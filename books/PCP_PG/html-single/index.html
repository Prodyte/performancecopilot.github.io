<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns:d="http://docbook.org/ns/docbook">Performance Co-Pilot™ Programmer's Guide</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.2" /><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content="PCP-pcp-programmers-guide-3-en-US-4.0-4" /></head><body><p id="title"><a class="left" href="https://fedorahosted.org/publican"><img alt="Product Site" src="Common_Content/images//image_left.png" /></a><a class="right" href="https://fedorahosted.org/publican"><img alt="Documentation Site" src="Common_Content/images//image_right.png" /></a></p><div xml:lang="en-US" class="book" lang="en-US"><div class="titlepage"><div><div><h1 class="title"><a id="idm140437911407056"></a>Performance Co-Pilot™ Programmer's Guide</h1></div><p xmlns:d="http://docbook.org/ns/docbook" class="edition">Edition 3</p><div><div class="othercredit"><h3 class="othercredit"></h3><span class="contrib">Maintained by</span> <div class="affiliation"><span xmlns:d="http://docbook.org/ns/docbook" class="orgname">The Performance Co-Pilot Development Team</span><div class="address"><div class="para"><br />
          <code class="email"><a class="email" href="mailto:pcp@groups.io">pcp@groups.io</a></code><br />
				<br />
          <span class="otheraddr"> <a href="http://pcp.io">http://pcp.io</a> <span class="inlinemediaobject"><object data="images/pcp.svg" type="image/svg+xml"><img src="images/pcp.png" alt="" /></object></span><br />
				 </span><br />
</div></div></div></div></div><div><p class="copyright">Copyright © 2000, 2013 Silicon Graphics, Inc.</p></div><div><p class="copyright">Copyright © 2013, 2015, 2016 Red Hat, Inc.</p></div><div><div class="legalnotice"><a id="idm140437912660784"></a><h1 class="legalnotice">Legal Notice</h1><p class="legalnotice-title"><strong>LICENSE</strong></p><div class="para">
				Permission is granted to copy, distribute, and/or modify this document under the terms of the Creative Commons Attribution-Share Alike, Version 3.0 or any later version published by the Creative Commons Corp. A copy of the license is available at <a href="http://creativecommons.org/licenses/by-sa/3.0/us/">http://creativecommons.org/licenses/by-sa/3.0/us/</a>
			</div></div></div><div><div class="legalnotice"><a id="idm140437912658512"></a><h1 class="legalnotice">Legal Notice</h1><p class="legalnotice-title"><strong>TRADEMARKS AND ATTRIBUTIONS</strong></p><div class="para">
				Silicon Graphics, SGI and the SGI logo are registered trademarks and Performance Co-Pilot is a trademark of Silicon Graphics, Inc.
			</div><div class="para">
				Red Hat and the Shadowman logo are trademarks of Red Hat, Inc., registered in the United States and other countries.
			</div><div class="para">
				Cisco is a registered trademark of Cisco Systems, Inc. Linux is a registered trademark of Linus Torvalds, used with permission. UNIX is a registered trademark of The Open Group.
			</div></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="preface"><a href="#id5178752">About This Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#id5178771">1. What This Guide Contains</a></span></dt><dt><span class="section"><a href="#id5178891">2. Audience for This Guide</a></span></dt><dt><span class="section"><a href="#id5178933">3. Related Resources</a></span></dt><dt><span class="section"><a href="#id5178968">4. Man Pages</a></span></dt><dt><span class="section"><a href="#id5179157">5. Web Site</a></span></dt><dt><span class="section"><a href="#id5179276">6. Conventions</a></span></dt><dt><span class="section"><a href="#z825546061melby">7. Reader Comments</a></span></dt></dl></dd><dt><span class="chapter"><a href="#LE21795-PARENT">1. Programming Performance Co-Pilot</a></span></dt><dd><dl><dt><span class="section"><a href="#id5177140">1.1. PCP Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#id5177343">1.1.1. Distributed Collection</a></span></dt><dt><span class="section"><a href="#id5177529">1.1.2. Name Space</a></span></dt><dt><span class="section"><a href="#id5177616">1.1.3. Distributed PMNS</a></span></dt><dt><span class="section"><a href="#id5177692">1.1.4. Retrospective Sources of Performance Metrics</a></span></dt></dl></dd><dt><span class="section"><a href="#LE13618-PARENT">1.2. Overview of Component Software</a></span></dt><dd><dl><dt><span class="section"><a href="#id5177879">1.2.1. Application and Agent Development</a></span></dt></dl></dd><dt><span class="section"><a href="#LE16056-PARENT">1.3. PMDA Development</a></span></dt><dd><dl><dt><span class="section"><a href="#id5178205">1.3.1. Overview</a></span></dt><dt><span class="section"><a href="#id5178242">1.3.2. Building a PMDA</a></span></dt></dl></dd><dt><span class="section"><a href="#id5178467">1.4. Client Development and PMAPI</a></span></dt><dt><span class="section"><a href="#id5187605">1.5. Library Reentrancy and Threaded Applications</a></span></dt></dl></dd><dt><span class="chapter"><a href="#LE98072-PARENT">2. Writing a PMDA</a></span></dt><dd><dl><dt><span class="section"><a href="#id5187772">2.1. Implementing a PMDA</a></span></dt><dt><span class="section"><a href="#id5188149">2.2. PMDA Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#id5188221">2.2.1. Overview</a></span></dt><dt><span class="section"><a href="#LE82676-PARENT">2.2.2. DSO PMDA</a></span></dt><dt><span class="section"><a href="#id5188840">2.2.3. Daemon PMDA</a></span></dt><dt><span class="section"><a href="#id5189181">2.2.4. Caching PMDA</a></span></dt></dl></dd><dt><span class="section"><a href="#LE97285-PARENT">2.3. Domains, Metrics, and Instances</a></span></dt><dd><dl><dt><span class="section"><a href="#id5189300">2.3.1. Overview</a></span></dt><dt><span class="section"><a href="#id5189538">2.3.2. Domains</a></span></dt><dt><span class="section"><a href="#LE98565-PARENT">2.3.3. Metrics</a></span></dt><dt><span class="section"><a href="#id5190481">2.3.4. Instances</a></span></dt></dl></dd><dt><span class="section"><a href="#id5191164">2.4. Other Issues</a></span></dt><dd><dl><dt><span class="section"><a href="#id5191177">2.4.1. Extracting the Information</a></span></dt><dt><span class="section"><a href="#id5191305">2.4.2. Latency and Threads of Control</a></span></dt><dt><span class="section"><a href="#LE83854-PARENT">2.4.3. Name Space</a></span></dt><dt><span class="section"><a href="#LE72473-PARENT">2.4.4. PMDA Help Text</a></span></dt><dt><span class="section"><a href="#id5191869">2.4.5. Management of Evolution within a PMDA</a></span></dt></dl></dd><dt><span class="section"><a href="#LE21831-PARENT">2.5. PMDA Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#id5192358">2.5.1. Overview</a></span></dt><dt><span class="section"><a href="#id5193658">2.5.2. PMDA Structures</a></span></dt></dl></dd><dt><span class="section"><a href="#LE19047-PARENT">2.6. Initializing a PMDA</a></span></dt><dd><dl><dt><span class="section"><a href="#id5194056">2.6.1. Overview</a></span></dt><dt><span class="section"><a href="#id5194087">2.6.2. Common Initialization</a></span></dt><dt><span class="section"><a href="#id5194563">2.6.3. Daemon Initialization</a></span></dt></dl></dd><dt><span class="section"><a href="#id5194770">2.7. Testing and Debugging a PMDA</a></span></dt><dd><dl><dt><span class="section"><a href="#id5194836">2.7.1. Overview</a></span></dt><dt><span class="section"><a href="#id5195016">2.7.2. Debugging Information</a></span></dt><dt><span class="section"><a href="#id5195283">2.7.3.  <code class="command">dbpmda</code> Debug Utility</a></span></dt></dl></dd><dt><span class="section"><a href="#id5195340">2.8. Integration of a PMDA</a></span></dt><dd><dl><dt><span class="section"><a href="#LE55181-PARENT">2.8.1. Installing a PMDA</a></span></dt><dt><span class="section"><a href="#id5197100">2.8.2. Upgrading a PMNS to Include Metrics from a New PMDA</a></span></dt><dt><span class="section"><a href="#Z976310185sdc">2.8.3. Removing a PMDA</a></span></dt><dt><span class="section"><a href="#id5197301">2.8.4. Configuring PCP Tools</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#LE97135-PARENT">3. PMAPI--The Performance Metrics API</a></span></dt><dd><dl><dt><span class="section"><a href="#LE87626-PARENT">3.1. Naming and Identifying Performance Metrics</a></span></dt><dt><span class="section"><a href="#id5197718">3.2. Performance Metric Instances</a></span></dt><dt><span class="section"><a href="#id5198049">3.3. Current PMAPI Context</a></span></dt><dt><span class="section"><a href="#LE11914-PARENT">3.4. Performance Metric Descriptions</a></span></dt><dt><span class="section"><a href="#LE82331-PARENT">3.5. Performance Metrics Values</a></span></dt><dt><span class="section"><a href="#id5199202">3.6. Performance Event Metrics</a></span></dt><dd><dl><dt><span class="section"><a href="#id5199203nat">3.6.1. Event Monitor Considerations</a></span></dt><dt><span class="section"><a href="#id5199204nat">3.6.2. Event Collector Considerations</a></span></dt></dl></dd><dt><span class="section"><a href="#id5199203">3.7. PMAPI Programming Style and Interaction</a></span></dt><dd><dl><dt><span class="section"><a href="#LE37655-PARENT">3.7.1. Variable Length Argument and Results Lists</a></span></dt><dt><span class="section"><a href="#idm140437843077872">3.7.2. Python Specific Issues</a></span></dt><dt><span class="section"><a href="#LE62826-PARENT">3.7.3. PMAPI Error Handling</a></span></dt></dl></dd><dt><span class="section"><a href="#id5199561">3.8. PMAPI Procedural Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#LE32034-PARENT">3.8.1. PMAPI Name Space Services</a></span></dt><dt><span class="section"><a href="#LE89521-PARENT">3.8.2. PMAPI Metrics Description Services</a></span></dt><dt><span class="section"><a href="#LE27200-PARENT">3.8.3. PMAPI Instance Domain Services</a></span></dt><dt><span class="section"><a href="#LE94187-PARENT">3.8.4. PMAPI Context Services</a></span></dt><dt><span class="section"><a href="#LE34685-PARENT">3.8.5. PMAPI Timezone Services</a></span></dt><dt><span class="section"><a href="#LE25844-PARENT">3.8.6. PMAPI Metrics Services</a></span></dt><dt><span class="section"><a href="#fetchgroup">3.8.7. PMAPI Fetchgroup Services</a></span></dt><dt><span class="section"><a href="#LE40692-PARENT">3.8.8. PMAPI Record-Mode Services</a></span></dt><dt><span class="section"><a href="#LE85604-PARENT">3.8.9. PMAPI Archive-Specific Services</a></span></dt><dt><span class="section"><a href="#LE73955-PARENT">3.8.10. PMAPI Time Control Services</a></span></dt><dt><span class="section"><a href="#LE44064-PARENT">3.8.11. PMAPI Ancillary Support Services</a></span></dt></dl></dd><dt><span class="section"><a href="#id5212196">3.9. PMAPI Programming Issues and Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#id5212297">3.9.1. Symbolic Association between a Metric's Name and Value</a></span></dt><dt><span class="section"><a href="#id5212519">3.9.2. Initializing New Metrics</a></span></dt><dt><span class="section"><a href="#id5212595">3.9.3. Iterative Processing of Values</a></span></dt><dt><span class="section"><a href="#id5212682">3.9.4. Accommodating Program Evolution</a></span></dt><dt><span class="section"><a href="#id5212805">3.9.5. Handling PMAPI Errors</a></span></dt><dt><span class="section"><a href="#id5212855">3.9.6. Compiling and Linking PMAPI Applications</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#LE25915-PARENT">4. Instrumenting Applications</a></span></dt><dd><dl><dt><span class="section"><a href="#id5213105">4.1. Application and Performance Co-Pilot Relationship</a></span></dt><dt><span class="section"><a href="#id5213104">4.2. Performance Instrumentation and Sampling</a></span></dt><dt><span class="section"><a href="#id5213287nat">4.3. MMV PMDA Design</a></span></dt><dt><span class="section"><a href="#id5213288nat">4.4. Memory Mapped Values API</a></span></dt><dd><dl><dt><span class="section"><a href="#id5214320nat">4.4.1. Starting and Stopping Instrumentation</a></span></dt><dt><span class="section"><a href="#idm140437898995056">4.4.2. Getting a Handle on Mapped Values</a></span></dt><dt><span class="section"><a href="#idm140437898986192">4.4.3. Updating Mapped Values</a></span></dt><dt><span class="section"><a href="#id5214734">4.4.4. Elapsed Time Measures</a></span></dt></dl></dd><dt><span class="section"><a href="#id5213106">4.5. Performance Instrumentation and Tracing</a></span></dt><dt><span class="section"><a href="#id5213287">4.6. Trace PMDA Design</a></span></dt><dd><dl><dt><span class="section"><a href="#id5213308">4.6.1. Application Interaction</a></span></dt><dt><span class="section"><a href="#id5213449">4.6.2. Sampling Techniques</a></span></dt><dt><span class="section"><a href="#id5213903">4.6.3. Configuring the Trace PMDA</a></span></dt></dl></dd><dt><span class="section"><a href="#LE26087-PARENT">4.7. Trace API</a></span></dt><dd><dl><dt><span class="section"><a href="#id5214320">4.7.1. Transactions </a></span></dt><dt><span class="section"><a href="#id5214714">4.7.2. Point Tracing </a></span></dt><dt><span class="section"><a href="#id5214931">4.7.3. Observations and Counters</a></span></dt><dt><span class="section"><a href="#id5215241">4.7.4. Configuring the Trace Library</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#LE54271-PARENT">A. Acronyms</a></span></dt><dt><span class="index"><a href="#sgi-index">Index</a></span></dt></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a id="id5178752">
      ⁠</a>About This Guide</h1></div></div></div><div class="para">
			This guide describes how to program the Performance Co-Pilot (PCP) performance analysis toolkit. PCP provides a systems-level suite of tools that cooperate to deliver distributed performance monitoring and performance management services spanning hardware platforms, operating systems, service layers, database internals, user applications and distributed architectures.
		</div><div class="para">
			PCP is an open source, cross-platform software package - customizations, extensions, source code inspection, and tinkering in general is actively encouraged.
		</div><div class="para">
			“About This Guide” includes short descriptions of the chapters in this book, directs you to additional sources of information, and explains typographical conventions.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5178771">
      ⁠</a>1. What This Guide Contains</h2></div></div></div><div class="para">
				This guide contains the following chapters:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						<a class="xref" href="#LE21795-PARENT">Chapter 1, <em>Programming Performance Co-Pilot</em></a>, contains a thumbnail sketch of how to program the various PCP components.
					</div></li><li class="listitem"><div class="para">
						<a class="xref" href="#LE98072-PARENT">Chapter 2, <em>Writing a PMDA</em></a>, describes how to write Performance Metrics Domain Agents (PMDAs) for PCP.
					</div></li><li class="listitem"><div class="para">
						<a class="xref" href="#LE97135-PARENT">Chapter 3, <em>PMAPI--The Performance Metrics API</em></a>, describes the interface that allows you to design custom performance monitoring tools.
					</div></li><li class="listitem"><div class="para">
						<a class="xref" href="#LE25915-PARENT">Chapter 4, <em>Instrumenting Applications</em></a>, introduces techniques, tools and interfaces to assist with exporting performance data from within applications.
					</div></li><li class="listitem"><div class="para">
						<a class="xref" href="#LE54271-PARENT">Appendix A, <em>Acronyms</em></a>, provides a comprehensive list of the acronyms used in this guide, in the PCP man pages, and in the release notes.
					</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5178891">
      ⁠</a>2. Audience for This Guide</h2></div></div></div><div class="para">
				The guide describes the programming interfaces to Performance Co-Pilot (PCP) for the following intended audience:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						Performance analysts or system administrators who want to extend or customize performance monitoring tools available with PCP
					</div></li><li class="listitem"><div class="para">
						Developers who wish to integrate performance data from within their applications into the PCP framework
					</div></li></ul></div><div class="para">
				This book is written for those who are competent with the C programming language, the UNIX or the Linux operating systems, and the target domain from which the desired performance metrics are to be extracted. Familiarity with the PCP tool suite is assumed.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5178933">
      ⁠</a>3. Related Resources</h2></div></div></div><div class="para">
				The <em class="citetitle">Performance Co-Pilot User's and Administrator's Guide</em> is a companion document to the <em class="citetitle">Performance Co-Pilot Programmer's Guide</em>, and is intended for system administrators and performance analysts who are directly using and administering PCP installations.
			</div><div class="para">
				The <em class="citetitle">Performance Co-Pilot Tutorials and Case Studies</em> provides a series of real-world examples of using various PCP tools, and lessons learned from deploying the toolkit in production environments. It serves to provide reinforcement of the general concepts discussed in the other two books with additional case studies, and in some cases very detailed discussion of specifics of individual tools.
			</div><div class="para">
				Additional resources include man pages and the project web site.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5178968">
      ⁠</a>4. Man Pages</h2></div></div></div><div class="para">
				The operating system man pages provide concise reference information on the use of commands, subroutines, and system resources. There is usually a man page for each PCP command or subroutine. To see a list of all the PCP man pages, start from the following command:
			</div><pre class="literallayout">
        <strong class="userinput"><code>man PCPIntro</code></strong>
</pre><div class="para">
				Each man page usually has a "SEE ALSO" section, linking to other, related entries.
			</div><div class="para">
				To see a particular man page, supply its name to the <code class="literal">man</code> command, for example:
			</div><pre class="literallayout">
        <strong class="userinput"><code>man pcp</code></strong>
</pre><div class="para">
				The man pages are arranged in different sections separating commands, programming interfaces, and so on. For a complete list of manual sections on a platform enter the command:
			</div><pre class="literallayout">
        <strong class="userinput"><code>man man</code></strong>
</pre><div class="para">
				When referring to man pages, this guide follows a standard convention: the section number in parentheses follows the item. For example, <code class="command">pminfo(1)</code> refers to the man page in section 1 for the <code class="command">pminfo</code> command.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5179157">
      ⁠</a>5. Web Site</h2></div></div></div><div class="para">
				The following web site is accessible to everyone:
			</div><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <span class="bold bold"><strong>URL</strong></span> </span></dt><dd><div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div></dd><dt><span class="term"> <a href="http://pcp.io">http://pcp.io</a> </span></dt><dd><div class="para">
							PCP is open source software released under the GNU General Public License (GPL) and GNU Lesser General Public License (LGPL)
						</div></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5179276">
      ⁠</a>6. Conventions</h2></div></div></div><div class="para">
				The following conventions are used throughout this document:
				<div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="bold bold"><strong>Convention</strong></span></span></dt><dd><div class="para">
								<span class="bold bold"><strong>Meaning</strong></span>
							</div></dd><dt><span class="term"><code class="literal">${PCP_VARIABLE}</code></span></dt><dd><div class="para">
								A brace-enclosed all-capital-letters syntax indicates a variable that has been sourced from the global <code class="filename">/etc/pcp.conf</code> file. These special variables indicate parameters that affect all PCP commands, and are likely to be different between platforms.
							</div></dd><dt><span class="term"><code class="literal">command</code></span></dt><dd><div class="para">
								This fixed-space font denotes literal items such as commands, files, routines, path names, signals, messages, and programming language structures.
							</div></dd><dt><span class="term"><em class="replaceable">variable</em></span></dt><dd><div class="para">
								Italic typeface denotes variable entries and words or concepts being defined.
							</div></dd><dt><span class="term"><strong class="userinput"><code>user input</code></strong></span></dt><dd><div class="para">
								This bold, fixed-space font denotes literal items that the user enters in interactive sessions. (Output is shown in nonbold, fixed-space font.)
							</div></dd><dt><span class="term">[ ]</span></dt><dd><div class="para">
								Brackets enclose optional portions of a command or directive line.
							</div></dd><dt><span class="term">...</span></dt><dd><div class="para">
								Ellipses indicate that a preceding element can be repeated.
							</div></dd><dt><span class="term">ALL CAPS</span></dt><dd><div class="para">
								All capital letters denote environment variables, operator names, directives, defined constants, and macros in C programs.
							</div></dd><dt><span class="term">()</span></dt><dd><div class="para">
								Parentheses that follow function names surround function arguments or are empty if the function has no arguments; parentheses that follow commands surround man page section numbers.
							</div></dd></dl></div>
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="z825546061melby">
      ⁠</a>7. Reader Comments</h2></div></div></div><div class="para">
				If you have comments about the technical accuracy, content, or organization of this document, contact the PCP maintainers using either the email address or the web site listed earlier.
			</div><div class="para">
				We value your comments and will respond to them promptly.
			</div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="LE21795-PARENT">
      ⁠</a>Chapter 1. Programming Performance Co-Pilot</h1></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="#id5177140">1.1. PCP Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#id5177343">1.1.1. Distributed Collection</a></span></dt><dt><span class="section"><a href="#id5177529">1.1.2. Name Space</a></span></dt><dt><span class="section"><a href="#id5177616">1.1.3. Distributed PMNS</a></span></dt><dt><span class="section"><a href="#id5177692">1.1.4. Retrospective Sources of Performance Metrics</a></span></dt></dl></dd><dt><span class="section"><a href="#LE13618-PARENT">1.2. Overview of Component Software</a></span></dt><dd><dl><dt><span class="section"><a href="#id5177879">1.2.1. Application and Agent Development</a></span></dt></dl></dd><dt><span class="section"><a href="#LE16056-PARENT">1.3. PMDA Development</a></span></dt><dd><dl><dt><span class="section"><a href="#id5178205">1.3.1. Overview</a></span></dt><dt><span class="section"><a href="#id5178242">1.3.2. Building a PMDA</a></span></dt></dl></dd><dt><span class="section"><a href="#id5178467">1.4. Client Development and PMAPI</a></span></dt><dt><span class="section"><a href="#id5187605">1.5. Library Reentrancy and Threaded Applications</a></span></dt></dl></div><div class="para">
			<a id="IG313401770" class="indexterm"></a>Performance Co-Pilot (PCP) provides a systems-level suite of tools that cooperate to deliver distributed, integrated performance management services. PCP is designed for the in-depth analysis and sophisticated control that are needed to understand and manage the hardest performance problems in the most complex systems.
		</div><div class="para">
			PCP provides unparalleled power to quickly isolate and understand performance behavior, resource utilization, activity levels and performance bottlenecks.
		</div><div class="para">
			Performance data may be collected and exported from multiple sources, most notably the hardware platform, the operating system kernel, layered services, and end-user applications.
		</div><div class="para">
			<a id="IG313401771" class="indexterm"></a> <a id="IG313401772" class="indexterm"></a>There are several ways to extend PCP by programming certain of its components:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a id="Z963349317sdc" class="indexterm"></a> <a id="IG313401773" class="indexterm"></a>By writing a Performance Metrics Domain Agent (PMDA) to collect performance metrics from an uncharted performance domain (<a class="xref" href="#LE98072-PARENT">Chapter 2, <em>Writing a PMDA</em></a>)
				</div></li><li class="listitem"><div class="para">
					<a id="Z963349400sdc" class="indexterm"></a> <a id="IG313401774" class="indexterm"></a>By creating new analysis or visualization tools using documented functions from the Performance Metrics Application Programming Interface (PMAPI) (<a class="xref" href="#LE97135-PARENT">Chapter 3, <em>PMAPI--The Performance Metrics API</em></a>)
				</div></li><li class="listitem"><div class="para">
					<a id="IG313401775" class="indexterm"></a> <a id="IG313401776" class="indexterm"></a>By adding performance instrumentation to an application using facilities from PCP libraries, which offer both sampling and event tracing models.
				</div></li></ul></div><div class="para">
			<a id="IG313401777" class="indexterm"></a>Finally, the topic of customizing an installation is covered in the chapter on customizing and extending PCP service in the <em class="citetitle">Performance Co-Pilot User's and Administrator's Guide</em>.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5177140">
      ⁠</a>1.1. PCP Architecture</h2></div></div></div><div class="para">
				<a id="IG313401778" class="indexterm"></a>This section gives a brief overview of PCP architecture. For an explanation of terms and acronyms, refer to <a class="xref" href="#LE54271-PARENT">Appendix A, <em>Acronyms</em></a>.
			</div><div class="para">
				<a id="IG313401779" class="indexterm"></a> <a id="IG3134017711" class="indexterm"></a> <a id="IG3134017712" class="indexterm"></a>PCP consists of numerous monitoring and collecting tools. <code class="literal">Monitoring tools</code> such as <code class="command">pmval</code> and <code class="command">pminfo</code> report on metrics, but have minimal interaction with target systems. <code class="literal">Collection tools</code>, called PMDAs, extract performance values from target systems, but do not provide user interfaces.
			</div><div class="para">
				Systems supporting PCP services are broadly classified into two categories:
			</div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Collector</span></dt><dd><div class="para">
							Hosts that have the PMCD and one or more PMDAs running to collect and export performance metrics
						</div></dd><dt><span class="term">Monitor</span></dt><dd><div class="para">
							Hosts that import performance metrics from one or more collector hosts to be consumed by tools to monitor, manage, or record the performance of the collector hosts
						</div></dd></dl></div><div class="para">
				Each PCP enabled host can operate as a collector, or a monitor, or both.
			</div><div class="para">
				<a class="xref" href="#id5177328">Figure 1.1, “PCP Global Process Architecture”</a> shows the architecture of PCP. The monitoring tools consume and process performance data using a public interface, the Performance Metrics Application Programming Interface (PMAPI).
			</div><div class="para">
				<a id="IG3134017713" class="indexterm"></a> <a id="IG3134017714" class="indexterm"></a>Below the PMAPI level is the PMCD process, which acts in a coordinating role, accepting requests from clients, routing requests to one or more PMDAs, aggregating responses from the PMDAs, and responding to the requesting client.
			</div><div class="para">
				Each performance metric domain (such as the operating system kernel or a database management system) has a well-defined name space for referring to the specific performance metrics it knows how to collect.
			</div><div class="para">
				<div class="figure"><a id="id5177328">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><object data="images/local-collector.svg" type="image/svg+xml"><img src="images/local-collector.png" alt="PCP Global Process Architecture" /></object></div></div><p class="title"><strong>Figure 1.1. PCP Global Process Architecture</strong></p></div>

			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5177343">
      ⁠</a>1.1.1. Distributed Collection</h3></div></div></div><div class="para">
					<a id="IG3134017715" class="indexterm"></a> <a id="IG3134017716" class="indexterm"></a> <a id="IG3134017717" class="indexterm"></a>The performance metrics collection architecture is distributed, in the sense that any monitoring tool may be executing remotely. However, a PMDA is expected to be running on the operating system for which it is collecting performance measurements; there are some notable PMDAs such as Cisco and Cluster that are exceptions, and collect performance data from remote systems.
				</div><div class="para">
					<a id="IG3134017718" class="indexterm"></a> <a id="IG3134017719" class="indexterm"></a>As shown in <a class="xref" href="#id5177408">Figure 1.2, “Process Structure for Distributed Operation”</a>, monitoring tools communicate only with PMCD. The PMDAs are controlled by PMCD and respond to requests from the monitoring tools that are forwarded by PMCD to the relevant PMDAs on the collector host.
				</div><div class="para">
					<div class="figure"><a id="id5177408">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><object data="images/remote-collector.svg" type="image/svg+xml"><img src="images/remote-collector.png" alt="Process Structure for Distributed Operation" /></object></div></div><p class="title"><strong>Figure 1.2. Process Structure for Distributed Operation</strong></p></div>

				</div><div class="para">
					The host running the monitoring tools does not require any collection tools, including PMCD, since all requests for metrics are sent to the PMCD process on the collector host.
				</div><div class="para">
					<a id="IG3134017720" class="indexterm"></a> <a id="IG3134017721" class="indexterm"></a>The connections between monitoring tools and PMCD processes are managed in <code class="filename">libpcp</code>, below the PMAPI level; see the <code class="command">PMAPI(3)</code> man page. Connections between PMDAs and PMCD are managed by the PMDA functions; see the <code class="command">PMDA(3)</code> and <code class="command">pmcd(1)</code> man pages. There can be multiple monitor clients and multiple PMDAs on the one host, but there may be only one PMCD process.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5177529">
      ⁠</a>1.1.2. Name Space</h3></div></div></div><div class="para">
					<a id="IG3134017722" class="indexterm"></a> <a id="IG3134017723" class="indexterm"></a> <a id="IG3134017724" class="indexterm"></a>Each PMDA provides a domain of metrics, whether they be for the operating system, a database manager, a layered service, or an application module. These metrics are referred to by name inside the user interface, and with a numeric Performance Metric Identifier (PMID) within the underlying PMAPI.
				</div><div class="para">
					<a id="IG3134017725" class="indexterm"></a> <a id="IG3134017726" class="indexterm"></a> <a id="IG3134017727" class="indexterm"></a>The PMID consists of three fields: the domain, the cluster, and the item number of the metric. The domain is a unique number assigned to each PMDA. For example, two metrics with the same domain number must be from the same PMDA. The cluster and item numbers allow metrics to be easily organized into groups within the PMDA, and provide a hierarchical taxonomy to guarantee uniqueness within each PMDA.
				</div><div class="para">
					<a id="IG3134017728" class="indexterm"></a>The Performance Metrics Name Space (PMNS) describes the exported performance metrics, in particular the mapping from PMID to external name, and vice-versa.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5177616">
      ⁠</a>1.1.3. Distributed PMNS</h3></div></div></div><div class="para">
					<a id="IG3134017729" class="indexterm"></a> Performance metric namespace (PMNS) operations are directed by default to the host or set of archives that is the source of the desired performance metrics.
				</div><div class="para">
					In <a class="xref" href="#id5177408">Figure 1.2, “Process Structure for Distributed Operation”</a>, both Performance Metrics Collection Daemon (PMCD) processes would respond to PMNS queries from monitoring tools by referring to their local PMNS. If different PMDAs were installed on the two hosts, then the PMNS used by each PMCD would be different, to reflect variations in available metrics on the two hosts.
				</div><div class="para">
					Although extremely rarely used, the <code class="command">-n</code> <em class="replaceable">pmnsfile</em> command line option may be used with many PCP monitoring tools to force use of a local PMNS file in preference to the PMNS at the source of the metrics.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5177692">
      ⁠</a>1.1.4. Retrospective Sources of Performance Metrics</h3></div></div></div><div class="para">
					<a id="IG3134017730" class="indexterm"></a>The distributed collection architecture described in the previous section is used when PMAPI clients are requesting performance metrics from a real-time or live source.
				</div><div class="para">
					<a id="IG3134017731" class="indexterm"></a>The PMAPI also supports delivery of performance metrics from a historical source in the form of a PCP archive log. Archive logs are created using the <code class="command">pmlogger</code> utility, and are replayed in an architecture as shown in <a class="xref" href="#id5177742">Figure 1.3, “Architecture for Retrospective Analysis”</a>.
				</div><div class="para">
					<div class="figure"><a id="id5177742">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><object data="images/retrospective-architecture.svg" type="image/svg+xml"><img src="images/retrospective-architecture.png" alt="Architecture for Retrospective Analysis" /></object></div></div><p class="title"><strong>Figure 1.3. Architecture for Retrospective Analysis</strong></p></div>

				</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="LE13618-PARENT">
      ⁠</a>1.2. Overview of Component Software</h2></div></div></div><div class="para">
				<a id="IG3134017732" class="indexterm"></a> <a id="IG3134017733" class="indexterm"></a>Performance Co-Pilot (PCP) is composed of text-based tools, optional graphical tools, and related commands. Each tool or command is fully documented by a man page. These man pages are named after the tools or commands they describe, and are accessible through the <code class="command">man</code> command. For example, to see the <code class="command">pminfo(1)</code> man page for the <code class="command">pminfo</code> command, enter this command:
<pre class="literallayout"><strong class="userinput"><code>man pminfo</code></strong></pre>
			</div><div class="para">
				A list of PCP developer tools and commands, grouped by functionality, is provided in the following section.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5177879">
      ⁠</a>1.2.1. Application and Agent Development</h3></div></div></div><div class="para">
					<a id="ITch01-114" class="indexterm"></a> <a id="IG3134017734" class="indexterm"></a>The following PCP tools aid the development of new programs to consume performance data, and new agents to export performance data within the PCP framework:
				</div><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <code class="command">chkhelp</code> </span></dt><dd><div class="para">
								<a id="IG3134017735" class="indexterm"></a>Checks the consistency of performance metrics help database files.
							</div></dd><dt><span class="term"> <code class="command">dbpmda</code> </span></dt><dd><div class="para">
								<a id="IG3134017736" class="indexterm"></a>Allows PMDA behavior to be exercised and tested. It is an interactive debugger for PMDAs.
							</div></dd><dt><span class="term"> <code class="command">mmv</code> </span></dt><dd><div class="para">
								<a id="IG3134017742nat" class="indexterm"></a>Is used to instrument applications using Memory Mapped Values (MMV). These are values that are communicated with <code class="command">pmcd</code> instantly, and very efficiently, using a shared memory mapping. It is a program instrumentation library.
							</div></dd><dt><span class="term"> <code class="command">newhelp</code> </span></dt><dd><div class="para">
								<a id="IG3134017737" class="indexterm"></a>Generates the database files for one or more source files of PCP help text.
							</div></dd><dt><span class="term"> <code class="command">pmapi</code> </span></dt><dd><div class="para">
								<a id="IG3134017738" class="indexterm"></a> <a id="IG3134017739" class="indexterm"></a> <a id="IG3134017740" class="indexterm"></a>Defines a procedural interface for developing PCP client applications. It is the Performance Metrics Application Programming Interface (PMAPI).
							</div></dd><dt><span class="term"> <code class="literal">pmclient</code> </span></dt><dd><div class="para">
								<a id="IG3134017741" class="indexterm"></a>Is a simple client that uses the PMAPI to report some high-level system performance metrics. The source code for <code class="command">pmclient</code> is included in the distribution.
							</div></dd><dt><span class="term"> <code class="command">pmda</code> </span></dt><dd><div class="para">
								<a id="IG3134017742" class="indexterm"></a>Is a library used by many shipped PMDAs to communicate with a <code class="command">pmcd</code> process. It can expedite the development of new and custom PMDAs.
							</div></dd><dt><span class="term"> <code class="command">pmgenmap</code> </span></dt><dd><div class="para">
								<a id="IG3134017743" class="indexterm"></a>Generates C declarations and <code class="literal">cpp</code> macros to aid the development of customized programs that use the facilities of PCP. It is a program development tool.
							</div></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="LE16056-PARENT">
      ⁠</a>1.3. PMDA Development</h2></div></div></div><div class="para">
				<a id="IG3134017744" class="indexterm"></a>A collection of Performance Metrics Domain Agents (PMDAs) are provided with PCP to extract performance metrics. Each PMDA encapsulates domain-specific knowledge and methods about performance metrics that implement the uniform access protocols and functional semantics of the PCP. There is one PMDA for the operating system, another for process specific statistics, one each for common DBMS products, and so on. Thus, the range of performance metrics can be easily extended by implementing and integrating new PMDAs. <a class="xref" href="#LE98072-PARENT">Chapter 2, <em>Writing a PMDA</em></a>, is a step-by-step guide to writing your own PMDA.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5178205">
      ⁠</a>1.3.1. Overview</h3></div></div></div><div class="para">
					Once you are familiar with the PCP and PMDA frameworks, you can quickly implement a new PMDA with only a few data structures and functions. This book contains detailed discussions of PMDA architecture and the integration of PMDAs into the PCP framework. This includes integration with PMCD. However, details of extracting performance metrics from the underlying instrumentation vary from one domain to another and are not covered in this book.
				</div><div class="para">
					A PMDA is responsible for a set of performance metrics, in the sense that it must respond to requests from PMCD for information about performance metrics, instance domains, and instantiated values. The PMCD process generates requests on behalf of monitoring tools that make requests using PMAPI functions.
				</div><div class="para">
					You can incorporate new performance metrics into the PCP framework by creating a PMDA, then reconfiguring PMCD to communicate with the new PMDA.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5178242">
      ⁠</a>1.3.2. Building a PMDA</h3></div></div></div><div class="para">
					A PMDA interacts with PMCD across one of several well-defined interfaces and protocol mechanisms. These implementation options are described in the <em class="citetitle">Performance Co-Pilot User's and Administrator's Guide</em>.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						It is strongly recommended that code for a new PMDA be based on the source of one of the existing PMDAs below the <code class="filename">${PCP_PMDAS_DIR}</code> directory.
					</div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5178295">
      ⁠</a>1.3.2.1. In-Process (DSO) Method</h4></div></div></div><div class="para">
						<a id="IG3134017745" class="indexterm"></a> <a id="IG3134017746" class="indexterm"></a> <a id="IG3134017747" class="indexterm"></a> <a id="IG3134017748" class="indexterm"></a> <a id="IG3134017749" class="indexterm"></a>This method of building a PMDA uses a Dynamic Shared Object (DSO) that is attached by PMCD, using the platform-specific shared library manipulation interfaces such as <code class="command">dlopen(3)</code>, at initialization time. This is the highest performance option (there is no context switching and no interprocess communication (IPC) between the PMCD and the PMDA), but is operationally intractable in some situations. For example, difficulties arise where special access permissions are required to read the instrumentation behind the performance metrics (<code class="command">pmcd</code> does not run as root), or where the performance metrics are provided by an existing process with a different protocol interface. The DSO PMDA effectively executes as part of PMCD; so great care is required when crafting a PMDA in this manner. Calls to <code class="command">exit(1)</code> in the PMDA, or a library it uses, would cause PMCD to exit and end monitoring of that host. Other implications are discussed in <a class="xref" href="#id5188840">Section 2.2.3, “Daemon PMDA”</a>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5178384">
      ⁠</a>1.3.2.2. Daemon Process Method</h4></div></div></div><div class="para">
						<a id="IG3134017750" class="indexterm"></a>Functionally, this method may be thought of as a DSO implementation with a standard <code class="command">main</code> routine conversion wrapper so that communication with PMCD uses message passing rather than direct procedure calls. For some very basic examples, see the <code class="filename">${PCP_PMDAS_DIR}/trivial/trivial.c</code> and <code class="filename">${PCP_PMDAS_DIR}/simple/simple.c</code> source files.
					</div><div class="para">
						The daemon PMDA is actually the most common, because it allows multiple threads of control, greater (different user) privileges when executing, and provides more resilient error encapsulation than the DSO method.
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							Of particular interest for daemon PMDA writers, the <code class="filename">${PCP_PMDAS_DIR}/simple</code> PMDA has implementations in C, Perl and Python.
						</div></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5178467">
      ⁠</a>1.4. Client Development and PMAPI</h2></div></div></div><div class="para">
				<a id="IG3134017752" class="indexterm"></a>Application developers are encouraged to create new PCP client applications to monitor, display, and analyze performance data in a manner suited to their particular site, application suite, or information processing environment.
			</div><div class="para">
				<a id="IG3134017755" class="indexterm"></a>PCP client applications are programmed using the Performance Metrics Application Programming Interface (PMAPI), documented in <a class="xref" href="#LE97135-PARENT">Chapter 3, <em>PMAPI--The Performance Metrics API</em></a>. The PMAPI, which provides performance tool developers with access to all of the historical and live distributed services of PCP, is the interface used by the standard PCP utilities.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5187605">
      ⁠</a>1.5. Library Reentrancy and Threaded Applications</h2></div></div></div><div class="para">
				<a id="IG3134017756" class="indexterm"></a> <a id="IG3134017757" class="indexterm"></a> <a id="IG3134017758" class="indexterm"></a>While the core PCP library (<code class="command">libpcp</code>) is thread safe, the layered PMDA library (<code class="command">libpcp_pmda</code>) is not. This is a deliberate design decision to trade-off commonly required performance and efficiency against the less common requirement for multiple threads of control to call the PCP libraries.
			</div><div class="para">
				The simplest and safest programming model is to designate at most one thread to make calls into the PCP PMDA library.
			</div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="LE98072-PARENT">
      ⁠</a>Chapter 2. Writing a PMDA</h1></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="#id5187772">2.1. Implementing a PMDA</a></span></dt><dt><span class="section"><a href="#id5188149">2.2. PMDA Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#id5188221">2.2.1. Overview</a></span></dt><dt><span class="section"><a href="#LE82676-PARENT">2.2.2. DSO PMDA</a></span></dt><dt><span class="section"><a href="#id5188840">2.2.3. Daemon PMDA</a></span></dt><dt><span class="section"><a href="#id5189181">2.2.4. Caching PMDA</a></span></dt></dl></dd><dt><span class="section"><a href="#LE97285-PARENT">2.3. Domains, Metrics, and Instances</a></span></dt><dd><dl><dt><span class="section"><a href="#id5189300">2.3.1. Overview</a></span></dt><dt><span class="section"><a href="#id5189538">2.3.2. Domains</a></span></dt><dt><span class="section"><a href="#LE98565-PARENT">2.3.3. Metrics</a></span></dt><dt><span class="section"><a href="#id5190481">2.3.4. Instances</a></span></dt></dl></dd><dt><span class="section"><a href="#id5191164">2.4. Other Issues</a></span></dt><dd><dl><dt><span class="section"><a href="#id5191177">2.4.1. Extracting the Information</a></span></dt><dt><span class="section"><a href="#id5191305">2.4.2. Latency and Threads of Control</a></span></dt><dt><span class="section"><a href="#LE83854-PARENT">2.4.3. Name Space</a></span></dt><dt><span class="section"><a href="#LE72473-PARENT">2.4.4. PMDA Help Text</a></span></dt><dt><span class="section"><a href="#id5191869">2.4.5. Management of Evolution within a PMDA</a></span></dt></dl></dd><dt><span class="section"><a href="#LE21831-PARENT">2.5. PMDA Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#id5192358">2.5.1. Overview</a></span></dt><dt><span class="section"><a href="#id5193658">2.5.2. PMDA Structures</a></span></dt></dl></dd><dt><span class="section"><a href="#LE19047-PARENT">2.6. Initializing a PMDA</a></span></dt><dd><dl><dt><span class="section"><a href="#id5194056">2.6.1. Overview</a></span></dt><dt><span class="section"><a href="#id5194087">2.6.2. Common Initialization</a></span></dt><dt><span class="section"><a href="#id5194563">2.6.3. Daemon Initialization</a></span></dt></dl></dd><dt><span class="section"><a href="#id5194770">2.7. Testing and Debugging a PMDA</a></span></dt><dd><dl><dt><span class="section"><a href="#id5194836">2.7.1. Overview</a></span></dt><dt><span class="section"><a href="#id5195016">2.7.2. Debugging Information</a></span></dt><dt><span class="section"><a href="#id5195283">2.7.3.  <code class="command">dbpmda</code> Debug Utility</a></span></dt></dl></dd><dt><span class="section"><a href="#id5195340">2.8. Integration of a PMDA</a></span></dt><dd><dl><dt><span class="section"><a href="#LE55181-PARENT">2.8.1. Installing a PMDA</a></span></dt><dt><span class="section"><a href="#id5197100">2.8.2. Upgrading a PMNS to Include Metrics from a New PMDA</a></span></dt><dt><span class="section"><a href="#Z976310185sdc">2.8.3. Removing a PMDA</a></span></dt><dt><span class="section"><a href="#id5197301">2.8.4. Configuring PCP Tools</a></span></dt></dl></dd></dl></div><div class="para">
			<a id="IG3134017759" class="indexterm"></a>This chapter constitutes a programmer's guide to writing a Performance Metrics Domain Agent (PMDA) for Performance Co-Pilot (PCP).
		</div><div class="para">
			The presentation assumes the developer is using the standard PCP <code class="filename">libpcp_pmda</code> library, as documented in the <code class="command">PMDA(3)</code> and associated man pages.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5187772">
      ⁠</a>2.1. Implementing a PMDA</h2></div></div></div><div class="para">
				<a id="IG3134017760" class="indexterm"></a> <a id="IG3134017761" class="indexterm"></a>The job of a PMDA is to gather performance data and report them to the Performance Metrics Collection Daemon (PMCD) in response to requests from PCP monitoring tools routed to the PMDA via PMCD.
			</div><div class="para">
				An important requirement for any PMDA is that it have low latency response to requests from PMCD. Either the PMDA must use a quick access method and a single thread of control, or it must have asynchronous refresh and two threads of control: one for communicating with PMCD, the other for updating the performance data.
			</div><div class="para">
				<a id="IG3134017762" class="indexterm"></a> <a id="IG3134017763" class="indexterm"></a> <a id="IG3134017764" class="indexterm"></a> <a id="IG3134017765" class="indexterm"></a>The PMDA is typically acting as a gateway between the target domain (that is, the performance instrumentation in an application program or service) and the PCP framework. The PMDA may extract the information using one of a number of possible export options that include a shared memory segment or <code class="command">mmap</code> file; a sequential log file (where the PMDA parses the tail of the log file to extract the information); a snapshot file (the PMDA rereads the file as required); or application-specific communication services (IPC).
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					The choice of export methodology is typically determined by the source of the instrumentation (the target domain) rather than by the PMDA.
				</div></div></div><div class="para">
				<a id="IG3134017766" class="indexterm"></a> <a class="xref" href="#id5187871">Procedure 2.1, “Creating a PMDA”</a> describes the suggested steps for designing and implementing a PMDA:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="procedure"><a id="id5187871">
      ⁠</a><p class="title"><strong>Procedure 2.1. Creating a PMDA</strong></p><ol class="1"><li class="step"><div class="para">
						Determine how to extract the metrics from the target domain.
					</div></li><li class="step"><div class="para">
						Select an appropriate architecture for the PMDA (daemon or DSO, IPC, <code class="command">pthreads</code> or single threaded).
					</div></li><li class="step"><div class="para">
						Define the metrics and instances that the PMDA will support.
					</div></li><li class="step"><div class="para">
						Implement the functionality to extract the metric values.
					</div></li><li class="step"><div class="para">
						Assign Performance Metric Identifiers (PMIDs) for the metrics, along with names for the metrics in the Performance Metrics Name Space (PMNS). These concepts will be further expanded in <a class="xref" href="#LE97285-PARENT">Section 2.3, “Domains, Metrics, and Instances”</a>
					</div></li><li class="step"><div class="para">
						<a id="IG3134017767" class="indexterm"></a>Specify the help file and control data structures for metrics and instances that are required by the standard PMDA implementation library functions.
					</div></li><li class="step"><div class="para">
						Write code to supply the metrics and associated information to PMCD.
					</div></li><li class="step"><div class="para">
						Implement any PMDA-specific callbacks, and PMDA initialization functions.
					</div></li><li class="step"><div class="para">
						<a id="IG3134017768" class="indexterm"></a>Exercise and test the PMDA with the purpose-built PMDA debugger; see the <code class="command">dbpmda(1)</code> man page.
					</div></li><li class="step"><div class="para">
						Install and connect the PMDA to a running PMCD process; see the <code class="command">pmcd(1)</code> man page.
					</div></li><li class="step"><div class="para">
						<a id="IG3134017769" class="indexterm"></a> <a id="IG3134017770" class="indexterm"></a> <a id="IG3134017774" class="indexterm"></a>Configure or develop tools to use the new metrics. For examples of visualization tools, see the <code class="command">pmchart(1)</code> and <code class="command">pmgadgets(1)</code> man pages. For examples of text-based tools, see the <code class="command">pminfo(1)</code> and <code class="command">pmval(1)</code> man pages.
					</div></li><li class="step"><div class="para">
						<a id="IG3134017772" class="indexterm"></a> <a id="IG3134017773" class="indexterm"></a> <a id="IG3134017775" class="indexterm"></a>Where appropriate, define <code class="command">pmie</code> rule templates suitable for alerting or notification systems. For more information, see the <code class="command">pmie(1)</code> and <code class="command">pmieconf(1)</code> man pages.
					</div></li><li class="step"><div class="para">
						<a id="IG3134017776" class="indexterm"></a>Where appropriate, define <code class="command">pmlogger</code> configuration templates suitable for creating PCP archives containing the new metrics. For more information, see the <code class="command">pmlogconf(1)</code> and <code class="command">pmlogger(1)</code> man pages.
					</div></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5188149">
      ⁠</a>2.2. PMDA Architecture</h2></div></div></div><div class="para">
				<a id="IG3134017777" class="indexterm"></a> <a id="IG3134017778" class="indexterm"></a> <a id="IG3134017779" class="indexterm"></a>This section discusses the two methods of connecting a PMDA to a PMCD process:
				<div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							As a separate process using some interprocess communication (IPC) protocol.
						</div></li><li class="listitem"><div class="para">
							As a dynamically attached library (that is, a dynamic shared object or DSO).
						</div></li></ul></div>
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5188221">
      ⁠</a>2.2.1. Overview</h3></div></div></div><div class="para">
					<a id="IG3134017780" class="indexterm"></a> <a id="IG3134017781" class="indexterm"></a>All PMDAs are launched and controlled by the PMCD process on the local host. PMCD receives requests from the monitoring tools and forwards them to the PMDAs. Responses, when required, are returned through PMCD to the clients. The requests fall into a small number of categories, and the PMDA must handle each request type. For a DSO PMDA, each request type corresponds to a method in the agent. For a daemon PMDA, each request translates to a message or protocol data unit (PDU) that may be sent to a PMDA from PMCD.
				</div><div class="para">
					For a daemon PMDA, the following request PDUs must be supported:
					<div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">PDU_FETCH</code></span></dt><dd><div class="para">
									<a id="IG3134017782" class="indexterm"></a><a id="IG3134017783" class="indexterm"></a>Request for metric values (see the <code class="command">pmFetch(3)</code> man page.)
								</div></dd><dt><span class="term"><code class="literal">PDU_PROFILE</code></span></dt><dd><div class="para">
									<a id="IG3134017784" class="indexterm"></a><a id="IG3134017785" class="indexterm"></a>A list of instances required for the corresponding metrics in subsequent fetches (see the <code class="command">pmAddProfile(3)</code> man page).
								</div></dd><dt><span class="term"><code class="literal">PDU_INSTANCE_REQ</code></span></dt><dd><div class="para">
									<a id="IG3134017786" class="indexterm"></a><a id="IG3134017787" class="indexterm"></a> Request for a particular instance domain for instance descriptions (see the <code class="command">pmGetInDom(3)</code> man page).
								</div></dd><dt><span class="term"><code class="literal">PDU_DESC_REQ</code></span></dt><dd><div class="para">
									<a id="IG3134017788" class="indexterm"></a><a id="IG3134017789" class="indexterm"></a>Request for metadata describing metrics (see the <code class="command">pmLookupDesc(3)</code> man page).
								</div></dd><dt><span class="term"><code class="literal">PDU_TEXT_REQ</code></span></dt><dd><div class="para">
									<a id="IG3134017790" class="indexterm"></a><a id="IG3134017791" class="indexterm"></a><a id="IG3134017792" class="indexterm"></a>Request for metric help text (see the <code class="command">pmLookupText(3)</code> man page).
								</div></dd><dt><span class="term"><code class="literal">PDU_RESULT</code></span></dt><dd><div class="para">
									<a id="IG3134017793" class="indexterm"></a><a id="IG3134017794" class="indexterm"></a>Values to store into metrics (see the <code class="command">pmStore(3)</code> man page).
								</div></dd></dl></div>
				</div><div class="para">
					The following request PDUs may optionally be supported:
					<div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">PDU_PMNS_NAMES</code></span></dt><dd><div class="para">
									<a id="IG3134017782nat" class="indexterm"></a><a id="IG3134017783nat" class="indexterm"></a>Request for metric names, given one or more identifiers (see the <code class="command">pmLookupName(3)</code> man page.)
								</div></dd><dt><span class="term"><code class="literal">PDU_PMNS_CHILD</code></span></dt><dd><div class="para">
									<a id="IG3134017784nat" class="indexterm"></a><a id="IG3134017785nat" class="indexterm"></a>A list of immediate descendent nodes of a given namespace node (see the <code class="command">pmGetChildren(3)</code> man page).
								</div></dd><dt><span class="term"><code class="literal">PDU_PMNS_TRAVERSE</code></span></dt><dd><div class="para">
									<a id="IG3134017786nat" class="indexterm"></a><a id="IG3134017787nat" class="indexterm"></a>Request for a particular sub-tree of a given namespace node (see the <code class="command">pmTraversePMNS(3)</code> man page).
								</div></dd><dt><span class="term"><code class="literal">PDU_PMNS_IDS</code></span></dt><dd><div class="para">
									<a id="IG3134017788nat" class="indexterm"></a><a id="IG3134017789nat" class="indexterm"></a>Perform a reverse name lookup, mapping a metric identifier to a name (see the <code class="command">pmNameID(3)</code> man page).
								</div></dd><dt><span class="term"><code class="literal">PDU_AUTH</code></span></dt><dd><div class="para">
									<a id="IG3134017790nat" class="indexterm"></a><a id="IG3134017791nat" class="indexterm"></a>Handle connection attributes (key/value pairs), such as client credentials and other authentication information (see the <code class="command">__pmParseHostAttrsSpec(3)</code> man page).
								</div></dd></dl></div>
				</div><div class="para">
					Each PMDA is associated with a unique domain number that is encoded in the domain field of metric and instance identifiers, and PMCD uses the domain number to determine which PMDA can handle the components of any given client request.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE82676-PARENT">
      ⁠</a>2.2.2. DSO PMDA</h3></div></div></div><div class="para">
					<a id="IG3134017795" class="indexterm"></a> <a id="IG3134017796" class="indexterm"></a>Each PMDA is required to implement a function that handles each of the request types. By implementing these functions as library functions, a PMDA can be implemented as a dynamically shared object (DSO) and attached by PMCD at run time with a platform-specific call, such as <code class="command">dlopen</code>; see the <code class="command">dlopen(3)</code> man page. This eliminates the need for an IPC layer (typically a pipe) between each PMDA and PMCD, because each request becomes a function call rather than a message exchange. The required library functions are detailed in <a class="xref" href="#LE21831-PARENT">Section 2.5, “PMDA Interface”</a>.
				</div><div class="para">
					A PMDA that interacts with PMCD in this fashion must abide by a formal initialization protocol so that PMCD can discover the location of the library functions that are subsequently called with function pointers. When a DSO PMDA is installed, the PMCD configuration file, <code class="filename">${PCP_PMCDCONF_PATH}</code>, is updated to reflect the domain and name of the PMDA, the location of the shared object, and the name of the initialization function. The initialization sequence is discussed in <a class="xref" href="#LE19047-PARENT">Section 2.6, “Initializing a PMDA”</a>.
				</div><div class="para">
					<a id="IG3134017797" class="indexterm"></a>As superuser, install the simple PMDA as a DSO, as shown in <a class="xref" href="#Z1033502809tls">Example 2.1, “Simple PMDA as a DSO”</a>, and observe the changes in the PMCD configuration file. The output may differ slightly depending on the operating system you are using, any other PMDAs you have installed or any PMCD access controls you have in place.
				</div><div class="para">
					<div class="example"><a id="Z1033502809tls">
      ⁠</a><p class="title"><strong>Example 2.1. Simple PMDA as a DSO</strong></p><div class="example-contents"><pre class="programlisting">
              <strong class="userinput"><code>cat ${PCP_PMCDCONF_PATH}</code></strong>
# Performance Metrics Domain Specifications
# 
# This file is automatically generated during the build
# Name  Id      IPC     IPC Params      File/Cmd
pmcd    2       dso     pmcd_init       ${PCP_PMDAS_DIR}/pmcd/pmda_pmcd.so
linux   60      dso     linux_init      ${PCP_PMDAS_DIR}/linux/pmda_linux.so
proc    3       pipe    binary          ${PCP_PMDAS_DIR}/linux/pmda_proc.so -d 3
simple  254     dso     simple_init     ${PCP_PMDAS_DIR}/simple/pmda_simple.so</pre></div></div>

				</div><div class="para">
					As can be seen from the contents of <code class="filename">${PCP_PMCDCONF_PATH}</code>, the DSO version of the simple PMDA is in a library named <code class="filename">pmda_simple.so</code> and has an initialization function called <a id="IG3134017799" class="indexterm"></a> <code class="command">simple_init</code>. The domain of the simple PMDA is 254, as shown in the column headed <code class="literal">Id</code>.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						For some platforms the DSO file name will not be <code class="filename">pmda_simple.so</code>. On Mac OS X it is <code class="filename">pmda_simple.dylib</code> and on Windows it is <code class="filename">pmda_simple.dll</code>.
					</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5188840">
      ⁠</a>2.2.3. Daemon PMDA</h3></div></div></div><div class="para">
					<a id="IG31340177100" class="indexterm"></a>A DSO PMDA provides the most efficient communication between the PMDA and PMCD. This approach has some disadvantages resulting from the DSO PMDA being the same process as PMCD:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							An error or bug that causes a DSO PMDA to exit also causes PMCD to exit, which affects all connected client tools.
						</div></li><li class="listitem"><div class="para">
							There is only one thread of control in PMCD; as a result, a computationally expensive PMDA, or worse, a PMDA that blocks for I/O, adversely affects the performance of PMCD.
						</div></li><li class="listitem"><div class="para">
							PMCD runs as the "pcp" user; so all DSO PMDAs must also run as this user.
						</div></li><li class="listitem"><div class="para">
							A memory leak in a DSO PMDA also causes a memory leak for PMCD.
						</div></li></ul></div><div class="para">
					Consequently, many PMDAs are implemented as a daemon process.
				</div><div class="para">
					The <code class="filename">libpcp_pmda</code> library is designed to allow simple implementation of a PMDA that runs as a separate process. The library functions provide a message passing layer acting as a generic wrapper that accepts PDUs, makes library calls using the standard DSO PMDA interface, and sends PDUs. Therefore, you can implement a PMDA as a DSO and then install it as either a daemon or a DSO, depending on the presence or absence of the generic wrapper.
				</div><div class="para">
					<a id="IG31340177101" class="indexterm"></a> <a id="IG31340177102" class="indexterm"></a> <a id="IG31340177103" class="indexterm"></a>The PMCD process launches a daemon PMDA with <code class="command">fork</code> and <code class="command">execv</code> (or <code class="command">CreateProcess</code> on Windows). You can easily connect a pipe to the PMDA using standard input and output. The PMCD process may also connect to a daemon PMDA using IPv4 or IPv6 TCP/IP, or UNIX domain sockets if the platform supports that; see the <code class="command">tcp(7)</code>, <code class="command">ip(7)</code>, <code class="command">ipv6(7)</code> or <code class="command">unix(7)</code> man pages.
				</div><div class="para">
					<a id="IG31340177104" class="indexterm"></a> <a id="IG31340177105" class="indexterm"></a>As superuser, install the simple PMDA as a daemon process as shown in <a class="xref" href="#Z1033576478tls">Example 2.2, “Simple PMDA as a Daemon”</a>. Again, the output may differ due to operating system differences, other PMDAs already installed, or access control sections in the PMCD configuration file.
				</div><div class="para">
					<div class="example"><a id="Z1033576478tls">
      ⁠</a><p class="title"><strong>Example 2.2. Simple PMDA as a Daemon</strong></p><div class="example-contents"><div class="para">
							The specification for the simple PMDA now states the connection type of <code class="command">pipe</code> to PMCD and the executable image for the PMDA is <code class="filename">${PCP_PMDAS_DIR}/simple/pmdasimple</code>, using domain number 253.
<pre class="programlisting"># <strong class="userinput"><code>cd ${PCP_PMDAS_DIR}/simple</code></strong>
# <strong class="userinput"><code>./Install</code></strong>
... 
Install simple as a daemon or dso agent? [daemon] daemon 
PMCD should communicate with the daemon via pipe or socket? [pipe] pipe
...
# <strong class="userinput"><code>cat ${PCP_PMCDCONF_PATH}</code></strong>
# Performance Metrics Domain Specifications
# 
# This file is automatically generated during the build
# Name  Id      IPC     IPC Params      File/Cmd
pmcd    2       dso     pmcd_init       ${PCP_PMDAS_DIR}/pmcd/pmda_pmcd.so
linux   60      dso     linux_init      ${PCP_PMDAS_DIR}/linux/pmda_linux.so
proc    3       pipe    binary          ${PCP_PMDAS_DIR}/linux/pmda_proc.so -d 3
simple  253     pipe    binary          ${PCP_PMDAS_DIR}/simple/pmdasimple -d 253</pre>
						</div></div></div>

				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5189181">
      ⁠</a>2.2.4. Caching PMDA</h3></div></div></div><div class="para">
					<a id="IG31340177106" class="indexterm"></a>When either the cost or latency associated with collecting performance metrics is high, the PMDA implementer may choose to trade off the currency of the performance data to reduce the PMDA resource demands or the fetch latency time.
				</div><div class="para">
					One scheme for doing this is called a caching PMDA, which periodically instantiates values for the performance metrics and responds to each request from PMCD with the most recently instantiated (or cached) values, as opposed to instantiating current values on demand when the PMCD asks for them.
				</div><div class="para">
					<a id="IG31340177107" class="indexterm"></a> <a id="IG31340177108" class="indexterm"></a>The Cisco PMDA is an example of a caching PMDA. For additional information, see the contents of the <code class="filename">${PCP_PMDAS_DIR}/cisco</code> directory and the <code class="command">pmdacisco(1)</code> man page.
				</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="LE97285-PARENT">
      ⁠</a>2.3. Domains, Metrics, and Instances</h2></div></div></div><div class="para">
				This section defines metrics and instances, discusses how they should be designed for a particular target domain, and shows how to implement support for them.
			</div><div class="para">
				<a id="IG31340177109" class="indexterm"></a>The examples in this section are drawn from the trivial and simple PMDAs. Refer to the <code class="filename">${PCP_PMDAS_DIR}/trivial</code> and <code class="filename">${PCP_PMDAS_DIR}/simple</code> directories, respectively, where both binaries and source code are available.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5189300">
      ⁠</a>2.3.1. Overview</h3></div></div></div><div class="para">
					<a id="IG31340177110" class="indexterm"></a> <a id="IG31340177111" class="indexterm"></a> <em class="firstterm">Domains</em> are autonomous performance areas, such as the operating system or a layered service or a particular application. <em class="firstterm">Metrics</em> are raw performance data for a domain, and typically quantify activity levels, resource utilization or quality of service. <em class="firstterm">Instances</em> are sets of related metrics, as for multiple processors, or multiple service classes, or multiple transaction types.
				</div><div class="para">
					PCP employs the following simple and uniform data model to accommodate the demands of performance metrics drawn from multiple domains:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							Each metric has an identifier that is unique across all metrics for all PMDAs on a particular host.
						</div></li><li class="listitem"><div class="para">
							Externally, metrics are assigned names for user convenience--typically there is a 1:1 relationship between a metric name and a metric identifier.
						</div></li><li class="listitem"><div class="para">
							The PMDA implementation determines if a particular metric has a singular value or a set of (zero or more) values. For instance, the metric <code class="literal">hinv.ndisk</code> counts the number of disks and has only one value on a host, whereas the metric <code class="literal">disk.dev.total</code> counts disk I/O operations and has one value for each disk on the host.
						</div></li><li class="listitem"><div class="para">
							If a metric has a set of values, then members of the set are differentiated by instances. The set of instances associated with a metric is an <em class="firstterm">instance domain</em>. For example, the set of metrics <code class="literal">disk.dev.total</code> is defined over an instance domain that has one member per disk spindle.
						</div></li></ul></div><div class="para">
					<a id="IG31340177112" class="indexterm"></a>The selection of metrics and instances is an important design decision for a PMDA implementer. The metrics and instances for a target domain should have the following qualities:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							Obvious to a user
						</div></li><li class="listitem"><div class="para">
							Consistent across the domain
						</div></li><li class="listitem"><div class="para">
							Accurately representative of the operational and functional aspects of the domain
						</div></li></ul></div><div class="para">
					For each metric, you should also consider these questions:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							How useful is this value?
						</div></li><li class="listitem"><div class="para">
							What units give a good sense of scale?
						</div></li><li class="listitem"><div class="para">
							What name gives a good description of the metric's meaning?
						</div></li><li class="listitem"><div class="para">
							Can this metric be combined with another to convey the same useful information?
						</div></li></ul></div><div class="para">
					As with all programming tasks, expect to refine the choice of metrics and instances several times during the development of the PMDA.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5189538">
      ⁠</a>2.3.2. Domains</h3></div></div></div><div class="para">
					Each PMDA must be uniquely identified by PMCD so that requests from clients can be efficiently routed to the appropriate PMDA. The unique identifier, the PMDA's domain, is encoded within the metrics and instance domain identifiers so that they are associated with the correct PMDA, and so that they are unique, regardless of the number of PMDAs that are connected to the PMCD process.
				</div><div class="para">
					<a id="IG31340177113" class="indexterm"></a>The default domain number for each PMDA is defined in <code class="filename">${PCP_VAR_DIR}/pmns/stdpmid</code>. This file is a simple table of PMDA names and their corresponding domain number. However, a PMDA does not have to use this domain number--the file is only a guide to help avoid domain number clashes when PMDAs are installed and activated.
				</div><div class="para">
					The domain number a PMDA uses is passed to the PMDA by PMCD when the PMDA is launched. Therefore, any data structures that require the PMDA's domain number must be set up when the PMDA is initialized, rather than declared statically. The protocol for PMDA initialization provides a standard way for a PMDA to implement this run-time initialization.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="tip"><div class="admonition_header"><p><strong>Tip</strong></p></div><div class="admonition"><div class="para">
					Although uniqueness of the domain number in the <code class="filename">${PCP_PMCDCONF_PATH}</code> control file used by PMCD is all that is required for successful starting of PMCD and the associated PMDAs, the developer of a new PMDA is encouraged to add the default domain number for each new PMDA to the <code class="filename">${PCP_VAR_DIR}/pmns/stdpmid.local</code> file and then to run the <code class="filename">Make.stdpmid</code> script in <code class="filename">${PCP_VAR_DIR}/pmns</code> to recreate <code class="filename">${PCP_VAR_DIR}/pmns/stdpmid</code>; this file acts as a repository for documenting the known default domain numbers.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE98565-PARENT">
      ⁠</a>2.3.3. Metrics</h3></div></div></div><div class="para">
					<a id="IG31340177114" class="indexterm"></a> <a id="IG31340177115" class="indexterm"></a>A PMDA provides support for a collection of metrics. In addition to the obvious performance metrics, and the measures of time, activity and resource utilization, the metrics should also describe how the target domain has been configured, as this can greatly affect the correct interpretation of the observed performance. For example, metrics that describe network transfer rates should also describe the number and type of network interfaces connected to the host (<code class="literal">hinv.ninterface</code>, <code class="literal">network.interface.speed</code>, <code class="literal">network.interface.duplex</code>, and so on)
				</div><div class="para">
					<a id="IG31340177116" class="indexterm"></a> <a id="IG31340177117" class="indexterm"></a>In addition, the metrics should describe how the PMDA has been configured. For example, if the PMDA was periodically probing a system to measure quality of service, there should be metrics for the delay between probes, the number of probes attempted, plus probe success and failure counters. It may also be appropriate to allow values to be stored (see the <code class="command">pmstore(1)</code> man page) into the delay metric, so that the delay used by the PMDA can be altered dynamically.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5189689">
      ⁠</a>2.3.3.1. Data Structures</h4></div></div></div><div class="para">
						<a id="IG31340177118" class="indexterm"></a> <a id="IG31340177119" class="indexterm"></a> <a id="IG31340177120" class="indexterm"></a>Each metric must be described in a <code class="filename">pmDesc</code> structure; see the <code class="command">pmLookupDesc(3)</code> man page:
					</div><pre class="programlisting">typedef struct { 
    pmID        pmid;           /* unique identifier */ 
    int         type;           /* base data type */ 
    pmInDom     indom;          /* instance domain */ 
    int         sem;            /* semantics of value */ 
    pmUnits     units;          /* dimension and units */ 
} pmDesc;</pre><div class="para">
						This structure contains the following fields:
					</div><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <code class="literal">pmid</code> </span></dt><dd><div class="para">
									A unique identifier, Performance Metric Identifier (PMID), that differentiates this metric from other metrics across the union of all PMDAs
								</div></dd><dt><span class="term"> <code class="literal">type</code> </span></dt><dd><div class="para">
									A data type indicator showing whether the format is an integer (32 or 64 bit, signed or unsigned); float; double; string; or arbitrary aggregate of binary data
								</div></dd><dt><span class="term"> <code class="literal">indom</code> </span></dt><dd><div class="para">
									An instance domain identifier that links this metric to an instance domain
								</div></dd><dt><span class="term"> <code class="literal">sem</code> </span></dt><dd><div class="para">
									An encoding of the value's semantics (counter, instantaneous, or discrete)
								</div></dd><dt><span class="term"> <code class="literal">units</code> </span></dt><dd><div class="para">
									A description of the value's units based on dimension and scale in the three orthogonal dimensions of space, time, and count (or events)
								</div></dd></dl></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							This information can be observed for metrics from any active PMDA using <code class="command">pminfo</code> command line options, for example: 
<pre class="literallayout"> $ <strong class="userinput"><code>pminfo -d -m network.interface.out.drops</code></strong>

 network.interface.out.drops PMID: 60.3.11
     Data Type: 64-bit unsigned int  InDom: 60.3 0xf000003
     Semantics: counter  Units: count</pre>
						</div></div></div><div class="para">
						<a id="IG31340177121" class="indexterm"></a>Symbolic constants of the form <code class="literal">PM_TYPE_*</code>, <code class="literal">PM_SEM_*</code>, <code class="literal">PM_SPACE_*</code>, <code class="literal">PM_TIME_*</code>, and <code class="literal">PM_COUNT_*</code> are defined in the <code class="filename">&lt;pcp/pmapi.h&gt;</code> header file. You may use them to initialize the elements of a <code class="literal">pmDesc</code> structure. The <code class="literal">pmID</code> type is an unsigned integer that can be safely cast to a <code class="filename">__pmID_int</code> structure, which contains fields defining the metric's (PMDA's) domain, cluster, and item number as shown in <a class="xref" href="#Z1033577630tls">Example 2.3, “ <code class="filename">__pmID_int</code> Structure”</a>:
					</div><div class="para">
						<div class="example"><a id="Z1033577630tls">
      ⁠</a><p class="title"><strong>Example 2.3.  <code class="filename">__pmID_int</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">typedef struct { 
        int             flag:1;
        unsigned int    domain:9;
        unsigned int    cluster:12;
        unsigned int    item:10;
} __pmID_int;</pre></div></div>

					</div><div class="para">
						For additional information, see the <code class="filename">&lt;pcp/impl.h&gt;</code> file.
					</div><div class="para">
						<a id="IG31340177122" class="indexterm"></a>The <code class="literal">flag</code> field should be ignored. The <code class="literal">domain</code> number should be set at run time when the PMDA is initialized. The <code class="literal">PMDA_PMID</code> macro defined in <code class="filename">&lt;pcp/pmapi.h&gt;</code> can be used to set the <code class="literal">cluster</code> and <code class="literal">item</code> fields at compile time, as these should always be known and fixed for a particular metric.
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							The three components of the PMID should correspond exactly to the three-part definition of the PMID for the corresponding metric in the PMNS described in <a class="xref" href="#LE83854-PARENT">Section 2.4.3, “Name Space”</a>.
						</div></div></div><div class="para">
						<a id="IG31340177123" class="indexterm"></a>A table of <code class="filename">pmdaMetric</code> structures should be defined within the PMDA, with one structure per metric as shown in <a class="xref" href="#Z976036629sdc">Example 2.4, “ <code class="filename">pmdaMetric</code> Structure”</a>.
					</div><div class="example"><a id="Z976036629sdc">
      ⁠</a><p class="title"><strong>Example 2.4.  <code class="filename">pmdaMetric</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">typedef struct { 
    void        *m_user;        /* for users external use */ 
    pmDesc      m_desc;         /* metric description */ 
} pmdaMetric;</pre></div></div><div class="para">
						This structure contains a <code class="filename">pmDesc</code> structure and a handle that allows PMDA-specific structures to be associated with each metric. For example, <code class="literal">m_user</code> could be a pointer to a global variable containing the metric value, or a pointer to a function that may be called to instantiate the metric's value.
					</div><div class="para">
						<a id="IG31340177124" class="indexterm"></a>The trivial PMDA, shown in <a class="xref" href="#Z963521873sdc">Example 2.5, “Trivial PMDA”</a>, has only a singular metric (that is, no instance domain):
					</div><div class="example"><a id="Z963521873sdc">
      ⁠</a><p class="title"><strong>Example 2.5. Trivial PMDA</strong></p><div class="example-contents"><pre class="programlisting">static pmdaMetric metrictab[] = {
/* time */
 { NULL,
   { PMDA_PMID(0, 1), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_INSTANT,
     PMDA_PMUNITS(0, 1, 0, 0, PM_TIME_SEC, 0) }, },
};</pre><div class="para">
							This single metric (<code class="literal">trivial.time</code>) has the following:
						</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
									A PMID with a cluster of 0 and an item of 1. Note that this is not yet a complete PMID, the domain number which identifies the PMDA will be combined with it at runtime.
								</div></li><li class="listitem"><div class="para">
									An unsigned 32-bit integer (<code class="literal">PM_TYPE_U32</code>)
								</div></li><li class="listitem"><div class="para">
									<a id="IG31340177125" class="indexterm"></a>A singular value and hence no instance domain (<code class="literal">PM_INDOM_NULL</code>)
								</div></li><li class="listitem"><div class="para">
									<a id="IG31340177126" class="indexterm"></a>An instantaneous semantic value (<code class="literal">PM_SEM_INSTANT</code>)
								</div></li><li class="listitem"><div class="para">
									Dimension “time” and the units “seconds”
								</div></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5190312">
      ⁠</a>2.3.3.2. Semantics</h4></div></div></div><div class="para">
						<a id="IG31340177127" class="indexterm"></a>The metric's semantics describe how PCP tools should interpret the metric's value. The following are the possible semantic types:
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
								<a id="IG31340177128" class="indexterm"></a>Counter (<code class="literal">PM_SEM_COUNTER</code>)
							</div></li><li class="listitem"><div class="para">
								<a id="IG31340177129" class="indexterm"></a> Instantaneous value (<code class="literal">PM_SEM_INSTANT</code>)
							</div></li><li class="listitem"><div class="para">
								<a id="IG31340177130" class="indexterm"></a>Discrete value (<code class="literal">PM_SEM_DISCRETE</code>)
							</div></li></ul></div><div class="para">
						A counter should be a value that monotonically increases (or monotonically decreases, which is less likely) with respect to time, so that the rate of change should be used in preference to the actual value. Rate conversion is not appropriate for metrics with instantaneous values, as the value is a snapshot and there is no basis for assuming any values that might have been observed between snapshots. Discrete is similar to instantaneous; however, once observed it is presumed the value will persist for an extended period (for example, system configuration, static tuning parameters and most metrics with non-numeric values).
					</div><div class="para">
						<a id="IG31340177131" class="indexterm"></a> <a id="IG31340177132" class="indexterm"></a> <a id="IG31340177133" class="indexterm"></a>For a given time interval covering six consecutive timestamps, each spanning two units of time, the metric values in <a class="xref" href="#Z963522765sdc">Example 2.6, “Effect of Semantics on a Metric”</a> are exported from a PMDA (“N/A” implies no value is available):
					</div><div class="example"><a id="Z963522765sdc">
      ⁠</a><p class="title"><strong>Example 2.6. Effect of Semantics on a Metric</strong></p><div class="example-contents"><pre class="programlisting">Timestamps:         1   3   5   7   9  11 
Value:             10  30  60  80  90 N/A</pre><div class="para">
							The default display of the values would be as follows:
						</div><pre class="programlisting">Timestamps:         1   3   5   7   9  11 
Semantics: 
Counter           N/A  10  15  10   5 N/A 
Instantaneous      10  30  60  80  90 N/A 
Discrete           10  30  60  80  90  90</pre></div></div><div class="para">
						Note that these interpretations of metric semantics are performed by the monitor tool, automatically, before displaying a value and they are not transformations that the PMDA performs.
					</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5190481">
      ⁠</a>2.3.4. Instances</h3></div></div></div><div class="para">
					Singular metrics have only one value and no associated instance domain. Some metrics contain a set of values that share a common set of semantics for a specific instance, such as one value per processor, or one value per disk spindle, and so on.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						The PMDA implementation is solely responsible for choosing the instance identifiers that differentiate instances within the instance domain. The PMDA is also responsible for ensuring the uniqueness of instance identifiers in any instance domain, as described in <a class="xref" href="#id5190505">Section 2.3.4.1, “Instance Identification”</a>.
					</div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5190505">
      ⁠</a>2.3.4.1. Instance Identification</h4></div></div></div><div class="para">
						Consistent interpretation of instances and instance domains require a few simple rules to be followed by PMDA authors. The PMDA library provides a series of <code class="command">pmdaCache</code> routines to assist.
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
								Each internal instance identifier (numeric) must be a unique 31-bit number.
							</div></li><li class="listitem"><div class="para">
								The external instance name (string) must be unique.
							</div></li><li class="listitem"><div class="para">
								When the instance name contains a space, the name to the left of the first space (the short name) must also be unique.
							</div></li><li class="listitem"><div class="para">
								Where an external instance name corresponds to some object or entity, there is an expectation that the association between the name and the object is fixed.
							</div></li><li class="listitem"><div class="para">
								It is preferable, although not mandatory, for the association between and external instance name (string) and internal instance identifier (numeric) to be persistent.
							</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5190506">
      ⁠</a>2.3.4.2. N Dimensional Data</h4></div></div></div><div class="para">
						<a id="IG31340177134" class="indexterm"></a>Where the performance data can be represented as scalar values (singular metrics) or one-dimensional arrays or lists (metrics with an instance domain), the PCP framework is more than adequate. In the case of metrics with an instance domain, each array or list element is associated with an instance from the instance domain.
					</div><div class="para">
						<a id="IG31340177135" class="indexterm"></a> <a id="IG31340177136" class="indexterm"></a>To represent two or more dimensional arrays, the coordinates must be one of the following:
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
								Mapped onto one dimensional coordinates.
							</div></li><li class="listitem"><div class="para">
								Enumerated into the Performance Metrics Name Space (PMNS).
							</div></li></ul></div><div class="para">
						For example, this 2 x 3 array of values called M can be represented as instances 1,..., 6 for a metric M:
					</div><pre class="programlisting">  M[1]   M[2]   M[3] 
  M[4]   M[5]   M[6]</pre><div class="para">
						Or they can be represented as instances 1, 2, 3 for metric M1 and instances 1, 2, 3 for metric M2:
					</div><pre class="programlisting">  M1[1]  M1[2]  M1[3] 
  M2[1]  M2[2]  M2[3]</pre><div class="para">
						The PMDA implementer must decide and consistently export this encoding from the N-dimensional instrumentation to the 1-dimensional data model of the PCP.
					</div><div class="para">
						In certain special cases (for example, such as for a histogram), it may be appropriate to export an array of values as raw binary data (the type encoding in the descriptor is <code class="literal">PM_TYPE_AGGREGATE</code>). However, this requires the development of special PMAPI client tools, because the standard PCP tools have no knowledge of the structure and interpretation of the binary data. The usual issues of platform-depdendence must also be kept in mind for this case - endianness, word-size, alignment and so on - the (possibly remote) special PMAPI client tools may need this information in order to decode the data successfully.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5190626">
      ⁠</a>2.3.4.3. Data Structures</h4></div></div></div><div class="para">
						<a id="IG31340177137" class="indexterm"></a> <a id="IG31340177138" class="indexterm"></a>If the PMDA is required to support instance domains, then for each instance domain the unique internal instance identifier and external instance identifier should be defined using a <code class="filename">pmdaInstid</code> structure as shown in <a class="xref" href="#Z975964618sdc">Example 2.7, “ <code class="filename">pmdaInstid</code> Structure”</a>:
					</div><div class="example"><a id="Z975964618sdc">
      ⁠</a><p class="title"><strong>Example 2.7.  <code class="filename">pmdaInstid</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">typedef struct { 
    int         i_inst;         /* internal instance identifier */ 
    char        *i_name;        /* external instance identifier */ 
} pmdaInstid;</pre><div class="para">
							The <code class="literal">i_inst</code> instance identifier must be a unique integer within a particular instance domain.
						</div></div></div><div class="para">
						<a id="IG31340177139" class="indexterm"></a>The complete instance domain description is specified in a <code class="filename">pmdaIndom</code> structure as shown in <a class="xref" href="#Z975964773sdc">Example 2.8, “ <code class="filename">pmdaIndom</code> Structure”</a>:
					</div><div class="example"><a id="Z975964773sdc">
      ⁠</a><p class="title"><strong>Example 2.8.  <code class="filename">pmdaIndom</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">typedef struct { 
    pmInDom     it_indom;       /* indom, filled in */ 
    int         it_numinst;     /* number of instances */ 
    pmdaInstid  *it_set;        /* instance identifiers */ 
} pmdaIndom;</pre></div></div><div class="para">
						<a id="IG31340177140" class="indexterm"></a> <a id="IG31340177141" class="indexterm"></a>The <code class="literal">it_indom</code> element contains a <code class="literal">pmInDom</code> that must be unique across every PMDA. The other fields of the <code class="filename">pmdaIndom</code> structure are the number of instances in the instance domain and a pointer to an array of instance descriptions.
					</div><div class="para">
						<a class="xref" href="#Z1033578294tls">Example 2.9, “ <code class="literal">__pmInDom_int</code> Structure”</a> shows that the <code class="literal">pmInDom</code> can be safely cast to <code class="literal">__pmInDom_int</code>, which specifies the PMDA's domain and the instance number within the PMDA:
					</div><div class="para">
						<div class="example"><a id="Z1033578294tls">
      ⁠</a><p class="title"><strong>Example 2.9.  <code class="literal">__pmInDom_int</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">typedef struct { 
        int             flag:1;
        unsigned int    domain:9;   /* the administrative PMD */ 
        unsigned int    serial:22;  /* unique within PMD */         
} __pmInDom_int;</pre></div></div>

					</div><div class="para">
						As with metrics, the PMDA domain number is not necessarily known until run time; so the <code class="literal">domain</code> field must be set up when the PMDA is initialized.
					</div><div class="para">
						<a id="IG31340177142" class="indexterm"></a>For information about how an instance domain may also be associated with more than one metric, see the <code class="command">pmdaInit(3)</code> man page.
					</div><div class="para">
						The simple PMDA, shown in <a class="xref" href="#Z963524114sdc">Example 2.10, “Simple PMDA”</a>, has five metrics and two instance domains of three instances.
					</div><div class="example"><a id="Z963524114sdc">
      ⁠</a><p class="title"><strong>Example 2.10. Simple PMDA</strong></p><div class="example-contents"><pre class="programlisting">/* 
 * list of instances 
 */ 
static pmdaInstid color[] = {
    { 0, “red” }, { 1, “green” }, { 2, “blue” }
};
static pmdaInstid       *timenow = NULL;
static unsigned int     timesize = 0;
/*
 * list of instance domains
 */
static pmdaIndom indomtab[] = {
#define COLOR_INDOM     0
    { COLOR_INDOM, 3, color },
#define NOW_INDOM       1
    { NOW_INDOM, 0, NULL },
};
/*
 * all metrics supported in this PMDA - one table entry for each
 */
static pmdaMetric metrictab[] = {
/* numfetch */
    { NULL,
      { PMDA_PMID(0, 0), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_INSTANT,
       PMDA_PMUNITS(0, 0, 0, 0, 0, 0) }, },
/* color */
    { NULL,
      { PMDA_PMID(0, 1), PM_TYPE_32, COLOR_INDOM, PM_SEM_INSTANT,
        PMDA_PMUNITS(0, 0, 0, 0, 0, 0) }, },
/* time.user */
    { NULL,
      { PMDA_PMID(1, 2), PM_TYPE_DOUBLE, PM_INDOM_NULL, PM_SEM_COUNTER,
        PMDA_PMUNITS(0, 1, 0, 0, PM_TIME_SEC, 0) }, },
/* time.sys */
    { NULL,
      { PMDA_PMID(1,3), PM_TYPE_DOUBLE, PM_INDOM_NULL, PM_SEM_COUNTER,
        PMDA_PMUNITS(0, 1, 0, 0, PM_TIME_SEC, 0) }, },
/* now */
    { NULL,
      { PMDA_PMID(2,4), PM_TYPE_U32, NOW_INDOM, PM_SEM_INSTANT,
        PMDA_PMUNITS(0, 0, 0, 0, 0, 0) }, },
};</pre></div></div><div class="para">
						<a id="IG31340177143" class="indexterm"></a>The metric <code class="literal">simple.color</code> is associated, via <code class="literal">COLOR_INDOM</code>, with the first instance domain listed in <code class="filename">indomtab</code>. PMDA initialization assigns the correct domain portion of the instance domain identifier in <code class="filename">indomtab[0].it_indom</code> and <code class="filename">metrictab[1].m_desc.indom</code>. This instance domain has three instances: red, green, and blue.
					</div><div class="para">
						The metric <code class="literal">simple.now</code> is associated, via <code class="literal">NOW_INDOM</code><a id="IG31340177144" class="indexterm"></a>, with the second instance domain listed in <code class="filename">indomtab</code>. PMDA initialization assigns the correct domain portion of the instance domain identifier in <code class="filename">indomtab[1].it_indom</code> and <code class="filename">metrictab[4].m_desc.indom</code>. This instance domain is dynamic and initially has no instances.
					</div><div class="para">
						<a id="IG31340177145" class="indexterm"></a>All other metrics are singular, as specified by <code class="literal">PM_INDOM_NULL</code>.
					</div><div class="para">
						In some cases an instance domain may vary dynamically after PMDA initialization (for example, <code class="literal">simple.now</code>), and this requires some refinement of the default functions and data structures of the <code class="filename">libpcp_pmda</code> library. Briefly, this involves providing new functions that act as wrappers for <code class="command">pmdaInstance</code> and <code class="command">pmdaFetch</code> while understanding the dynamics of the instance domain, and then overriding the instance and fetch methods in the <code class="filename">pmdaInterface</code> structure during PMDA initialization.
					</div><div class="para">
						For the simple PMDA, the wrapper functions are <code class="command">simple_fetch</code> and <code class="command">simple_instance</code>, and defaults are over-ridden by the following assignments in the <code class="command">simple_init</code> function:
					</div><pre class="programlisting">dp-&gt;version.any.fetch = simple_fetch;
dp-&gt;version.any.instance = simple_instance;</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5191164">
      ⁠</a>2.4. Other Issues</h2></div></div></div><div class="para">
				Other issues include extracting the information, latency and threads of control, Name Space, PMDA help text, and management of evolution within a PMDA.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5191177">
      ⁠</a>2.4.1. Extracting the Information</h3></div></div></div><div class="para">
					<a id="IG31340177146" class="indexterm"></a>A suggested approach to writing a PMDA is to write a standalone program to extract the values from the target domain and then incorporate this program into the PMDA framework. This approach avoids concurrent debugging of two distinct problems: 
					<div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
								<a id="IG31340177147" class="indexterm"></a> Extraction of the data
							</div></li><li class="listitem"><div class="para">
								Communication with PMCD
							</div></li></ul></div>
				</div><div class="para">
					<a id="IG31340177148" class="indexterm"></a>These are some possible ways of exporting the data from the target domain:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							Accumulate the performance data in a public shared memory segment.
						</div></li><li class="listitem"><div class="para">
							Write the performance data to the end of a log file.
						</div></li><li class="listitem"><div class="para">
							Periodically rewrite a file with the most recent values for the performance data.
						</div></li><li class="listitem"><div class="para">
							Implement a protocol that allows a third party to connect to the target application, send a request, and receive new performance data.
						</div></li><li class="listitem"><div class="para">
							If the data is in the operating system kernel, provide a kernel interface (preferred) to export the performance data.
						</div></li></ul></div><div class="para">
					Most of these approaches require some further data processing by the PMDA.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5191305">
      ⁠</a>2.4.2. Latency and Threads of Control</h3></div></div></div><div class="para">
					<a id="IG31340177149" class="indexterm"></a> <a id="IG31340177150" class="indexterm"></a> <a id="IG31340177151" class="indexterm"></a>The PCP protocols expect PMDAs to return the current values for performance metrics when requested, and with short delay (low latency). For some target domains, access to the underlying instrumentation may be costly or involve unpredictable delays (for example, if the real performance data is stored on some remote host or network device). In these cases, it may be necessary to separate probing for new performance data from servicing PMCD requests.
				</div><div class="para">
					<a id="IG31340177152" class="indexterm"></a>An architecture that has been used successfully for several PMDAs is to create one or more child processes to obtain information while the main process communicates with PMCD.
				</div><div class="para">
					At the simplest deployment of this arrangement, the two processes may execute without synchronization. Threads have also been used as a more portable multithreading mechanism; see the <code class="command">pthreads(7)</code> man page.
				</div><div class="para">
					By contrast, a complex deployment would be one in which the refreshing of the metric values must be atomic, and this may require double buffering of the data structures. It also requires coordination between parent and child processes.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
						Since certain data structures used by the PMDA library are not thread-aware, only one PMDA thread of control should call PMDA library functions - this would typically be the thread servicing requests from PMCD.
					</div></div></div><div class="para">
					<a id="IG31340177153" class="indexterm"></a>One caveat about this style of caching PMDA--in this (special) case it is better if the PMDA converts counts to rates based upon consecutive periodic sampling from the underlying instrumentation. By exporting precomputed rate metrics with instantaneous semantics, the PMDA prevents the PCP monitor tools from computing their own rates upon consecutive PMCD fetches (which are likely to return identical values from a caching PMDA). The finer points of metric semantics are discussed in <a class="xref" href="#id5190312">Section 2.3.3.2, “Semantics”</a>
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE83854-PARENT">
      ⁠</a>2.4.3. Name Space</h3></div></div></div><div class="para">
					<a id="IG31340177154" class="indexterm"></a> <a id="IG31340177155" class="indexterm"></a>The PMNS file defines the name space of the PMDA. It is a simple text file that is used during installation to expand the Name Space of the PMCD process. The format of this file is described by the <code class="command">pmns(5)</code> man page and its hierarchical nature, syntax, and helper tools are further described in the <em class="citetitle">Performance Co-Pilot User's and Administrator's Guide</em>.
				</div><div class="para">
					Client processes will not be able to access the PMDA metrics if the PMNS file is not installed as part of the PMDA installation procedure on the collector host. The installed list of metric names and their corresponding PMIDs can be found in <code class="filename">${PCP_VAR_DIR}/pmns/root</code>.
				</div><div class="para">
					<a id="IG31340177156" class="indexterm"></a> <a class="xref" href="#Z963526380sdc">Example 2.11, “ <code class="filename">pmns</code> File for the Simple PMDA”</a> shows the simple PMDA, which has five metrics:
					<div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
								Three metrics immediately under the <code class="literal">simple</code> node
							</div></li><li class="listitem"><div class="para">
								Two metrics under another non-terminal node called <code class="literal">simple.time</code>
							</div></li></ul></div>
				</div><div class="example"><a id="Z963526380sdc">
      ⁠</a><p class="title"><strong>Example 2.11.  <code class="filename">pmns</code> File for the Simple PMDA</strong></p><div class="example-contents"><pre class="programlisting">simple {
    numfetch    SIMPLE:0:0
    color       SIMPLE:0:1
    time
    now         SIMPLE:2:4
}
simple.time {
    user        SIMPLE:1:2
    sys         SIMPLE:1:3
}</pre></div></div><div class="para">
					Metrics that have different clusters do not have to be specified in different subtrees of the PMNS. <a class="xref" href="#Z976046292sdc">Example 2.12, “Alternate <code class="filename">pmns</code> File for the Simple PMDA”</a> shows an alternative PMNS for the simple PMDA:
				</div><div class="example"><a id="Z976046292sdc">
      ⁠</a><p class="title"><strong>Example 2.12. Alternate <code class="filename">pmns</code> File for the Simple PMDA</strong></p><div class="example-contents"><pre class="programlisting">simple { 
    numfetch    SIMPLE:0:0 
    color       SIMPLE:0:1 
    usertime    SIMPLE:1:2 
    systime     SIMPLE:1:3 
}</pre><div class="para">
						In this example, the <code class="literal">SIMPLE</code> macro is replaced by the domain number listed in <code class="filename">${PCP_VAR_DIR}/pmns/stdpmid</code> for the corresponding PMDA during installation (for the simple PMDA, this would normally be the value 253).
					</div></div></div><div class="para">
					If the PMDA implementer so chooses, all or a subset of the metric names and identifiers can be specified programatically. In this situation, a special asterisk syntax is used to denote those subtrees which are to be handles this way. <a class="xref" href="#Z976046292nat">Example 2.13, “Dynamic metrics <code class="filename">pmns</code> File for the Simple PMDA”</a> shows this dynamic namespace syntax, for all metrics in the simple PMDA:
				</div><div class="example"><a id="Z976046292nat">
      ⁠</a><p class="title"><strong>Example 2.13. Dynamic metrics <code class="filename">pmns</code> File for the Simple PMDA</strong></p><div class="example-contents"><pre class="programlisting">simple         SIMPLE:*:*</pre><div class="para">
						In this example, like the one before, the <code class="literal">SIMPLE</code> macro is replaced by the domain number, and all (simple.*) metric namespace operations must be handled by the PMDA. This is in contrast to the static metric name model earlier, where the host-wide PMNS file is updated and used by PMCD, acting on behalf of the agent.
					</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE72473-PARENT">
      ⁠</a>2.4.4. PMDA Help Text</h3></div></div></div><div class="para">
					<a id="IG31340177157" class="indexterm"></a> <a id="IG31340177158" class="indexterm"></a>For each metric defined within a PMDA, the PMDA developer is strongly encouraged to provide both terse and extended help text to describe the metric, and perhaps provide hints about the expected value ranges.
				</div><div class="para">
					<a id="IG31340177159" class="indexterm"></a>The help text is used to describe each metric in the visualization tools and <code class="command">pminfo</code> with the <code class="command">-T</code> option. The help text, such as the help text for the simple PMDA in <a class="xref" href="#Z963526754sdc">Example 2.14, “Help Text for the Simple PMDA”</a>, is specified in a specially formatted file, normally called <code class="filename">help</code>. This file is converted to the expected run-time format using the <code class="command">newhelp</code> command; see the <code class="command">newhelp(1)</code> man page. Converted help text files are usually placed in the PMDA's directory below <code class="filename">${PCP_PMDAS_DIR}</code> as part of the PMDA installation procedure.
				</div><div class="example"><a id="Z963526754sdc">
      ⁠</a><p class="title"><strong>Example 2.14. Help Text for the Simple PMDA</strong></p><div class="example-contents"><div class="para">
						The two instance domains and five metrics have a short and a verbose description. Each entry begins with a line that starts with the character “@” and is followed by either the metric name (<code class="literal">simple.numfetch</code>) or a symbolic reference to the instance domain number (<code class="literal">SIMPLE.1</code>), followed by the short description. The verbose description is on the following lines, terminated by the next line starting with “@” or end of file:
					</div><pre class="programlisting">@ SIMPLE.0 Instance domain “colour” for simple PMDA
Universally 3 instances, “red” (0), “green” (1) and “blue” (3).

@ SIMPLE.1 Dynamic instance domain “time” for simple PMDA
An instance domain is computed on-the-fly for exporting current time
information. Refer to the help text for simple.now for more details.

@ simple.numfetch Number of pmFetch operations.
The cumulative number of pmFetch operations directed to “simple” PMDA.

This counter may be modified with pmstore(1).

@ simple.color Metrics which increment with each fetch
This metric has 3 instances, designated “red”, “green” and “blue”.

The value of the metric is monotonic increasing in the range 0 to
255, then back to 0.  The different instances have different starting
values, namely 0 (red), 100 (green) and 200 (blue).

The metric values my be altered using pmstore(1).

@ simple.time.user Time agent has spent executing user code
The time in seconds that the CPU has spent executing agent user code.

@ simple.time.sys Time agent has spent executing system code
The time in seconds that the CPU has spent executing agent system code.

@ simple.now Time of day with a configurable instance domain
The value reflects the current time of day through a dynamically
reconfigurable instance domain.  On each metric value fetch request,
the agent checks to see whether the configuration file in
${PCP_PMDAS_DIR}/simple/simple.conf has been modified - if it has then
the file is re-parsed and the instance domain for this metric is again
constructed according to its contents.

This configuration file contains a single line of comma-separated time
tokens from this set:
  “sec”  (seconds after the minute),
  “min”  (minutes after the hour),
  “hour” (hour since midnight).

An example configuration file could be:  sec,min,hour
and in this case the simple.now metric would export values for the
three instances “sec”, “min” and “hour” corresponding respectively to
the components seconds, minutes and hours of the current time of day.

The instance domain reflects each token present in the file, and the
values reflect the time at which the PMDA processes the fetch.</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5191869">
      ⁠</a>2.4.5. Management of Evolution within a PMDA</h3></div></div></div><div class="para">
					<a id="IG31340177160" class="indexterm"></a> <a id="IG31340177161" class="indexterm"></a>Evolution of a PMDA, or more particularly the underlying instrumentation to which it provides access, over time naturally results in the appearance of new metrics and the disappearance of old metrics. This creates potential problems for PMAPI clients and PCP tools that may be required to interact with both new and former versions of the PMDA.
				</div><div class="para">
					The following guidelines are intended to help reduce the complexity of implementing a PMDA in the face of evolutionary change, while maintaining predictability and semantic coherence for tools using the PMAPI, and for end users of those tools.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<a id="IG31340177162" class="indexterm"></a>Try to support as full a range of metrics as possible in every version of the PMDA. In this context, <em class="firstterm">support</em> means responding sensibly to requests, even if the underlying instrumentation is not available.
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177163" class="indexterm"></a> <a id="IG31340177164" class="indexterm"></a> <a id="IG31340177165" class="indexterm"></a>If a metric is not supported in a given version of the underlying instrumentation, the PMDA should respond to <code class="command">pmLookupDesc</code> requests with a <code class="filename">pmDesc</code> structure whose <code class="literal">type</code> field has the special value <code class="literal">PM_TYPE_NOSUPPORT</code>. Values of fields other than <code class="literal">pmid</code> and <code class="literal">type</code> are immaterial, but <a class="xref" href="#Z976047129sdc">Example 2.15, “ Setting Values”</a> is typically benign:
						</div><div class="example"><a id="Z976047129sdc">
      ⁠</a><p class="title"><strong>Example 2.15.  Setting Values</strong></p><div class="example-contents"><pre class="programlisting">pmDesc dummy = { 
     .pmid  = PMDA_PMID(3,0),           /* pmid, fill this in */
     .type  = PM_TYPE_NOSUPPORT,        /* this is the important part */
     .indom = PM_INDOM_NULL,            /* singular,causes no problems */
     .sem   = 0,                        /* no semantics */
     .units = PMDA_PMUNITS(0,0,0,0,0,0) /* no units */
};</pre></div></div></li><li class="listitem"><div class="para">
							<a id="IG31340177166" class="indexterm"></a> <a id="IG31340177167" class="indexterm"></a>If a metric lacks support in a particular version of the underlying instrumentation, the PMDA should respond to <code class="command">pmFetch</code> requests with a <code class="command">pmResult</code> in which no values are returned for the unsupported metric. This is marginally friendlier than the other semantically acceptable option of returning an illegal PMID error or <code class="literal">PM_ERR_PMID</code>.
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177168" class="indexterm"></a> <a id="IG31340177169" class="indexterm"></a>Help text should be updated with annotations to describe different versions of the underlying product, or product configuration options, for which a specific metric is available. This is so <code class="command">pmLookupText</code> can always respond correctly.
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177170" class="indexterm"></a> <a id="IG31340177171" class="indexterm"></a>The <code class="command">pmStore</code> operation should fail with return status of <code class="literal">PM_ERR_PERMISSION</code> if a user or application tries to amend the value of an unsupported metric.
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177172" class="indexterm"></a> <a id="IG31340177173" class="indexterm"></a> <a id="IG31340177174" class="indexterm"></a> <a id="IG31340177175" class="indexterm"></a> <a id="IG31340177176" class="indexterm"></a> <a id="IG31340177177" class="indexterm"></a> The value extraction, conversion, and printing functions (<code class="command">pmExtractValue</code>, <code class="command">pmConvScale</code>, <code class="command">pmAtomStr</code>, <code class="command">pmTypeStr</code>, and <code class="command">pmPrintValue</code>) return the <code class="literal">PM_ERR_CONV</code> error or an appropriate diagnostic string, if an attempt is made to operate on a value for which <code class="literal">type</code> is <code class="literal">PM_TYPE_NOSUPPORT</code>.
						</div><div class="para">
							If performance tools take note of the <code class="literal">type</code> field in the <code class="filename">pmDesc</code> structure, they should not manipulate values for unsupported metrics. Even if tools ignore <code class="literal">type</code> in the metric's description, following these development guidelines ensures that no misleading value is ever returned; so there is no reason to call the extraction, conversion, and printing functions.
						</div></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="LE21831-PARENT">
      ⁠</a>2.5. PMDA Interface</h2></div></div></div><div class="para">
				<a id="IG31340177178" class="indexterm"></a>This section describes an interface for the request handling callbacks in a PMDA. This interface is used by PMCD for communicating with DSO PMDAs and is also used by daemon PMDAs with <code class="command">pmdaMain</code>.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5192358">
      ⁠</a>2.5.1. Overview</h3></div></div></div><div class="para">
					Both daemon and DSO PMDAs must handle multiple request types from PMCD. A daemon PMDA communicates with PMCD using the PDU protocol, while a DSO PMDA defines callbacks for each request type. To avoid duplicating this PDU processing (in the case of a PMDA that can be installed either as a daemon or as a DSO), and to allow a consistent framework, <code class="command">pmdaMain</code> can be used by a daemon PMDA as a wrapper to handle the communication protocol using the same callbacks as a DSO PMDA. This allows a PMDA to be built as both a daemon and a DSO, and then to be installed as either.
				</div><div class="para">
					To further simplify matters, default callbacks are declared in <code class="filename">&lt;pcp/pmda.h&gt;</code>:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<a id="IG31340177179" class="indexterm"></a> <code class="command">pmdaFetch</code>
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177180" class="indexterm"></a> <code class="command">pmdaProfile</code>
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177181" class="indexterm"></a> <code class="command">pmdaInstance</code>
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177182" class="indexterm"></a> <code class="command">pmdaDesc</code>
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177183" class="indexterm"></a> <code class="command">pmdaText</code>
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177184" class="indexterm"></a> <code class="command">pmdaStore</code>
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177nat" class="indexterm"></a> <code class="command">pmdaPMID</code>
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340178nat" class="indexterm"></a> <code class="command">pmdaName</code>
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340179nat" class="indexterm"></a> <code class="command">pmdaChildren</code>
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340180nat" class="indexterm"></a> <code class="command">pmdaAttribute</code>
						</div></li></ul></div><div class="para">
					<a id="IG31340177185" class="indexterm"></a>Each callback takes a <code class="filename">pmdaExt</code> structure as its last argument. This structure contains all the information that is required by the default callbacks in most cases. The one exception is <code class="command">pmdaFetch</code>, which needs an additional callback to instantiate the current value for each supported combination of a performance metric and an instance.
				</div><div class="para">
					Therefore, for most PMDAs all the communication with PMCD is automatically handled by functions in <code class="filename">libpcp.so</code> and <code class="filename">libpcp_pmda.so</code>.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5192570">
      ⁠</a>2.5.1.1. Trivial PMDA</h4></div></div></div><div class="para">
						<a id="IG31340177186" class="indexterm"></a>The trivial PMDA uses all of the default callbacks as shown in <a class="xref" href="#Z964109292sdc">Example 2.16, “Request Handling Callbacks in the Trivial PMDA”</a>. The additional callback for <code class="command">pmdaFetch</code> is defined as <code class="command">trivial_fetchCallBack</code>:
					</div><div class="example"><a id="Z964109292sdc">
      ⁠</a><p class="title"><strong>Example 2.16. Request Handling Callbacks in the Trivial PMDA</strong></p><div class="example-contents"><pre class="programlisting">static int
trivial_fetchCallBack(pmdaMetric *mdesc, unsigned int inst, pmAtomValue *atom)
{
   __pmID_int      *idp = (__pmID_int *)&amp;(mdesc-&gt;m_desc.pmid);

   if (idp-&gt;cluster != 0 || idp-&gt;item != 0)
       return PM_ERR_PMID;
   if (inst != PM_IN_NULL)
       return PM_ERR_INST;
   atom-&gt;l = time(NULL);
   return 0;
}</pre><div class="para">
							<a id="IG31340177187" class="indexterm"></a>This function checks that the PMID and instance are valid, and then places the metric value for the current time into the <code class="filename">pmAtomValue</code> structure.
						</div></div></div><div class="para">
						The callback is set up by a call to <code class="command">pmdaSetFetchCallBack</code> in <code class="command">trivial_init</code>. As a rule of thumb, the API routines with named ending with <code class="command">CallBack</code> are helpers for the higher PDU handling routines like <code class="command">pmdaFetch</code>. The latter are set directly using the PMDA Interface Structures, as described in <a class="xref" href="#id5193658">Section 2.5.2, “PMDA Structures”</a>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5192681">
      ⁠</a>2.5.1.2. Simple PMDA</h4></div></div></div><div class="para">
						<a id="IG31340177188" class="indexterm"></a> <a id="IG31340177189" class="indexterm"></a>The simple PMDA callback for <code class="command">pmdaFetch</code> is more complicated because it supports more metrics, some metrics are instantiated with each fetch, and one instance domain is dynamic. The default <code class="command">pmdaFetch</code> callback, shown in <a class="xref" href="#Z964110950sdc">Example 2.17, “Request Handling Callbacks in the Simple PMDA”</a>, is replaced by <code class="command">simple_fetch</code> in <code class="command">simple_init</code>, which increments the number of fetches and updates the instance domain for <code class="literal">INDOM_NOW</code> before calling <code class="command">pmdaFetch</code>:
					</div><div class="example"><a id="Z964110950sdc">
      ⁠</a><p class="title"><strong>Example 2.17. Request Handling Callbacks in the Simple PMDA</strong></p><div class="example-contents"><pre class="programlisting">static int
simple_fetch(int numpmid, pmID pmidlist[], pmResult **resp, pmdaExt *pmda)
{
    numfetch++;
    simple_timenow_check();
    simple_timenow_refresh();
    return pmdaFetch(numpmid, pmidlist, resp, pmda);
}</pre></div></div><div class="para">
						<a id="IG31340177190" class="indexterm"></a>The callback for <code class="command">pmdaFetch</code> is defined as <code class="command">simple_fetchCallBack</code>. The PMID is extracted from the <code class="filename">pmdaMetric</code> structure, and if valid, the appropriate field in the <code class="filename">pmAtomValue</code> structure is set. The available types and associated fields are described further in <a class="xref" href="#LE11914-PARENT">Section 3.4, “Performance Metric Descriptions”</a> and <a class="xref" href="#Z976562908sdc">Example 3.16, “ <code class="filename">pmAtomValue</code> Structure”</a>.
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							Note that PMID validity checking need only check the cluster and item numbers, the domain number is guaranteed to be valid and the PMDA should make no assumptions about the actual domain number being used at this point.
						</div></div></div><div class="para">
						The <code class="literal">simple.numfetch</code> metric has no instance domain and is easily handled first as shown in <a class="xref" href="#Z976306482sdc">Example 2.18, “ <code class="literal">simple.numfetch</code> Metric”</a>:
					</div><div class="example"><a id="Z976306482sdc">
      ⁠</a><p class="title"><strong>Example 2.18.  <code class="literal">simple.numfetch</code> Metric</strong></p><div class="example-contents"><pre class="programlisting">static int
simple_fetchCallBack(pmdaMetric *mdesc, unsigned int inst, pmAtomValue *atom)
{
   int             i;
   static int      oldfetch;
   static double   usr, sys;
   __pmID_int      *idp = (__pmID_int *)&amp;(mdesc-&gt;m_desc.pmid);

   if (inst != PM_IN_NULL &amp;&amp;
       !(idp-&gt;cluster == 0 &amp;&amp; idp-&gt;item == 1) &amp;&amp;
       !(idp-&gt;cluster == 2 &amp;&amp; idp-&gt;item == 4))
       return PM_ERR_INST;
   if (idp-&gt;cluster == 0) {
       if (idp-&gt;item == 0) {                   /* simple.numfetch */
           atom-&gt;l = numfetch;
       }</pre></div></div><div class="para">
						<a id="IG31340177191" class="indexterm"></a>In <a class="xref" href="#Z976049747sdc">Example 2.19, “ <code class="literal">simple.color</code> Metric”</a>, the <code class="literal">inst</code> parameter is used to specify which instance is required for the <code class="literal">simple.color</code> metric:
					</div><div class="example"><a id="Z976049747sdc">
      ⁠</a><p class="title"><strong>Example 2.19.  <code class="literal">simple.color</code> Metric</strong></p><div class="example-contents"><pre class="programlisting">       else if (idp-&gt;item == 1) {              /* simple.color */
            switch (inst) {
            case 0:                             /* red */
                red = (red + 1) % 256;
                atom-&gt;l = red;
                break;
            case 1:                             /* green */
                green = (green + 1) % 256;
                atom-&gt;l = green;
                break;
            case 2:                             /* blue */
                blue = (blue + 1) % 256;
                atom-&gt;l = blue;
                break;
            default:
                return PM_ERR_INST;
            }
       }
       else
           return PM_ERR_PMID;</pre></div></div><div class="para">
						<a id="IG31340177192" class="indexterm"></a>In <a class="xref" href="#Z976049353sdc">Example 2.20, “ <code class="literal">simple.time</code> Metric”</a>, the <code class="literal">simple.time</code> metric is in a second cluster and has a simple optimization to reduce the overhead of calling <code class="command">times</code> twice on the same fetch and return consistent values from a single call to <code class="command">times</code> when both metrics <code class="literal">simple.time.user</code> and <code class="literal">simple.time.sys</code> are requested in a single <code class="command">pmFetch</code>. The previous fetch count is used to determine if the <code class="filename">usr</code> and <code class="filename">sys</code> values should be updated:
					</div><div class="example"><a id="Z976049353sdc">
      ⁠</a><p class="title"><strong>Example 2.20.  <code class="literal">simple.time</code> Metric</strong></p><div class="example-contents"><pre class="programlisting">   else if (idp-&gt;cluster == 1) {               /* simple.time */
       if (oldfetch &lt; numfetch) {
           __pmProcessRunTimes(&amp;usr, &amp;sys);
           oldfetch = numfetch;
       }
       if (idp-&gt;item == 2)                     /* simple.time.user */
           atom-&gt;d = usr;
       else if (idp-&gt;item == 3)                /* simple.time.sys */
           atom-&gt;d = sys;
       else
           return PM_ERR_PMID;
    }</pre></div></div><div class="para">
						<a id="IG31340177193" class="indexterm"></a>In <a class="xref" href="#Z976049020sdc">Example 2.21, “ <code class="literal">simple.now</code> Metric”</a>, the <code class="literal">simple.now</code> metric is in a third cluster and uses <code class="literal">inst</code> again to select a specific instance from the <code class="literal">INDOM_NOW</code> instance domain. The values associated with instances in this instance domain are managed using the <code class="command">pmdaCache(3)</code> helper routines, which provide efficient interfaces for managing more complex instance domains:
					</div><div class="example"><a id="Z976049020sdc">
      ⁠</a><p class="title"><strong>Example 2.21.  <code class="literal">simple.now</code> Metric</strong></p><div class="example-contents"><pre class="programlisting">    else if (idp-&gt;cluster == 2) {
        if (idp-&gt;item == 4) {                 /* simple.now */
            struct timeslice *tsp;
            sts = pmdaCacheLookup(*now_indom, inst, NULL, (void *)&amp;tsp);
            if (sts != PMDA_CACHE_ACTIVE) {
                if (sts &lt; 0)
                    __pmNotifyErr(LOG_ERR, "pmdaCacheLookup failed: inst=%d: %s",
                                  inst, pmErrStr(sts));
                return PM_ERR_INST;
            }
            atom-&gt;l = tsp-&gt;tm_field;
        }
        else 
            return PM_ERR_PMID;
    }</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5193108">
      ⁠</a>2.5.1.3.  <code class="literal">simple_store</code> in the Simple PMDA</h4></div></div></div><div class="para">
						<a id="IG31340177194" class="indexterm"></a> <a id="IG31340177195" class="indexterm"></a>The simple PMDA permits some of the metrics it supports to be modified by <code class="command">pmStore</code> as shown in <a class="xref" href="#Z964111850sdc">Example 2.22, “ <code class="literal">simple_store</code> in the Simple PMDA”</a>. For additional information, see the <code class="command">pmstore(1)</code> and <code class="command">pmStore(3)</code> man pages.
					</div><div class="example"><a id="Z964111850sdc">
      ⁠</a><p class="title"><strong>Example 2.22.  <code class="literal">simple_store</code> in the Simple PMDA</strong></p><div class="example-contents"><div class="para">
							<a id="IG31340177196" class="indexterm"></a>The <code class="command">pmdaStore</code> callback (which returns <code class="literal">PM_ERR_PERMISSION</code> to indicate no metrics can be altered) is replaced by <code class="command">simple_store</code> in <code class="command">simple_init</code>. This replacement function must take the same arguments so that it can be assigned to the function pointer in the <code class="filename">pmdaInterface</code> structure.
						</div><div class="para">
							The function traverses the <code class="literal">pmResult</code> and checks the cluster and unit of each PMID to ensure that it corresponds to a metric that can be changed. Checks are made on the values to ensure they are within range before being assigned to variables in the PMDA that hold the current values for exported metrics:
						</div><pre class="programlisting">static int
simple_store(pmResult *result, pmdaExt *pmda)
{
    int         i, j, val, sts = 0;
    pmAtomValue av;
    pmValueSet  *vsp = NULL;
    __pmID_int  *pmidp = NULL;

    /* a store request may affect multiple metrics at once */
    for (i = 0; i &lt; result-&gt;numpmid; i++) {
        vsp = result-&gt;vset[i];
        pmidp = (__pmID_int *)&amp;vsp-&gt;pmid;
        if (pmidp-&gt;cluster == 0) {  /* storable metrics are cluster 0 */
            switch (pmidp-&gt;item) {
            case 0:                           /* simple.numfetch */
                val = vsp-&gt;vlist[0].value.lval;
                if (val &lt; 0) {
                    sts = PM_ERR_SIGN;
                    val = 0;
                }
                numfetch = val;
                break;
            case 1:                             /* simple.color */
                /* a store request may affect multiple instances at once */
                for (j = 0; j &lt; vsp-&gt;numval &amp;&amp; sts == 0; j++) {
                    val = vsp-&gt;vlist[j].value.lval;
                    if (val &lt; 0) {
                        sts = PM_ERR_SIGN;
                        val = 0;
                    } if (val &gt; 255) {
                        sts = PM_ERR_CONV;
                        val = 255;
                    }</pre></div></div><div class="para">
						<a id="IG31340177197" class="indexterm"></a>The <code class="literal">simple.color</code> metric has an instance domain that must be searched because any or all instances may be specified. Any instances that are not supported in this instance domain should cause an error value of <code class="literal">PM_ERR_INST</code> to be returned as shown in <a class="xref" href="#Z976051081sdc">Example 2.23, “ <code class="literal">simple.color</code> and <code class="literal">PM_ERR_INST</code> Errors”</a>:
					</div><div class="example"><a id="Z976051081sdc">
      ⁠</a><p class="title"><strong>Example 2.23.  <code class="literal">simple.color</code> and <code class="literal">PM_ERR_INST</code> Errors</strong></p><div class="example-contents"><pre class="programlisting">                       switch (vsp-&gt;vlist[j].inst) {
                       case 0:                         /* red */
                           red = val;
                           break;
                       case 1:                         /* green */
                           green = val;
                           break;
                       case 2:                         /* blue */
                           blue = val;
                           break;
                       default:
                           sts = PM_ERR_INST;
                       }</pre></div></div><div class="para">
						<a id="IG31340177198" class="indexterm"></a>Any other PMIDs in cluster 0 that are not supported by the simple PMDA should result in an error value of <code class="literal">PM_ERR_PMID</code> as shown in <a class="xref" href="#Z976307148sdc">Example 2.24, “ <code class="literal">PM_ERR_PMID</code> Errors”</a>:
					</div><div class="example"><a id="Z976307148sdc">
      ⁠</a><p class="title"><strong>Example 2.24.  <code class="literal">PM_ERR_PMID</code> Errors</strong></p><div class="example-contents"><pre class="programlisting">                default:
                    sts = PM_ERR_PMID;
                    break;
            }
        }</pre></div></div><div class="para">
						Any metrics that cannot be altered should generate an error value of <code class="literal">PM_ERR_PERMISSION</code>, and metrics not supported by the PMDA should result in an error value of <code class="literal">PM_ERR_PMID</code> as shown in <a class="xref" href="#Z976050822sdc">Example 2.25, “ <code class="literal">PM_ERR_PERMISSION</code> and <code class="literal">PM_ERR_PMID</code> Errors”</a>:
					</div><div class="example"><a id="Z976050822sdc">
      ⁠</a><p class="title"><strong>Example 2.25.  <code class="literal">PM_ERR_PERMISSION</code> and <code class="literal">PM_ERR_PMID</code> Errors</strong></p><div class="example-contents"><pre class="programlisting">        else if ((pmidp-&gt;cluster == 1 &amp;&amp;
                 (pmidp-&gt;item == 2 || pmidp-&gt;item == 3)) ||
                 (pmidp-&gt;cluster == 2 &amp;&amp; pmidp-&gt;item == 4)) {
            sts = PM_ERR_PERMISSION;
            break;
        }
        else {
            sts = PM_ERR_PMID;
            break;
        }
    }
    return sts;
}</pre><div class="para">
							The structure <code class="literal">pmdaExt</code> <em class="replaceable">pmda</em> argument is not used by the <code class="command">simple_store</code> function above.
						</div></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							When using storable metrics, it is important to consider the implications. It is possible <code class="command">pmlogger</code> is actively sampling the metric being modified, for example, which may cause unexpected results to be persisted in an archive. Consider also the use of client credentials, available via the <code class="command">attribute</code> callback of the <code class="filename">pmdaInterface</code> structure, to appropriately limit access to any modifications that might be made via your storable metrics.
						</div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5193469">
      ⁠</a>2.5.1.4. Return Codes for <code class="command">pmdaFetch</code> Callbacks</h4></div></div></div><div class="para">
						In <code class="literal">PMDA_INTERFACE_1</code> and <code class="literal">PMDA_INTERFACE_2</code>, the return codes for the <code class="command">pmdaFetch</code> callback function are defined:
					</div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Value</span></dt><dd><div class="para">
									Meaning
								</div></dd><dt><span class="term">&lt; 0</span></dt><dd><div class="para">
									Error code (for example, <code class="literal">PM_ERR_PMID</code>, <code class="literal">PM_ERR_INST</code> or <code class="literal">PM_ERR_AGAIN</code>)
								</div></dd><dt><span class="term">0</span></dt><dd><div class="para">
									Success
								</div></dd></dl></div><div class="para">
						In <code class="literal">PMDA_INTERFACE_3</code> and all later versions, the return codes for the <code class="command">pmdaFetch</code> callback function are defined:
					</div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Value</span></dt><dd><div class="para">
									Meaning
								</div></dd><dt><span class="term">&lt; 0</span></dt><dd><div class="para">
									Error code (for example, <code class="literal">PM_ERR_PMID</code>, <code class="literal">PM_ERR_INST</code>)
								</div></dd><dt><span class="term">0</span></dt><dd><div class="para">
									Metric value not currently available
								</div></dd><dt><span class="term">&gt; 0</span></dt><dd><div class="para">
									Success
								</div></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5193658">
      ⁠</a>2.5.2. PMDA Structures</h3></div></div></div><div class="para">
					<a id="IG31340177199" class="indexterm"></a>PMDA structures used with the <code class="filename">pcp_pmda</code> library are defined in <code class="filename">&lt;pcp/pmda.h&gt;</code>. <a class="xref" href="#Z964112160sdc">Example 2.26, “ <code class="literal">pmdaInterface</code> Structure Header”</a> and <a class="xref" href="#Z964117744sdc">Example 2.28, “ <code class="literal">pmdaExt</code> Stucture”</a> describe the <code class="literal">pmdaInterface</code> and <code class="literal">pmdaExt</code> structures.
				</div><div class="example"><a id="Z964112160sdc">
      ⁠</a><p class="title"><strong>Example 2.26.  <code class="literal">pmdaInterface</code> Structure Header</strong></p><div class="example-contents"><div class="para">
						<a id="IG31340177200" class="indexterm"></a>The callbacks must be specified in a <code class="filename">pmdaInterface</code> structure:
					</div><pre class="programlisting">typedef struct {
    int domain;     /* set/return performance metrics domain id here */
    struct {
        unsigned int pmda_interface : 8;  /* PMDA DSO version */
        unsigned int pmapi_version : 8;   /* PMAPI version */
        unsigned int flags : 16;          /* optional feature flags */
    } comm;             /* set/return communication and version info */
    int status;         /* return initialization status here */
    union {
        ...
</pre></div></div><div class="para">
					This structure is passed by PMCD to a DSO PMDA as an argument to the initialization function. This structure supports multiple (binary-compatible) versions--the second and subsequent versions have support for the <code class="filename">pmdaExt</code> structure. Protocol version one is for backwards compatibility only, and should not be used in any new PMDA.
				</div><div class="para">
					To date there have been six revisions of the interface structure:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							Version two added the <code class="literal">pmdaExt</code> structure, as mentioned above.
						</div></li><li class="listitem"><div class="para">
							Version three changed the fetch callback return code semantics, as mentioned in <a class="xref" href="#id5193469">Section 2.5.1.4, “Return Codes for <code class="command">pmdaFetch</code> Callbacks”</a>.
						</div></li><li class="listitem"><div class="para">
							Version four added support for dynamic metric names, where the PMDA is able to create and remove metric names on-the-fly in response to changes in the performance domain (<code class="command">pmdaPMID</code>, <code class="command">pmdaName</code>, <code class="command">pmdaChildren</code> interfaces)
						</div></li><li class="listitem"><div class="para">
							Version five added support for per-client contexts, where the PMDA is able to track arrival and disconnection of PMAPI client tools via PMCD (<code class="command">pmdaGetContext</code> helper routine). At the same time, support for <code class="literal">PM_TYPE_EVENT</code> metrics was implemented, which relies on the per-client context concepts (<code class="command">pmdaEvent*</code> helper routines).
						</div></li><li class="listitem"><div class="para">
							Version six added support for authenticated client contexts, where the PMDA is informed of user credentials and other PMCD attributes of the connection between individual PMAPI clients and PMCD (<code class="command">pmdaAttribute</code> interface)
						</div></li></ul></div><div class="example"><a id="Z964112160nat">
      ⁠</a><p class="title"><strong>Example 2.27.  <code class="literal">pmdaInterface</code> Structure, Latest Version</strong></p><div class="example-contents"><pre class="programlisting">   ...
    union {
        ...
        /*
         * PMDA_INTERFACE6
         */ 
        struct {
            pmdaExt *ext;
            int     (*profile)(pmdaInProfile *, pmdaExt *);
            int     (*fetch)(int, pmID *, pmResult **, pmdaExt *);
            int     (*desc)(pmID, pmDesc *, pmdaExt *);
            int     (*instance)(pmInDom, int, char *, pmdaInResult **, pmdaExt *);
            int     (*text)(int, int, char **, pmdaExt *);
            int     (*store)(pmResult *, pmdaExt *);
            int     (*pmid)(const char *, pmID *, pmdaExt *);
            int     (*name)(pmID, char ***, pmdaExt *);
            int     (*children)(const char *, int, char ***, int **, pmdaExt *);
            int     (*attribute)(int, int, const char *, int, pmdaExt *);
        } six;
    } version;
} pmdaInterface;</pre></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						Each new interface version is always defined as a superset of those that preceded it, only adds fields at the end of the new structure in the union, and is always binary backwards-compatible. <code class="literal">And thus it shall remain.</code> For brevity, we have shown only the latest interface version (six) above, but all prior versions still exist, build, and function. In other words, PMDAs built against earlier versions of this header structure (and PMDA library) function correctly with the latest version of the PMDA library.
					</div></div></div><div class="example"><a id="Z964117744sdc">
      ⁠</a><p class="title"><strong>Example 2.28.  <code class="literal">pmdaExt</code> Stucture</strong></p><div class="example-contents"><div class="para">
						<a id="IG31340177201" class="indexterm"></a>Additional PMDA information must be specified in a <code class="filename">pmdaExt</code> structure:
					</div><a id="Z964117899sdc">
      ⁠</a><pre class="programlisting">typedef struct {
    unsigned int e_flags;       /* PMDA_EXT_FLAG_* bit field */
    void        *e_ext;         /* used internally within libpcp_pmda */
    char        *e_sockname;    /* socket name to pmcd */
    char        *e_name;        /* name of this pmda */
    char        *e_logfile;     /* path to log file */
    char        *e_helptext;    /* path to help text */
    int         e_status;       /* =0 is OK */
    int         e_infd;         /* input file descriptor from pmcd */
    int         e_outfd;        /* output file descriptor to pmcd */
    int         e_port;         /* port to pmcd */
    int         e_singular;     /* =0 for singular values */
    int         e_ordinal;      /* &gt;=0 for non-singular values */
    int         e_direct;       /* =1 if pmid map to meta table */
    int         e_domain;       /* metrics domain */
    int         e_nmetrics;     /* number of metrics */
    int         e_nindoms;      /* number of instance domains */
    int         e_help;         /* help text comes via this handle */
    __pmProfile *e_prof;        /* last received profile */
    pmdaIoType  e_io;           /* connection type to pmcd */
    pmdaIndom   *e_indoms;      /* instance domain table */
    pmdaIndom   *e_idp;         /* instance domain expansion */
    pmdaMetric  *e_metrics;     /* metric description table */
    pmdaResultCallBack e_resultCallBack; /* to clean up pmResult after fetch */
    pmdaFetchCallBack  e_fetchCallBack;  /* to assign metric values in fetch */
    pmdaCheckCallBack  e_checkCallBack;  /* callback on receipt of a PDU */
    pmdaDoneCallBack   e_doneCallBack;   /* callback after PDU is processed */
    /* added for PMDA_INTERFACE_5 */
    int         e_context;      /* client context id from pmcd */
    pmdaEndContextCallBack e_endCallBack;  /* callback after client context closed */
} pmdaExt;</pre></div></div><div class="para">
					<a id="IG31340177202" class="indexterm"></a> <a id="IG31340177203" class="indexterm"></a> <a id="IG31340177204" class="indexterm"></a> <a id="IG31340177205" class="indexterm"></a> <a id="IG31340177206" class="indexterm"></a>The <code class="filename">pmdaExt</code> structure contains filenames, pointers to tables, and some variables shared by several functions in the <code class="filename">pcp_pmda </code>library. All fields of the <code class="filename">pmdaInterface</code> and <code class="filename">pmdaExt</code> structures can be correctly set by PMDA initialization functions; see the <code class="command">pmdaDaemon(3)</code>, <code class="command">pmdaDSO(3)</code>, <code class="command">pmdaGetOptions(3)</code>, <code class="command">pmdaInit(3)</code>, and <code class="command">pmdaConnect(3)</code> man pages for a full description of how various fields in these structures may be set or used by <code class="filename">pcp_pmda</code> library functions.
				</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="LE19047-PARENT">
      ⁠</a>2.6. Initializing a PMDA</h2></div></div></div><div class="para">
				<a id="IG31340177207" class="indexterm"></a>Several functions are provided to simplify the initialization of a PMDA. These functions, if used, must be called in a strict order so that the PMDA can operate correctly.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5194056">
      ⁠</a>2.6.1. Overview</h3></div></div></div><div class="para">
					<a id="IG31340177208" class="indexterm"></a>The initialization process for a PMDA involves opening help text files, assigning callback function pointers, adjusting the metric and instance identifiers to the correct domains, and much more. The initialization of a daemon PMDA also differs significantly from a DSO PMDA, since the <code class="literal">pmdaInterface</code> structure is initialized by <code class="command">main</code> or the PMCD process, respectively.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5194087">
      ⁠</a>2.6.2. Common Initialization</h3></div></div></div><div class="para">
					<a id="IG31340177209" class="indexterm"></a>As described in <a class="xref" href="#LE82676-PARENT">Section 2.2.2, “DSO PMDA”</a>, an initialization function is provided by a DSO PMDA and called by PMCD. Using the standard PMDA wrappers, the same function can also be used as part of the daemon PMDA initialization. This PMDA initialization function performs the following tasks:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							Assigning callback functions to the function pointer interface of <code class="filename">pmdaInterface</code>
						</div></li><li class="listitem"><div class="para">
							Assigning pointers to the metric and instance tables from <code class="filename">pmdaExt</code>
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177210" class="indexterm"></a>Opening the help text files
						</div></li><li class="listitem"><div class="para">
							Assigning the domain number to the instance domains
						</div></li><li class="listitem"><div class="para">
							Correlating metrics with their instance domains
						</div></li></ul></div><div class="para">
					<a id="IG31340177211" class="indexterm"></a> <a id="IG31340177212" class="indexterm"></a>If the PMDA uses the common data structures defined for the <code class="filename">pcp_pmda</code> library, most of these requirements can be handled by the default <code class="command">pmdaInit</code> function; see the <code class="command">pmdaInit(3)</code> man page.
				</div><div class="para">
					Because the initialization function is the only initialization opportunity for a DSO PMDA, the common initialization function should also perform any DSO-specific functions that are required. A default implementation of this functionality is provided by the <code class="command">pmdaDSO</code> function; see the <code class="command">pmdaDSO(3)</code> man page.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5194313">
      ⁠</a>2.6.2.1. Trivial PMDA</h4></div></div></div><div class="para">
						<a id="IG31340177213" class="indexterm"></a> <a id="IG31340177214" class="indexterm"></a> <a id="IG31340177215" class="indexterm"></a> <a class="xref" href="#Z976058585sdc">Example 2.29, “Initialization in the Trivial PMDA”</a> shows the trivial PMDA, which has no instances (that is, all metrics have singular values) and a single callback. This callback is for the <code class="command">pmdaFetch</code> function called <code class="command">trivial_fetchCallBack</code>; see the <code class="command">pmdaFetch(3)</code> man page:
					</div><div class="example"><a id="Z976058585sdc">
      ⁠</a><p class="title"><strong>Example 2.29. Initialization in the Trivial PMDA</strong></p><div class="example-contents"><pre class="programlisting">static char     *username;
static int      isDSO = 1;              /* ==0 if I am a daemon */

void trivial_init(pmdaInterface *dp)
{
    if (isDSO)
        pmdaDSO(dp, PMDA_INTERFACE_2, “trivial DSO”,
                “${PCP_PMDAS_DIR}/trivial/help”);
    else
        __pmSetProcessIdentity(username);

    if (dp-&gt;status != 0)
        return;

    pmdaSetFetchCallBack(dp, trivial_fetchCallBack);
    pmdaInit(dp, NULL, 0,
             metrictab, sizeof(metrictab)/sizeof(metrictab[0]));
}</pre></div></div><div class="para">
						The trivial PMDA can execute as either a DSO or daemon PMDA. A default installation installs it as a daemon, however, and the <code class="command">main</code> routine clears <em class="replaceable">isDSO</em> and sets <em class="replaceable">username</em> accordingly.
					</div><div class="para">
						The <code class="command">trivial_init</code> routine provides the opportunity to do any extra DSO or daemon setup before calling the library <code class="command">pmdaInit</code>. In the example, the help text is setup for DSO mode and the daemon is switched to run as an unprivileged user (default is <code class="literal">root</code>, but it is generally good form for PMDAs to run with the least privileges possible). If <code class="literal">dp-&gt;status</code> is non-zero after the <code class="command">pmdaDSO</code> call, the PMDA will be removed by PMCD and cannot safely continue to use the <code class="command">pmdaInterface</code> structure.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5194416">
      ⁠</a>2.6.2.2. Simple PMDA</h4></div></div></div><div class="para">
						<a id="IG31340177216" class="indexterm"></a> <a id="IG31340177217" class="indexterm"></a> <a id="IG31340177218" class="indexterm"></a> <a id="IG31340177219" class="indexterm"></a>In <a class="xref" href="#Z976058770sdc">Example 2.30, “Initialization in the Simple PMDA”</a>, the simple PMDA uses its own callbacks to handle <code class="literal">PDU_FETCH</code> and <code class="literal">PDU_RESULT</code> request PDUs (for <code class="command">pmFetch</code> and <code class="command">pmStore</code> operations respectively), as well as providing <code class="command">pmdaFetch</code> with the callback <code class="command">simple_fetchCallBack</code>.
					</div><div class="example"><a id="Z976058770sdc">
      ⁠</a><p class="title"><strong>Example 2.30. Initialization in the Simple PMDA</strong></p><div class="example-contents"><pre class="programlisting">static int      isDSO = 1;              /* =0 I am a daemon */
static char     *username;

void simple_init(pmdaInterface *dp)
{
    if (isDSO)
        pmdaDSO(dp, PMDA_INTERFACE_2, “simple DSO”,
                “${PCP_PMDAS_DIR}/simple/help”);
    else
        __pmSetProcessIdentity(username);

    if (dp-&gt;status != 0)
        return;

    dp-&gt;version.any.fetch = simple_fetch;
    dp-&gt;version.any.store = simple_store;
    dp-&gt;version.any.instance = simple_instance;
    pmdaSetFetchCallBack(dp, simple_fetchCallBack);
    pmdaInit(dp, indomtab, sizeof(indomtab)/sizeof(indomtab[0]),
             metrictab, sizeof(metrictab)/sizeof(metrictab[0]));
}</pre></div></div><div class="para">
						Once again, the simple PMDA may be installed either as a daemon PMDA or a DSO PMDA. The static variable <em class="replaceable">isDSO</em> indicates whether the PMDA is running as a DSO or as a daemon. A daemon PMDA always changes the value of this variable to 0 in <code class="literal">main</code>, for PMDAs that can operate in both modes.
					</div><div class="para">
						Remember also, as described earlier, <code class="command">simple_fetch</code> is dealing with a single request for (possibly many) values for metrics from the PMDA, and <code class="command">simple_fetchCallBack</code> is its little helper, dealing with just one metric and one instance (optionally, if the metric happens to have an instance domain) within that larger request.
					</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5194563">
      ⁠</a>2.6.3. Daemon Initialization</h3></div></div></div><div class="para">
					In addition to the initialization function that can be shared by a DSO and a daemon PMDA, a daemon PMDA must also meet the following requirements:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							Create the <code class="filename">pmdaInterface</code> structure that is passed to the initialization function
						</div></li><li class="listitem"><div class="para">
							Parse any command-line arguments
						</div></li><li class="listitem"><div class="para">
							Open a log file (a DSO PMDA uses PMCD's log file)
						</div></li><li class="listitem"><div class="para">
							Set up the IPC connection between the PMDA and the PMCD process
						</div></li><li class="listitem"><div class="para">
							Handle incoming PDUs
						</div></li></ul></div><div class="para">
					<a id="IG31340177220" class="indexterm"></a> <a id="IG31340177221" class="indexterm"></a> <a id="IG31340177222" class="indexterm"></a> <a id="IG31340177223" class="indexterm"></a> <a id="IG31340177224" class="indexterm"></a>All these requirements can be handled by default initialization functions in the <code class="filename">pcp_pmda</code> library; see the <code class="command">pmdaDaemon(3)</code>, <code class="command">pmdaGetOptions(3)</code>, <code class="command">pmdaOpenLog(3)</code>, <code class="command">pmdaConnect(3)</code>, and <code class="command">pmdaMain(3)</code> man pages.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						Optionally, a daemon PMDA may wish to reduce or change its privilege level, as seen in <a class="xref" href="#Z976058585sdc">Example 2.29, “Initialization in the Trivial PMDA”</a> and <a class="xref" href="#Z976058770sdc">Example 2.30, “Initialization in the Simple PMDA”</a>. Some performance domains <code class="literal">require</code> the extraction process to run as a specific user in order to access the instrumentation. Many domains require the default <code class="literal">root</code> level of access for a daemon PMDA.
					</div></div></div><div class="para">
					<a id="IG31340177225" class="indexterm"></a>The simple PMDA specifies the command-line arguments it accepts using <code class="command">pmdaGetOptions</code>, as shown in <a class="xref" href="#Z964110483sdc">Example 2.31, “ <code class="literal">main</code> in the Simple PMDA”</a>. For additional information, see the <code class="command">pmdaGetOptions(3)</code> man page.
				</div><div class="example"><a id="Z964110483sdc">
      ⁠</a><p class="title"><strong>Example 2.31.  <code class="literal">main</code> in the Simple PMDA</strong></p><div class="example-contents"><pre class="programlisting">static pmLongOptions longopts[] = {
    PMDA_OPTIONS_HEADER(“Options”),
    PMOPT_DEBUG,
    PMDAOPT_DOMAIN,
    PMDAOPT_LOGFILE,
    PMDAOPT_USERNAME,
    PMOPT_HELP,
    PMDA_OPTIONS_TEXT(“\nExactly one of the following options may appear:”),
    PMDAOPT_INET,
    PMDAOPT_PIPE,
    PMDAOPT_UNIX,
    PMDAOPT_IPV6,
    PMDA_OPTIONS_END
};
static pmdaOptions opts = {
    .short_options = “D:d:i:l:pu:U:6:?”,
    .long_options = longopts,
};

int
main(int argc, char **argv)
{
    pmdaInterface       dispatch;

    isDSO = 0;
    __pmSetProgname(argv[0]);
    __pmGetUsername(&amp;username);
    pmdaDaemon(&amp;dispatch, PMDA_INTERFACE_2, pmProgname, SIMPLE,
               “simple.log”, “${PCP_PMDAS_DIR}/simple/help”);

    pmdaGetOptions(argc, argv, &amp;opts, &amp;dispatch);
    if (opts.errors) {
        pmdaUsageMessage(&amp;opts);
        exit(1);
    }
    if (opts.username)
        username = opts.username;

    pmdaOpenLog(&amp;dispatch);
    simple_init(&amp;dispatch);
    simple_timenow_check();
    pmdaConnect(&amp;dispatch);
    pmdaMain(&amp;dispatch);

    exit(0);
}</pre></div></div><div class="para">
					The conditions under which <code class="command">pmdaMain</code> will return are either unexpected error conditions (often from failed initialisation, which would already have been logged), or when PMCD closes the connection to the PMDA. In all cases the correct action to take is simply to exit cleanly, possibly after any final cleanup the PMDA may need to perform.
				</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5194770">
      ⁠</a>2.7. Testing and Debugging a PMDA</h2></div></div></div><div class="para">
				Ensuring the correct operation of a PMDA can be difficult, because the responsibility of providing metrics to the requesting PMCD process and simultaneously retrieving values from the target domain requires nearly real-time communication with two modules beyond the PMDA's control. Some tools are available to assist in this important task. <a id="IG31340177226" class="indexterm"></a> <a id="IG31340177227" class="indexterm"></a>
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5194836">
      ⁠</a>2.7.1. Overview</h3></div></div></div><div class="para">
					<a id="IG31340177228" class="indexterm"></a>Thoroughly testing a PMDA with PMCD is difficult, although testing a daemon PMDA is marginally simpler than testing a DSO PMDA. If a DSO PMDA exits, PMCD also exits because they share a single address space and control thread.
				</div><div class="para">
					The difficulty in using PMCD to test a daemon PMDA results from PMCD requiring timely replies from the PMDA in response to request PDUs. Although a timeout period can be set in <code class="filename">${PCP_PMCDOPTIONS_PATH}</code>, attaching a debugger (such as <code class="command">gdb</code>) to the PMDA process might cause an already running PMCD to close its connection with the PMDA. If timeouts are disabled, PMCD could wait forever to connect with the PMDA.
				</div><div class="para">
					If you suspect a PMDA has been terminated due to a timeout failure, check the PMCD log file, usually <code class="filename">${PCP_LOG_DIR}/pmcd/pmcd.log</code>.
				</div><div class="para">
					<a id="IG31340177229" class="indexterm"></a>A more robust way of testing a PMDA is to use the <code class="command">dbpmda</code> tool, which is similar to PMCD except that <code class="command">dbpmda</code> provides complete control over the PDUs that are sent to the PMDA, and there are no time limits--it is essentially an interactive debugger for exercising a PMDA. See the <code class="command">dbpmda(3)</code> man page for details.
				</div><div class="para">
					<a id="IG31340177230" class="indexterm"></a>In addition, careful use of PCP debugging flags can produce useful information concerning a PMDA's behavior; see the <code class="command">PMAPI(3)</code> and <code class="command">pmdbg(1)</code> man pages for a discussion of the PCP debugging and tracing framework.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5195016">
      ⁠</a>2.7.2. Debugging Information</h3></div></div></div><div class="para">
					<a id="IG31340177231" class="indexterm"></a> <a id="IG31340177232" class="indexterm"></a> <a id="IG31340177233" class="indexterm"></a>You can activate debugging flags in PMCD and most other PCP tools with the <code class="literal">-D</code> command-line option. Supported flags can be listed with the <code class="command">pmdbg</code> command; see the <code class="command">pmdbg(1)</code> man page. Setting the debug flag for PMCD in <code class="filename">${PCP_PMCDOPTIONS_PATH}</code> might generate too much information to be useful, especially if there are other clients and PMDAs connected to the PMCD process.
				</div><div class="para">
					The PMCD debugging flag can also be changed dynamically by storing a new value into the metric <code class="literal">pmcd.control.debug</code>:
				</div><pre class="programlisting"># <span class="bold bold"><strong>pmstore pmcd.control.debug 5</strong></span></pre><div class="para">
					Most of the <code class="filename">pcp_pmda</code> library functions log additional information if the <code class="literal">DBG_TRACE_LIBPMDA</code> flag is set within the PMDA; see the <code class="command">PMDA(3)</code> man page. The command-line argument <code class="command">-D</code> is trapped by <code class="command">pmdaGetOptions</code> to set the global debugging control variable <code class="literal">pmDebug</code>. Adding tests within the PMDA for the <code class="literal">DBG_TRACE_APPL0</code>, <code class="literal">DBG_TRACE_APPL1</code>, and <code class="literal">DBG_TRACE_APPL2</code> trace flags permits different levels of information to be logged to the PMDA's log file.
				</div><div class="para">
					All diagnostic, debugging, and tracing output from a PMDA should be written to the standard error stream. By convention, all debugging information is enclosed by preprocessor <code class="literal">#ifdef</code> <code class="command">PCP_DEBUG</code> statements so that they can be compiled out of the program at a later stage, if required, although this is rarely done in practice.
				</div><div class="para">
					<a id="IG31340177234" class="indexterm"></a>Adding this segment of code to the <code class="command">simple_store</code> metric causes a timestamped log message to be sent to the current log file whenever <code class="command">pmstore</code> attempts to change <code class="literal">simple.numfetch</code> and <code class="command">pmDebug</code> has the <code class="literal">DBG_TRACE_APPL0</code> flag set as shown in <a class="xref" href="#Z976060060sdc">Example 2.32, “ <code class="literal">simple.numfetch</code> in the Simple PMDA”</a>:
				</div><div class="example"><a id="Z976060060sdc">
      ⁠</a><p class="title"><strong>Example 2.32.  <code class="literal">simple.numfetch</code> in the Simple PMDA</strong></p><div class="example-contents"><pre class="programlisting">   case 0: /* simple.numfetch */ 
       	x
        val = vsp-&gt;vlist[0].value.lval; 
        if (val &lt; 0) { 
            sts = PM_ERR_SIGN; 
            val = 0; 
        } 
#ifdef PCP_DEBUG 
        if (pmDebug &amp; DBG_TRACE_APPL0) { 
            __pmNotifyErr(LOG_DEBUG,
                  "simple: %d stored into numfetch", val); 
        } 
#endif 
        numfetch = val; 
        break;</pre></div></div><div class="para">
					<a id="IG31340177235" class="indexterm"></a>For a description of <code class="command">pmstore</code>, see the <code class="command">pmstore(1)</code> man page.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5195283">
      ⁠</a>2.7.3.  <code class="command">dbpmda</code> Debug Utility</h3></div></div></div><div class="para">
					<a id="IG31340177236" class="indexterm"></a>The <code class="command">dbpmda</code> utility provides a simple interface to the PDU communication protocol. It allows daemon and DSO PMDAs to be tested with most request types, while the PMDA process may be monitored with a debugger, tracing utilities, and other diagnostic tools. The <code class="command">dbpmda(1)</code> man page contains a sample session with the <code class="filename">simple</code> PMDA.
				</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5195340">
      ⁠</a>2.8. Integration of a PMDA</h2></div></div></div><div class="para">
				<a id="IG31340177237" class="indexterm"></a>Several steps are required to install (or remove) a PMDA from a production PMCD environment without affecting the operation of other PMDAs or related visualization and logging tools.<a id="IG31340177238" class="indexterm"></a>
			</div><div class="para">
				The PMDA typically would have its own directory below <code class="filename">${PCP_PMDAS_DIR}</code> into which several files would be installed. In the description in <a class="xref" href="#LE55181-PARENT">Section 2.8.1, “Installing a PMDA”</a>, the PMDA of interest is assumed to be known by the name <code class="filename">newbie</code>, hence the PMDA directory would be <code class="filename">${PCP_PMDAS_DIR}/newbie</code>.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					Any installation or removal of a PMDA involves updating files and directories that are typically well protected. Hence the procedures described in this section must be executed as the superuser.
				</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE55181-PARENT">
      ⁠</a>2.8.1. Installing a PMDA</h3></div></div></div><div class="para">
					A PMDA is fully installed when these tasks are completed:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<a id="IG31340177239" class="indexterm"></a>Help text has been installed in a place where the PMDA can find it, usually in the PMDA directory <code class="filename">${PCP_PMDAS_DIR}/newbie</code>.
						</div></li><li class="listitem"><div class="para">
							The name space has been updated in the <code class="filename">${PCP_VAR_DIR}/pmns</code> directory.
						</div></li><li class="listitem"><div class="para">
							The PMDA binary has been installed, usually in the directory <code class="filename">${PCP_PMDAS_DIR}/newbie</code>.
						</div></li><li class="listitem"><div class="para">
							The <code class="filename">${PCP_PMCDCONF_PATH}</code> file has been updated.
						</div></li><li class="listitem"><div class="para">
							The PMCD process has been restarted or notified (with a <code class="literal">SIGHUP</code> signal) that the new PMDA exists.
						</div></li></ul></div><div class="para">
					The <code class="filename">Makefile</code> should include an <code class="literal">install</code> target to compile and link the PMDA (as a DSO, or a daemon or both) in the PMDA directory. The <code class="literal">clobber</code> target should remove any files created as a by-product of the <code class="literal">install</code> target.<a id="IG31340177240" class="indexterm"></a>
				</div><div class="para">
					You may wish to use <code class="filename">${PCP_PMDAS_DIR}/simple/Makefile</code> as a template for constructing a new PMDA <code class="filename">Makefile</code>; changing the assignment of <code class="literal">IAM</code> from <code class="literal">simple</code> to <code class="literal">newbie</code> would account for most of the required changes.
				</div><div class="para">
					The <code class="filename">Install</code> script should make use of the generic procedures defined in the script <code class="filename">${PCP_SHARE_DIR}/lib/pmdaproc.sh</code>, and may be as straightforward as the one used for the trivial PMDA, shown in <a class="xref" href="#Z976309325sdc">Example 2.33, “ <code class="filename">Install</code> Script for the Trivial PMDA”</a>:
				</div><div class="example"><a id="Z976309325sdc">
      ⁠</a><p class="title"><strong>Example 2.33.  <code class="filename">Install</code> Script for the Trivial PMDA</strong></p><div class="example-contents"><pre class="programlisting">. ${PCP_DIR}/etc/pcp.env
. ${PCP_SHARE_DIR}/lib/pmdaproc.sh

iam=trivial
pmda_interface=2

pmdaSetup
pmdainstall
exit</pre></div></div><div class="para">
					The variables, shown in <a class="xref" href="#id5195779">Table 2.1, “Variables to Control Behavior of Generic <code class="filename">pmdaproc.sh</code> Procedures”</a>, may be assigned values to modify the behavior of the <code class="literal">pmdaSetup</code> and <code class="literal">pmdainstall</code> procedures from <code class="filename">${PCP_SHARE_DIR}/lib/pmdaproc.sh</code>.
				</div><div class="table"><a id="id5195779">
      ⁠</a><p class="title"><strong>Table 2.1. Variables to Control Behavior of Generic <code class="filename">pmdaproc.sh</code> Procedures</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-14-rows" summary="Variables to Control Behavior of Generic pmdaproc.sh Procedures"><colgroup><col width="29%" /><col width="54%" /><col width="17%" /></colgroup><thead><tr valign="top"><th align="left" valign="bottom"> <div class="para">
									Shell Variable
								</div>
								 </th><th align="left" valign="bottom"> <div class="para">
									Use
								</div>
								 </th><th align="left" valign="bottom"> <div class="para">
									Default
								</div>
								 </th></tr></thead><tbody><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$iam</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Name of the PMDA; assignment to this variable is mandatory.
								</div>
								 <div class="para">
									Example: <code class="literal">iam=newbie</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$dso_opt</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Can this PMDA be installed as a DSO?
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">false</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$daemon_opt</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Can this PMDA be installed as a daemon?
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">true</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$perl_opt</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Is this PMDA a perl script?
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">false</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$python_opt</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Is this PMDA a python script?
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">false</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$pipe_opt</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									If installed as a daemon PMDA, is the default IPC via pipes?
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">true</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$socket_opt</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									If installed as a daemon PMDA, is the default IPC via an Internet socket?
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">false</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$socket_inet_def</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									If installed as a daemon PMDA, and the IPC method uses an Internet socket, the default port number.
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$ipc_prot</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									IPC style for PDU exchanges involving a daemon PMDA; <code class="literal">binary</code> or <code class="literal">text</code>.
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">binary</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$check_delay</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Delay in seconds between installing PMDA and checking if metrics are available.
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">3</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$args</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Additional command-line arguments passed to a daemon PMDA.
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$pmda_interface</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Version of the <code class="filename">libpcp_pmda</code> library required, used to determine the version for generating help text files.
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">1</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$pmns_source</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The name of the PMNS file (by default relative to the PMDA directory).
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">pmns</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$pmns_name</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									First-level name for this PMDA's metrics in the PMNS.
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">$iam</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$help_source</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The name of the help file (by default relative to the PMDA directory).
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">help</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$pmda_name</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The name of the executable for a daemon PMDA.
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">pmda$iam</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$dso_name</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The name of the shared library for a DSO PMDA.
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">pmda$iam.$dso_suffix</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$dso_entry</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The name of the initialization function for a DSO PMDA.
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">${iam}_init</code>
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$domain</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The numerical PMDA domain number (from <code class="filename">domain.h</code>).
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$SYMDOM</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The symbolic name of the PMDA domain number (from <code class="filename">domain.h</code>).
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">$status</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Exit status for the shell script
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<code class="literal">0</code>
								</div>
								 </td></tr></tbody></table></div></div><div class="para">
					In addition, the variables <code class="literal">do_pmda</code> and <code class="literal">do_check</code> will be set to reflect the intention to install the PMDA (as opposed to install just the PMNS) and to check the availability of the metrics once the PMDA is installed. By default, each variable is <code class="literal">true</code>; however, the command-line options <code class="literal">-N</code> and <code class="literal">-Q</code> to <code class="filename">Install</code> may be used to set the variables to <code class="literal">false</code>, as follows: <code class="literal">do_pmda</code> (<code class="command">-N</code>) and <code class="literal">do_check</code> (<code class="literal">-N</code> or <code class="literal">-Q</code>).
				</div><div class="para">
					The variables may also have their assignments changed by the user's response to the common prompt as shown in <a class="xref" href="#Z976309844sdc">Example 2.34, “Changing Variable Assignments”</a>:
				</div><div class="example"><a id="Z976309844sdc">
      ⁠</a><p class="title"><strong>Example 2.34. Changing Variable Assignments</strong></p><div class="example-contents"><pre class="programlisting">You will need to choose an appropriate configuration for installation 
of the ... Performance Metrics Domain Agent (PMDA).
  collector   collect performance statistics on this system
  monitor     allow this system to monitor local and/or remote systems
  both        collector and monitor configuration for this system</pre></div></div><div class="para">
					Obviously, for anything but the most trivial PMDA, after calling the <code class="filename">pmdaSetup</code> procedure, the <code class="filename">Install</code> script should also prompt for any PMDA-specific parameters, which are typically accumulated in the <em class="replaceable">args</em> variable and used by the <code class="literal">pmdainstall</code> procedure.
				</div><div class="para">
					The detailed operation of the <code class="filename">pmdainstall</code> procedure involves the following tasks:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							Using default assignments, and interaction where ambiguity exists, determine the PMDA type (DSO or daemon) and the IPC parameters, if any.
						</div></li><li class="listitem"><div class="para">
							Copy the <code class="filename">$pmns_source</code> file, replacing symbolic references to <code class="literal">SYMDOM</code> by the desired numeric domain number from <code class="literal">domain.</code>
						</div></li><li class="listitem"><div class="para">
							Merge the PMDA's name space into the PCP name space at the non-leaf node identified by <code class="filename">$pmns_name</code>.
						</div></li><li class="listitem"><div class="para">
							If any <code class="command">pmchart</code> views can be found (files with names ending in “.pmchart”), copy these to the standard directory (<code class="filename">${PCP_VAR_DIR}/config/pmchart</code>) with the “.pmchart” suffix removed.
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177241" class="indexterm"></a>Create new help files from <code class="literal">$help_source</code> after replacing symbolic references to <code class="literal">SYMDOM</code> by the desired numeric domain number from <code class="literal">domain</code>.
						</div></li><li class="listitem"><div class="para">
							Terminate the old daemon PMDA, if any.
						</div></li><li class="listitem"><div class="para">
							Use the <code class="filename">Makefile</code> to build the appropriate executables.
						</div></li><li class="listitem"><div class="para">
							Add the PMDA specification to PMCD's configuration file (<code class="filename">${PCP_PMCDCONF_PATH}</code>).
						</div></li><li class="listitem"><div class="para">
							Notify PMCD. To minimize the impact on the services PMCD provides, sending a <code class="literal">SIGHUP</code> to PMCD forces it to reread the configuration file and start, restart, or remove any PMDAs that have changed since the file was last read. However, if the newly installed PMDA must run using a different privilege level to PMCD then PMCD must be restarted. This is because PMCD runs unprivileged after initially starting the PMDAs.
						</div></li><li class="listitem"><div class="para">
							Check that the metrics from the new PMDA are available.
						</div></li></ul></div><div class="para">
					There are some PMDA changes that may trick PMCD into thinking nothing has changed, and not restarting the PMDA. Most notable are changes to the PMDA executable. In these cases, you may need to explicitly remove the PMDA as described in <a class="xref" href="#Z976310185sdc">Section 2.8.3, “Removing a PMDA”</a>, or more drastically, restart PMCD as follows: <a id="IG31340177242" class="indexterm"></a>
				</div><pre class="literallayout"># <strong class="userinput"><code>${PCP_RC_DIR}/pcp start</code></strong></pre><div class="para">
					<a id="IG31340177243" class="indexterm"></a>The files <code class="filename">${PCP_PMDAS_DIR}/*/Install</code> provide a wealth of examples that may be used to construct a new PMDA <code class="filename">Install</code> script.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5197100">
      ⁠</a>2.8.2. Upgrading a PMNS to Include Metrics from a New PMDA</h3></div></div></div><div class="para">
					<a id="IG31340177244" class="indexterm"></a> <a id="IG31340177245" class="indexterm"></a> <a id="IG31340177246" class="indexterm"></a>When invoked with a <code class="literal">-N</code> command-line option, the PMDA <code class="filename">Install</code> script may be used to update the PMNS without installing the PMDA. This functionality is rarely, if ever, used in modern versions of PCP, but allows one to populate the local PMNS with the names of the performance metrics from a PMDA installed on a remote host. The <code class="literal">-N</code> option can also install <code class="command">pmchart</code> views useful on a monitoring system, although this also is rarely used now with each platforms package management tools handling this task.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Z976310185sdc">
      ⁠</a>2.8.3. Removing a PMDA</h3></div></div></div><div class="para">
					<a id="IG31340177247" class="indexterm"></a>The simplest way to stop a PMDA from running, apart from killing the process, is to remove the entry from <code class="filename">${PCP_PMCDCONF_PATH}</code> and signal PMCD (with <code class="literal">SIGHUP</code>) to reread its configuration file. To completely remove a PMDA requires the reverse process of the installation, including an update of the Performance Metrics Name Space (PMNS).
				</div><div class="para">
					<a id="IG31340177248" class="indexterm"></a>This typically involves a <code class="filename">Remove</code> script in the PMDA directory that uses the same common procedures as the <code class="filename">Install</code> script described <a class="xref" href="#LE55181-PARENT">Section 2.8.1, “Installing a PMDA”</a>.
				</div><div class="para">
					<a id="IG31340177249" class="indexterm"></a>The <code class="filename">${PCP_PMDAS_DIR}/*/Remove</code> files provide a wealth of examples that may be used to construct a new PMDA <code class="filename">Remove</code> script.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5197301">
      ⁠</a>2.8.4. Configuring PCP Tools</h3></div></div></div><div class="para">
					<a id="IG31340177250" class="indexterm"></a> <a id="IG31340177251" class="indexterm"></a>Most PCP tools have their own configuration file format for specifying which metrics to view or to log. By using canned configuration files that monitor key metrics of the new PMDA, users can quickly see the performance of the target system, as characterized by key metrics in the new PMDA.
				</div><div class="para">
					Any configuration files that are created should be kept with the PMDA and installed into the appropriate directories when the PMDA is installed.
				</div><div class="para">
					As with all PCP customization, some of the most valuable tools can be created by defining views, scenes, and control-panel layouts that combine related performance metrics from multiple PMDAs or multiple hosts.
				</div><div class="para">
					<a id="IG31340177254" class="indexterm"></a> <a id="IG31340177255" class="indexterm"></a>Metrics suitable for on-going logging can be specified in templated <code class="command">pmlogger</code> configuration files for <code class="command">pmlogconf</code> to automatically add to the <code class="command">pmlogger_daily</code> recorded set; see the <code class="command">pmlogger(1)</code>, <code class="command">pmlogconf(1)</code> and <code class="command">pmlogger_daily(1)</code> man pages.
				</div><div class="para">
					<a id="IG31340177252" class="indexterm"></a> <a id="IG31340177253" class="indexterm"></a>Parameterized alarm configurations can be created using the <code class="command">pmieconf</code> facilities; see the <code class="command">pmieconf(1)</code> and <code class="command">pmie(1)</code> man pages.
				</div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="LE97135-PARENT">
      ⁠</a>Chapter 3. PMAPI--The Performance Metrics API</h1></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="#LE87626-PARENT">3.1. Naming and Identifying Performance Metrics</a></span></dt><dt><span class="section"><a href="#id5197718">3.2. Performance Metric Instances</a></span></dt><dt><span class="section"><a href="#id5198049">3.3. Current PMAPI Context</a></span></dt><dt><span class="section"><a href="#LE11914-PARENT">3.4. Performance Metric Descriptions</a></span></dt><dt><span class="section"><a href="#LE82331-PARENT">3.5. Performance Metrics Values</a></span></dt><dt><span class="section"><a href="#id5199202">3.6. Performance Event Metrics</a></span></dt><dd><dl><dt><span class="section"><a href="#id5199203nat">3.6.1. Event Monitor Considerations</a></span></dt><dt><span class="section"><a href="#id5199204nat">3.6.2. Event Collector Considerations</a></span></dt></dl></dd><dt><span class="section"><a href="#id5199203">3.7. PMAPI Programming Style and Interaction</a></span></dt><dd><dl><dt><span class="section"><a href="#LE37655-PARENT">3.7.1. Variable Length Argument and Results Lists</a></span></dt><dt><span class="section"><a href="#idm140437843077872">3.7.2. Python Specific Issues</a></span></dt><dt><span class="section"><a href="#LE62826-PARENT">3.7.3. PMAPI Error Handling</a></span></dt></dl></dd><dt><span class="section"><a href="#id5199561">3.8. PMAPI Procedural Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#LE32034-PARENT">3.8.1. PMAPI Name Space Services</a></span></dt><dt><span class="section"><a href="#LE89521-PARENT">3.8.2. PMAPI Metrics Description Services</a></span></dt><dt><span class="section"><a href="#LE27200-PARENT">3.8.3. PMAPI Instance Domain Services</a></span></dt><dt><span class="section"><a href="#LE94187-PARENT">3.8.4. PMAPI Context Services</a></span></dt><dt><span class="section"><a href="#LE34685-PARENT">3.8.5. PMAPI Timezone Services</a></span></dt><dt><span class="section"><a href="#LE25844-PARENT">3.8.6. PMAPI Metrics Services</a></span></dt><dt><span class="section"><a href="#fetchgroup">3.8.7. PMAPI Fetchgroup Services</a></span></dt><dt><span class="section"><a href="#LE40692-PARENT">3.8.8. PMAPI Record-Mode Services</a></span></dt><dt><span class="section"><a href="#LE85604-PARENT">3.8.9. PMAPI Archive-Specific Services</a></span></dt><dt><span class="section"><a href="#LE73955-PARENT">3.8.10. PMAPI Time Control Services</a></span></dt><dt><span class="section"><a href="#LE44064-PARENT">3.8.11. PMAPI Ancillary Support Services</a></span></dt></dl></dd><dt><span class="section"><a href="#id5212196">3.9. PMAPI Programming Issues and Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#id5212297">3.9.1. Symbolic Association between a Metric's Name and Value</a></span></dt><dt><span class="section"><a href="#id5212519">3.9.2. Initializing New Metrics</a></span></dt><dt><span class="section"><a href="#id5212595">3.9.3. Iterative Processing of Values</a></span></dt><dt><span class="section"><a href="#id5212682">3.9.4. Accommodating Program Evolution</a></span></dt><dt><span class="section"><a href="#id5212805">3.9.5. Handling PMAPI Errors</a></span></dt><dt><span class="section"><a href="#id5212855">3.9.6. Compiling and Linking PMAPI Applications</a></span></dt></dl></dd></dl></div><div class="para">
			<a id="IG31340177256" class="indexterm"></a> <a id="IG31340177257" class="indexterm"></a>This chapter describes the Performance Metrics Application Programming Interface (PMAPI) provided with Performance Co-Pilot (PCP).
		</div><div class="para">
			<a id="IG31340177258" class="indexterm"></a>The PMAPI is a set of functions and data structure definitions that allow client applications to access performance data from one or more Performance Metrics Collection Daemons (PMCDs) or from PCP archive logs. The PCP utilities are all written using the PMAPI.
		</div><div class="para">
			The most common use of PCP includes running performance monitoring utilities on a workstation (the monitoring system) while performance data is retrieved from one or more remote collector systems by a number of PCP processes. These processes execute on both the monitoring system and the collector systems. The collector systems are typically servers, and are the targets for the performance investigations.
		</div><div class="para">
			In the development of the PMAPI the most important question has been, “How easily and quickly will this API enable the user to build new performance tools, or exploit existing tools for newly available performance metrics?” The PMAPI and the standard tools that use the PMAPI have enjoyed a symbiotic evolution throughout the development of PCP.
		</div><div class="para">
			It will be convenient to differentiate between code that uses the PMAPI and code that implements the services of the PMAPI. The former will be termed “above the PMAPI” and the latter “below the PMAPI.”
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="LE87626-PARENT">
      ⁠</a>3.1. Naming and Identifying Performance Metrics</h2></div></div></div><div class="para">
				<a id="IG31340177259" class="indexterm"></a> <a id="IG31340177260" class="indexterm"></a> <a id="IG31340177261" class="indexterm"></a>Across all of the supported performance metric domains, there are a large number of performance metrics. Each metric has its own description, format, and semantics. PCP presents a uniform interface to these metrics above the PMAPI, independent of the source of the underlying metric data. For example, the performance metric <code class="literal">hinv.physmem</code> has a single 32-bit unsigned integer value, representing the number of megabytes of physical memory in the system, while the performance metric <code class="literal">disk.dev.total</code> has one 32-bit unsigned integer value per disk spindle, representing the cumulative count of I/O operations involving each associated disk spindle. These concepts are described in greater detail in <a class="xref" href="#LE97285-PARENT">Section 2.3, “Domains, Metrics, and Instances”</a>.
			</div><div class="para">
				For brevity and efficiency, internally PCP avoids using names for performance metrics, and instead uses an identification scheme that unambiguously associates a single integer with each known performance metric. This integer is known as a Performance Metric Identifier, or PMID. For functions using the PMAPI, a PMID is defined and manipulated with the typedef <code class="literal">pmID</code>.
			</div><div class="para">
				Below the PMAPI, the integer value of the PMID has an internal structure that reflects the details of the PMCD and PMDA architecture, as described in <a class="xref" href="#LE98565-PARENT">Section 2.3.3, “Metrics”</a>.
			</div><div class="para">
				Above the PMAPI, a Performance Metrics Name Space (PMNS) is used to provide a hierarchic classification of external metric names, and a one-to-one mapping of external names to internal PMIDs. A more detailed description of the PMNS can be found in the <em class="citetitle">Performance Co-Pilot User's and Administrator's Guide</em>.
			</div><div class="para">
				The default PMNS comes from the performance metrics source, either a PMCD process or a PCP archive. This PMNS always reflects the available metrics from the performance metrics source
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5197718">
      ⁠</a>3.2. Performance Metric Instances</h2></div></div></div><div class="para">
				<a id="IG31340177262" class="indexterm"></a>When performance metric values are returned across the PMAPI to a requesting application, there may be more than one value for a particular metric; for example, independent counts for each CPU, or each process, or each disk, or each system call type, and so on. This multiplicity of values is not enumerated in the Name Space, but rather when performance metrics are delivered across the PMAPI.
			</div><div class="para">
				The notion of <code class="literal">metric instances</code> is really a number of related concepts, as follows:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						A particular performance metric may have a set of associated values or instances.
					</div></li><li class="listitem"><div class="para">
						The instances are differentiated by an instance identifier.
					</div></li><li class="listitem"><div class="para">
						An instance identifier has an internal encoding (an integer value) and an external encoding (a corresponding external name or label).
					</div></li><li class="listitem"><div class="para">
						The set of all possible instance identifiers associated with a performance metric on a particular host constitutes an <em class="firstterm">instance domain</em>.
					</div></li><li class="listitem"><div class="para">
						Several performance metrics may share the same instance domain.
					</div></li></ul></div><div class="para">
				Consider <a class="xref" href="#Z976548024sdc">Example 3.1, “Metrics Sharing the Same Instance Domain”</a>:
			</div><div class="example"><a id="Z976548024sdc">
      ⁠</a><p class="title"><strong>Example 3.1. Metrics Sharing the Same Instance Domain</strong></p><div class="example-contents"><pre class="programlisting">
          <strong class="userinput"><code>$ pminfo -f filesys.free</code></strong>

filesys.free
    inst [1 or “/dev/disk0”] value 1803
    inst [2 or “/dev/disk1”] value 22140
    inst [3 or “/dev/disk2”] value 157938</pre></div></div><div class="para">
				The metric <code class="literal">filesys.free</code> has three values, currently 1803, 22140, and 157938. These values are respectively associated with the instances identified by the internal identifiers 1, 2 and 3, and the external identifiers <code class="filename">/dev/disk0</code>, <code class="filename">/dev/disk1</code>, and <code class="filename">/dev/disk2</code>. These instances form an instance domain that is shared by the performance metrics <code class="literal">filesys.capacity</code>, <code class="literal">filesys.used</code>, <code class="literal">filesys.free</code>, <code class="literal">filesys.mountdir</code>, and so on.
			</div><div class="para">
				Each performance metric is associated with an instance domain, while each instance domain may be associated with many performance metrics. Each instance domain is identified by a unique value, as defined by the following <code class="literal">typedef</code> declaration:
			</div><pre class="literallayout">
        <code class="literal">typedef unsigned long pmInDom;</code>
</pre><div class="para">
				<a id="IG31340177263" class="indexterm"></a>The special instance domain <code class="literal">PM_INDOM_NULL</code> is reserved to indicate that the metric has a single value (a singular instance domain). For example, the performance metric <code class="literal">mem.freemem</code> always has exactly one value. Note that this is semantically different to a performance metric like <code class="literal">kernel.percpu.cpu.sys</code> that has a non-singular instance domain, but may have only one value available; for example, on a system with a single processor.
			</div><div class="para">
				<a id="IG31340177264" class="indexterm"></a>In the results returned above the PMAPI, each individual instance within an instance domain is identified by an internal integer instance identifier. The special instance identifier <code class="literal">PM_IN_NULL</code> is reserved for the single value in a singular instance domain. Performance metric values are delivered across the PMAPI as a set of instance identifier and value pairs.
			</div><div class="para">
				The instance domain of a metric may change with time. For example, a machine may be shut down, have several disks added, and be rebooted. All performance metrics associated with the instance domain of disk devices would contain additional values after the reboot. The difficult issue of transient performance metrics means that repeated requests for the same PMID may return different numbers of values, or some changes in the particular instance identifiers returned. This means applications need to be aware that metric instantiation is guaranteed to be valid only at the time of collection.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					Some instance domains are more dynamic than others. For example, consider the instance domains behind the performance metrics <code class="literal">proc.memory.rss</code> (one instance per process), <code class="literal">swap.free</code> (one instance per swap partition) and <code class="literal">kernel.percpu.cpu.intr</code> (one instance per CPU).
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5198049">
      ⁠</a>3.3. Current PMAPI Context</h2></div></div></div><div class="para">
				<a id="IG31340177265" class="indexterm"></a>When performance metrics are retrieved across the PMAPI, they are delivered in the context of a particular source of metrics, a point in time, and a profile of desired instances. This means that the application making the request has already negotiated across the PMAPI to establish the context in which the request should be executed.
			</div><div class="para">
				<a id="IG31340177266" class="indexterm"></a>A metric's source may be the current performance data from a particular host (a live or real-time source), or a set of archive logs of performance data collected by <code class="command">pmlogger</code> at some remote host or earlier time (a retrospective or archive source). The metric's source is specified when the PMAPI context is created by calling the <code class="command">pmNewContext</code> function. This function returns an opaque handle which can be used to identify the context.
			</div><div class="para">
				<a id="IG31340177267" class="indexterm"></a>The collection time for a performance metric is always the current time of day for a real-time source, or current position for an archive source. For archives, the collection time may be set to an arbitrary time within the bounds of the set of archive logs by calling the <code class="command">pmSetMode</code> function.
			</div><div class="para">
				The last component of a PMAPI context is an instance profile that may be used to control which particular instances from an instance domain should be retrieved. When a new PMAPI context is created, the initial state expresses an interest in all possible instances, to be collected at the current time. The instance profile can be manipulated using the <code class="command">pmAddProfile</code> and <code class="command">pmDelProfile</code> functions.
			</div><div class="para">
				The current context can be changed by passing a context handle to <code class="command">pmUseContext</code>. If a live context connection fails, the <code class="command">pmReconnectContext</code> function can be used to attempt to reconnect it.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="LE11914-PARENT">
      ⁠</a>3.4. Performance Metric Descriptions</h2></div></div></div><div class="para">
				<a id="IG31340177268" class="indexterm"></a>For each defined performance metric, there is associated metadata encoded in a performance metric description (<code class="command">pmDesc</code> structure) that describes the format and semantics of the performance metric. The <code class="command">pmDesc</code> structure, in <a class="xref" href="#Z976548425sdc">Example 3.2, “ <code class="command">pmDesc</code> Structure”</a>, provides all of the information required to interpret and manipulate a performance metric through the PMAPI. It has the following declaration:
			</div><div class="example"><a id="Z976548425sdc">
      ⁠</a><p class="title"><strong>Example 3.2.  <code class="command">pmDesc</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">/* Performance Metric Descriptor */
typedef struct {
    pmID    pmid;   /* unique identifier */
    int     type;   /* base data type (see below) */
    pmInDom indom;  /* instance domain */
    int     sem;    /* semantics of value (see below) */
    pmUnits units;  /* dimension and units (see below) */
} pmDesc;</pre></div></div><div class="para">
				The <code class="literal">type</code> field in the <code class="filename">pmDesc</code> structure describes various encodings of a metric's value. Its value will be one of the following constants:
			</div><pre class="programlisting">/* pmDesc.type - data type of metric values */
#define PM_TYPE_NOSUPPORT -1   /* not in this version */
#define PM_TYPE_32        0    /* 32-bit signed integer */
#define PM_TYPE_U32       1    /* 32-bit unsigned integer */
#define PM_TYPE_64        2    /* 64-bit signed integer */
#define PM_TYPE_U64       3    /* 64-bit unsigned integer */
#define PM_TYPE_FLOAT     4    /* 32-bit floating point */
#define PM_TYPE_DOUBLE    5    /* 64-bit floating point */
#define PM_TYPE_STRING    6    /* array of char */
#define PM_TYPE_AGGREGATE 7    /* arbitrary binary data */
#define PM_TYPE_AGGREGATE_STATIC 8 /* static pointer to aggregate */
#define PM_TYPE_EVENT     9    /* packed pmEventArray */
#define PM_TYPE_UNKNOWN   255  /* used in pmValueBlock not pmDesc */</pre><div class="para">
				<a id="IG31340177269" class="indexterm"></a>By convention <code class="literal">PM_TYPE_STRING</code> is interpreted as a classic C-style null byte terminated string.
			</div><div class="para">
				<a id="IG31340177269nat" class="indexterm"></a>Event records are encoded as a packed array of strongly-typed, well-defined records within a <code class="literal">pmResult</code> structure, using a container metric with a value of type <code class="literal">PM_TYPE_EVENT</code>.
			</div><div class="para">
				<a id="IG31340177270" class="indexterm"></a>If the value of a performance metric is of type <code class="literal">PM_TYPE_STRING</code>, <code class="literal">PM_TYPE_AGGREGATE</code>, <code class="literal">PM_TYPE_AGGREGATE_STATIC</code>, or <code class="literal">PM_TYPE_EVENT</code>, the interpretation of that value is unknown to many PCP components. In the case of the aggregate types, the application using the value and the Performance Metrics Domain Agent (PMDA) providing the value must have some common understanding about how the value is structured and interpreted. Strings can be manipulated using the standard C libraries. Event records contain timestamps, event flags and event parameters, and the PMAPI provides support for unpacking an event record - see the <code class="command">pmUnpackEventRecords(3)</code> man page for details. Further discussion on event metrics and event records can be found in <a class="xref" href="#id5199202">Section 3.6, “Performance Event Metrics”</a>.
			</div><div class="para">
				<a id="IG31340177271" class="indexterm"></a> <code class="literal">PM_TYPE_NOSUPPORT</code> indicates that the PCP collection framework knows about the metric, but the corresponding service or application is either not configured or is at a revision level that does not provide support for this performance metric.
			</div><div class="para">
				The semantics of the performance metric is described by the <code class="literal">sem</code> field of a <code class="filename">pmDesc</code> structure and uses the following constants:
			</div><pre class="programlisting">/* pmDesc.sem - semantics of metric values */
#define PM_SEM_COUNTER  1  /* cumulative count, monotonic increasing */
#define PM_SEM_INSTANT  3  /* instantaneous value continuous domain */
#define PM_SEM_DISCRETE 4  /* instantaneous value discrete domain */</pre><div class="para">
				<a id="IG31340177272" class="indexterm"></a> <a id="IG31340177273" class="indexterm"></a>Each value for a performance metric is assumed to be drawn from a set of values that can be described in terms of their dimensionality and scale by a compact encoding, as follows:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						The dimensionality is defined by a power, or index, in each of three orthogonal dimensions: Space, Time, and Count (dimensionless). For example, I/O throughput is Space<sup>1</sup>.Time<sup>-1</sup>, while the running total of system calls is Count<sup>1</sup>, memory allocation is Space<sup>1</sup>, and average service time per event is Time<sup>1</sup>.Count<sup>-1</sup>.
					</div></li><li class="listitem"><div class="para">
						In each dimension, a number of common scale values are defined that may be used to better encode ranges that might otherwise exhaust the precision of a 32-bit value. For example, a metric with dimension Space<sup>1</sup>.Time<sup>-1</sup> may have values encoded using the scale megabytes per second.
					</div></li></ul></div><div class="para">
				<a id="IG31340177274" class="indexterm"></a>This information is encoded in the <code class="filename">pmUnits</code> data structure, shown in <a class="xref" href="#Z1034792511tls">Example 3.3, “ <code class="filename">pmUnits</code> and <code class="filename">pmDesc</code> Structures”</a>. It is embedded in the <code class="filename">pmDesc</code> structure :
			</div><div class="para">
				The structures are as follows:
			</div><div class="example"><a id="Z1034792511tls">
      ⁠</a><p class="title"><strong>Example 3.3.  <code class="filename">pmUnits</code> and <code class="filename">pmDesc</code> Structures</strong></p><div class="example-contents"><pre class="programlisting">/*
 * Encoding for the units (dimensions and
 * scale) for Performance Metric Values
 *
 * For example, a pmUnits struct of
 * { 1, -1, 0, PM_SPACE_MBYTE, PM_TIME_SEC, 0 }
 * represents Mbytes/sec, while 
 * { 0, 1, -1, 0, PM_TIME_HOUR, 6 }
 * represents hours/million-events
 */
typedef struct {
    int pad:8;
    int scaleCount:4; /* one of PM_COUNT_* below */
    int scaleTime:4;  /* one of PM_TIME_* below */
    int scaleSpace:4; /* one of PM_SPACE_* below */    
    int dimCount:4;   /* event dimension */
    int dimTime:4;    /* time dimension */
    int dimSpace:4;   /* space dimension
} pmUnits;   /* dimensional units and scale of value */
/* pmUnits.scaleSpace */
#define PM_SPACE_BYTE 0  /* bytes */
#define PM_SPACE_KBYTE 1 /* Kilobytes (1024) */
#define PM_SPACE_MBYTE 2 /* Megabytes (1024^2) */
#define PM_SPACE_GBYTE 3 /* Gigabytes (1024^3) */
#define PM_SPACE_TBYTE 4 /* Terabytes (1024^4) */
/* pmUnits.scaleTime */
#define PM_TIME_NSEC 0   /* nanoseconds */
#define PM_TIME_USEC 1   /* microseconds */
#define PM_TIME_MSEC 2   /* milliseconds */
#define PM_TIME_SEC 3    /* seconds */
#define PM_TIME_MIN 4    /* minutes */
#define PM_TIME_HOUR 5   /* hours */
/*
 * pmUnits.scaleCount (e.g. count events, syscalls,
 * interrupts, etc.) -- these are simply powers of 10,
 * and not enumerated here.
 * e.g. 6 for 10^6, or -3 for 10^-3
 */
#define PM_COUNT_ONE 0 /* 1 */</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="LE82331-PARENT">
      ⁠</a>3.5. Performance Metrics Values</h2></div></div></div><div class="para">
				<a id="IG31340177275" class="indexterm"></a> <a id="IG31340177276" class="indexterm"></a>An application may fetch (or store) values for a set of performance metrics, each with a set of associated instances, using a single <code class="command">pmFetch</code> (or <code class="command">pmStore</code>) function call. To accommodate this, values are delivered across the PMAPI in the form of a tree data structure, rooted at a <code class="filename">pmResult</code> structure. This encoding is illustrated in <a class="xref" href="#id5198718">Figure 3.1, “A Structured Result for Performance Metrics from <code class="command">pmFetch</code>”</a>, and uses the component data structures in <a class="xref" href="#Z976557818sdc">Example 3.4, “ <code class="command">pmValueBlock</code> and <code class="command">pmValue</code> Structures”</a>:
			</div><div class="example"><a id="Z976557818sdc">
      ⁠</a><p class="title"><strong>Example 3.4.  <code class="command">pmValueBlock</code> and <code class="command">pmValue</code> Structures</strong></p><div class="example-contents"><pre class="programlisting">typedef struct {
    int inst;                 /* instance identifier */
    union {
        pmValueBlock *pval;   /* pointer to value-block */
        int           lval;   /* integer value insitu */
    } value;
} pmValue;</pre></div></div><div class="para">
				<div class="figure"><a id="id5198718">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><object data="images/pmresult.svg" type="image/svg+xml"><img src="images/pmresult.png" alt="A Structured Result for Performance Metrics from pmFetch" /></object></div></div><p class="title"><strong>Figure 3.1. A Structured Result for Performance Metrics from <code class="command">pmFetch</code></strong></p></div>

			</div><div class="para">
				<a id="IG31340177277" class="indexterm"></a>The internal instance identifier is stored in the <code class="literal">inst</code> element. If a value for a particular metric-instance pair is a 32-bit integer (signed or unsigned), then it will be stored in the <code class="literal">lval</code> element. If not, the value will be in a <code class="literal">pmValueBlock</code> structure, as shown in <a class="xref" href="#Z1034793414tls">Example 3.5, “<code class="literal">pmValueBlock</code> Structure”</a>, and will be located via <code class="literal">pval</code>:
			</div><div class="para">
				The <code class="literal">pmValueBlock</code> structure is as follows:
				<div class="example"><a id="Z1034793414tls">
      ⁠</a><p class="title"><strong>Example 3.5. <code class="literal">pmValueBlock</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">typedef struct {
    unsigned int    vlen : 24;    /* bytes for vtype/vlen + vbuf */
    unsigned int    vtype : 8;    /* value type */
    char            vbuf[1];      /* the value */
} pmValueBlock;</pre></div></div>
			</div><div class="para">
				<a id="IG31340177278" class="indexterm"></a>The length of the <code class="filename">pmValueBlock</code> (including the <code class="literal">vtype</code> and <code class="literal">vlen</code> fields) is stored in <code class="literal">vlen</code>. Despite the prototype declaration of <code class="literal">vbuf</code>, this array really accommodates <code class="literal">vlen</code> minus <code class="command">sizeof</code>(<code class="literal">vlen</code>) bytes. The <code class="literal">vtype</code> field encodes the type of the value in the <code class="literal">vbuf[]</code> array, and is one of the <code class="command">PM_TYPE_*</code> macros defined in <code class="filename">&lt;pcp/pmapi.h&gt;</code>.
			</div><div class="para">
				<a id="IG31340177279" class="indexterm"></a>A <code class="filename">pmValueSet</code> structure, as shown in <a class="xref" href="#Z976549488sdc">Example 3.6, “ <code class="filename">pmValueSet</code> Structure”</a>, contains all of the values to be returned from <code class="command">pmFetch</code> for a single performance metric identified by the <code class="literal">pmid</code> field.
			</div><div class="example"><a id="Z976549488sdc">
      ⁠</a><p class="title"><strong>Example 3.6.  <code class="filename">pmValueSet</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">typedef struct {
    pmID    pmid;          /* metric identifier */
    int     numval;        /* number of values */
    int     valfmt;        /* value style, insitu or ptr */
    pmValue vlist[1];      /* set of instances/values */ 
} pmValueSet;</pre></div></div><div class="para">
				If positive, the <code class="literal">numval</code> field identifies the number of value-instance pairs in the <code class="literal">vlist</code> array (despite the prototype declaration of size 1). If <code class="literal">numval</code> is zero, there are no values available for the associated performance metric and <code class="literal">vlist</code>[0] is undefined. A negative value for <code class="literal">numval</code> indicates an error condition (see the <code class="command">pmErrStr(3)</code> man page) and <code class="literal">vlist</code>[0] is undefined. The <code class="literal">valfmt</code> field has the value <code class="literal">PM_VAL_INSITU</code> to indicate that the values for the performance metrics should be located directly via the <code class="literal">lval</code> member of the <code class="literal">value</code> union embedded in the elements of <code class="literal">vlist</code>; otherwise, metric values are located indirectly via the <code class="literal">pval</code> member of the elements of <code class="literal">vlist</code>.
			</div><div class="para">
				<a id="IG31340177280" class="indexterm"></a>The <code class="filename">pmResult</code> structure, as shown in <a class="xref" href="#Z976549833sdc">Example 3.7, “ <code class="filename">pmResult</code> Structure”</a>, contains a time stamp and an array of <code class="literal">numpmid</code> pointers to <code class="filename">pmValueSet</code>.
			</div><div class="example"><a id="Z976549833sdc">
      ⁠</a><p class="title"><strong>Example 3.7.  <code class="filename">pmResult</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">/* Result returned by pmFetch() */
typedef struct {
    struct timeval timestamp;    /* stamped by collector */
    int            numpmid;      /* number of PMIDs */
    pmValueSet     *vset[1];     /* set of value sets */
} pmResult</pre></div></div><div class="para">
				There is one <code class="literal">pmValueSet</code> pointer per PMID, with a one-to-one correspondence to the set of requested PMIDs passed to <code class="command">pmFetch</code>.
			</div><div class="para">
				Along with the metric values, the PMAPI returns a time stamp with each <code class="filename">pmResult</code> that serves to identify when the performance metric values were collected. The time is in the format returned by <code class="command">gettimeofday</code> and is typically very close to the time when the metric values were extracted from their respective domains.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					There is a question of exactly when individual metrics may have been collected, especially given their origin in potentially different performance metric domains, and variability in metric updating frequency by individual PMDAs. PCP uses a pragmatic approach, in which the PMAPI implementation returns all metrics with values accurate as of the time stamp, to the maximum degree possible, and PMCD demands that all PMDAs deliver values within a small realtime window. The resulting inaccuracy is small, and the additional burden of accurate individual timestamping for each returned metric value is neither warranted nor practical (from an implementation viewpoint).
				</div></div></div><div class="para">
				The PMAPI provides functions to extract, rescale, and print values from the above structures; refer to <a class="xref" href="#LE44064-PARENT">Section 3.8.11, “PMAPI Ancillary Support Services”</a>.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5199202">
      ⁠</a>3.6. Performance Event Metrics</h2></div></div></div><div class="para">
				In addition to performance metric values which are sampled by monitor tools, PCP supports the notion of performance event metrics which occur independently to any sampling frequency. These event metrics (PM_TYPE_EVENT) are delivered using a novel approach which allows both sampled and event trace data to be delivered via the same live wire protocol, the same on-disk archive format, and fundamentally using the same PMAPI services. In other words, a monitor tool may be sample and trace, simultaneously, using the PMAPI services discussed here.
			</div><div class="para">
				Event metrics are characterised by certain key properties, distinguishing them from the other metric types (counters, instantaneous, and discrete):
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						Occur at times outside of any monitor tools control, and often have a fine-grained timestamp associated with each event.
					</div></li><li class="listitem"><div class="para">
						Often have parameters associated with the event, which further describe each individual event, as shown in <a class="xref" href="#id5198719nat">Figure 3.2, “Sample <code class="command">write(2)</code> syscall entry point encoding”</a>.
					</div></li><li class="listitem"><div class="para">
						May occur in very rapid succession, at rates such that both the collector and monitor sides may not be able to track all events. This property requires the PCP protocol to support the notion of "dropped" or "missed" events.
					</div></li><li class="listitem"><div class="para">
						There may be inherent relationships between events, for example the start and commit (or rollback) of a database transaction could be separate events, linked by a common transaction identifier (which would likely also be one of the parameters to each event). Begin-end and parent-child relationships are relatively common, and these properties require the PCP protocol to support the notion of "flags" that can be associated with events.
					</div></li></ul></div><div class="para">
				These differences aside, the representation of event metrics within PCP shares many aspects of the other metric types - event metrics appear in the Name Space (as do each of the event parameters), each has an associated Performance Metric Identifier and Descriptor, may have an instance domain associated with them, and may be recorded by <code class="command">pmlogger</code> for subsequent replay.
			</div><div class="para">
				<div class="figure"><a id="id5198719nat">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><object data="images/syscallevent.svg" type="image/svg+xml"><img src="images/syscallevent.png" alt="Sample syscall entry point encoding" /></object></div></div><p class="title"><strong>Figure 3.2. Sample <code class="command">write(2)</code> syscall entry point encoding</strong></p></div>

			</div><div class="para">
				Event metrics and their associated information (parameters, timestamps, flags, and so on) are delivered to monitoring tools alongside sampled metrics as part of the <code class="command">pmResult</code> structure seen previously in <a class="xref" href="#Z976549833sdc">Example 3.7, “ <code class="filename">pmResult</code> Structure”</a>.
			</div><div class="para">
				The semantics of <code class="command">pmFetch(3)</code> specifying an event metric PMID are such that all events observed on the collector since the previous fetch (by this specific monitor client) are to transfered to the monitor. Each event will have the metadata described earlier encoded with it (timestamps, flags, and so on) for each event. The encoding of the series of events involves a compound data structure within the <code class="command">pmValueSet</code> associated with the event metric PMID, as illustrated in <a class="xref" href="#id5198719">Figure 3.3, “Result Format for Event Performance Metrics from <code class="command">pmFetch</code>”</a>.
			</div><div class="para">
				<div class="figure"><a id="id5198719">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><object data="images/pmevents.svg" type="image/svg+xml"><img src="images/pmevents.png" alt="Result Format for Event Performance Metrics from pmFetch" /></object></div></div><p class="title"><strong>Figure 3.3. Result Format for Event Performance Metrics from <code class="command">pmFetch</code></strong></p></div>

			</div><div class="para">
				At the highest level, the "series of events" is encapsulated within a <code class="command">pmEventArray</code> structure, as in <a class="xref" href="#Z976557818nat">Example 3.8, “ <code class="command">pmEventArray</code> and <code class="command">pmEventRecord</code> Structures”</a>:
			</div><div class="example"><a id="Z976557818nat">
      ⁠</a><p class="title"><strong>Example 3.8.  <code class="command">pmEventArray</code> and <code class="command">pmEventRecord</code> Structures</strong></p><div class="example-contents"><pre class="programlisting">typedef struct {
    __pmTimeval      er_timestamp;  /* 2 x 32-bit timestamp format */
    unsigned int     er_flags;      /* event record characteristics */
    int              er_nparams;    /* number of ea_param[] entries */
    pmEventParameter er_param[1];
} pmEventRecord;

typedef struct {
    unsigned int     ea_len :  24;  /* bytes for type/len + records */
    unsigned int     ea_type : 8;   /* value type */
    int              ea_nrecords;   /* number of ea_record entries */
    pmEventRecord    ea_record[1];
} pmEventArray;</pre></div></div><div class="para">
				Note that in the case of dropped events, the <code class="command">pmEventRecord</code> structure is used to convey the number of events dropped - <em class="replaceable">er_flags</em> is used to indicate the presence of dropped events, and <em class="replaceable">er_nparams</em> is used to hold a count. Unsurprisingly, the parameters (<em class="replaceable">er_param</em>) will be empty in this situation.
			</div><div class="para">
				The <code class="literal">pmEventParameter</code> structure is as follows:
			</div><div class="example"><a id="Z1034793415nat">
      ⁠</a><p class="title"><strong>Example 3.9.  <code class="literal">pmEventParameter</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">typedef struct {
    pmID             ep_pmid;       /* parameter identifier */
    unsigned int     ep_type;       /* value type */
    int              ep_len;        /* bytes for type/len + vbuf */
    /* actual value (vbuf) here */
} pmEventParameter;</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5199203nat">
      ⁠</a>3.6.1. Event Monitor Considerations</h3></div></div></div><div class="para">
					<a id="IG31340177280nat" class="indexterm"></a>In order to simplify the decoding of event record arrays, the PMAPI provides the <code class="command">pmUnpackEventRecords</code> function for monitor tools. This function is passed a pointer to a <code class="command">pmValueSet</code> associated with an event metric (within a <code class="command">pmResult</code>) from a <code class="command">pmFetch(3)</code>. For a given instance of that event metric, it returns an array of "unpacked" <code class="command">pmResult</code> structures for each event.
				</div><div class="para">
					The control information (flags and optionally dropped events) is included as derived metrics within each result structure. As such, these values can be queried similarly to other metrics, using their names - <code class="literal">event.flags</code> and <code class="literal">event.missed</code>. Note that these metrics will only exist after the first call to <code class="command">pmUnpackEventRecords</code>.
				</div><div class="para">
					An example of decoding event metrics in this way is presented in <a class="xref" href="#Z976557819nat">Example 3.10, “Unpacking Event Records from an Event Metric <code class="literal">pmValueSet</code>”</a>:
				</div><div class="example"><a id="Z976557819nat">
      ⁠</a><p class="title"><strong>Example 3.10. Unpacking Event Records from an Event Metric <code class="literal">pmValueSet</code></strong></p><div class="example-contents"><pre class="programlisting">enum { event_flags = 0, event_missed = 1 };
static char *metadata[] = { "event.flags", "event.missed" };
static pmID metapmid[2];

void dump_event(pmValueSet *vsp, int idx)
{
    pmResult    **res;
    int	        r, sts, nrecords;

    nrecords = pmUnpackEventRecords(vsp, idx, &amp;res);
    if (nrecords &lt; 0)
        fprintf(stderr, " pmUnpackEventRecords: %s\n", pmErrStr(nrecords));
    else
        printf(" %d event records\n", nrecords);

    if ((sts = pmLookupName(2, &amp;metadata, &amp;metapmid)) &lt; 0) {
        fprintf(stderr, "Event metadata error: %s\n", pmErrStr(sts));
        exit(1);
    }

    for (r = 0; r &lt; nrecords; r++)
        dump_event_record(res, r);

    if (nrecords &gt;= 0)
        pmFreeEventResult(res);
}

void dump_event_record(pmResult *res, int r)
{
    int         p;

    __pmPrintStamp(stdout, &amp;res[r]-&gt;timestamp);
    if (res[r]-&gt;numpmid == 0)
       	printf(" ==&gt; No parameters\n");
    for (p = 0; p &lt; res[r]-&gt;numpmid; p++) {
        pmValueSet  *vsp = res[r]-&gt;vset[p];

        if (vsp-&gt;numval &lt; 0) {
            int error = vsp-&gt;numval;
            printf("%s: %s\n", pmIDStr(vsp-&gt;pmid), pmErrStr(error));
        } else if (vsp-&gt;pmid == metapmid[event_flags]) {
            int flags = vsp-&gt;vlist[0].value.lval;
            printf(" flags 0x%x (%s)\n", flags, pmEventFlagsStr(flags));
        } else if (vsp-&gt;pmid == metapmid[event_missed]) {
            int count = vsp-&gt;vlist[0].value.lval;
            printf(" ==&gt; %d missed event records\n", count);
        } else {
            dump_event_record_parameters(vsp);
        }
    }
}

void dump_event_record_parameters(pmValueSet *vsp)
{
    pmDesc      desc;
    char        *name;
    int         sts, j;

    if ((sts = pmLookupDesc(vsp-&gt;pmid, &amp;desc)) &lt; 0) {
        fprintf(stderr, "pmLookupDesc: %s\n", pmErrStr(sts));
    } else
    if ((sts = pmNameID(vsp-&gt;pmid, &amp;name)) &lt; 0) {
        fprintf(stderr, "pmNameID: %s\n", pmErrStr(sts));
    } else {
        printf("parameter %s", name);
        for (j = 0; j &lt; vsp-&gt;numval; j++) {
            pmValue *vp = &amp;vsp-&gt;vlist[j];
            if (vsp-&gt;numval &gt; 1) {
                printf("[%d]", vp-&gt;inst);
                pmPrintValue(stdout, vsp-&gt;valfmt, desc.type, vp, 1);
                putchar('\n');
            }
        }
        free(name);
    }
}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5199204nat">
      ⁠</a>3.6.2. Event Collector Considerations</h3></div></div></div><div class="para">
					There is a feedback mechanism that is inherent in the design of the PCP monitor-collector event metric value exchange, which protects both monitor and collector components from becoming overrun by high frequency event arrivals. It is important that PMDA developers are aware of this mechanism and all of its implications.
				</div><div class="para">
					Monitor tools can query new event arrival on whatever schedule they choose. There are no guarantees that this is a fixed interval, and no way for the PMDA to attempt to dictate this interval (nor should there be).
				</div><div class="para">
					As a result, a PMDA that provides event metrics must:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							Track individual client connections using the per-client PMDA extensions (PMDA_INTERFACE_5 or later).
						</div></li><li class="listitem"><div class="para">
							Queue events, preferably in a memory-efficient manner, such that each interested monitor tool (there may be more than one) is informed of those events that arrived since their last request.
						</div></li><li class="listitem"><div class="para">
							Control the memory allocated to in-memory event storage. If monitors are requesting new events too slowly, compared to event arrival on the collector, the "missed events" feedback mechanism must be used to inform the monitor. This mechanism is also part of the model by which a PMDA can fix the amount of memory it uses. Once a fixed space is consumed, events can be dropped from the tail of the queue for each client, provided a counter is incremented and the client is subsequently informed.
						</div></li></ul></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						It is important that PMDAs are part of the performance solution, and not part of the performance problem! With event metrics, this is much more difficult to achieve than with counters or other sampled values.
					</div></div></div><div class="para">
					There is certainly elegance to this approach for event metrics, and the way they dovetail with other, sampled performance metrics is unique to PCP. Notice also how the scheme naturally allows multiple monitor tools to consume the same events, no matter what the source of events is. The downside to this flexibility is increased complexity in the PMDA when event metrics are used.
				</div><div class="para">
					This complexity comes in the form of event queueing and memory management, as well as per-client state tracking. Routines are available as part of the <code class="command">pcp_pmda</code> library to assist, however - refer to the man page entries for <code class="command">pmdaEventNewQueue(3)</code> and <code class="command">pmdaEventNewClient(3)</code> for further details.
				</div><div class="para">
					One final set of helper APIs is available to PMDA developers who incorporate event metrics. There is a need to build the <code class="command">pmEventArray</code> structure, introduced in <a class="xref" href="#Z976557818nat">Example 3.8, “ <code class="command">pmEventArray</code> and <code class="command">pmEventRecord</code> Structures”</a>. This can be done directly, or using the helper routine <code class="command">pmdaEventNewArray(3)</code>. If the latter, simpler model is chosen, the closely related routines <code class="command">pmdaEventAddRecord</code>, <code class="command">pmdaEventAddParam</code> and <code class="command">pmdaEventAddMissedRecord</code> would also usually be used.
				</div><div class="para">
					Depending on the nature of the events being exported by a PMDA, it can be desirable to perform <span class="bold bold"><strong>filtering</strong></span> of events on the collector system. This reduces the amount of event traffic between monitor and collector systems (which may be filtered further on the monitor system, before presenting results). Some PMDAs have had success using the <code class="command">pmStore(3)</code> mechanism to allow monitor tools to send a filter to the PMDA - using either a special control metric for the store operation, or the event metric itself. The filter sent will depend on the event metric, but it might be a regular expression, or a tracing script, or something else.
				</div><div class="para">
					This technique has also been used to <span class="bold bold"><strong>enable</strong></span> and <span class="bold bold"><strong>disable</strong></span> event tracing entirely. It is often appropriate to make use of authentication and user credentials when providing such a facility (PMDA_INTERFACE_6 or later).
				</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5199203">
      ⁠</a>3.7. PMAPI Programming Style and Interaction</h2></div></div></div><div class="para">
				<a id="IG31340177281" class="indexterm"></a>The following sections describe the PMAPI programming style:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						Variable length argument and results lists
					</div></li><li class="listitem"><div class="para">
						Python specific issues
					</div></li><li class="listitem"><div class="para">
						PMAPI error handling
					</div></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE37655-PARENT">
      ⁠</a>3.7.1. Variable Length Argument and Results Lists</h3></div></div></div><div class="para">
					<a id="IG31340177282" class="indexterm"></a> <a id="IG31340177283" class="indexterm"></a>All arguments and results involving a “list of something” are encoded as an array with an associated argument or function value to identify the number of elements in the array. This encoding scheme avoids both the <code class="literal">varargs</code> approach and sentinel-terminated lists. Where the size of a result is known at the time of a call, it is the caller's responsibility to allocate (and possibly free) the storage, and the called function assumes that the resulting argument is of an appropriate size.
				</div><div class="para">
					<a id="IG31340177284" class="indexterm"></a> <a id="IG31340177285" class="indexterm"></a> <a id="IG31340177286" class="indexterm"></a> <a id="IG31340177287" class="indexterm"></a> <a id="IG31340177288" class="indexterm"></a> <a id="IG31340177289" class="indexterm"></a> <a id="IG31340177290" class="indexterm"></a>Where a result is of variable size and that size cannot be known in advance (for example, <code class="command">pmGetChildren</code>, <code class="command">pmGetInDom</code>, <code class="command">pmNameInDom</code>, <code class="command">pmNameID</code>, <code class="command">pmLookupText</code>, and <code class="command">pmFetch</code>), the underlying implementation uses dynamic allocation through <code class="command">malloc</code> in the called function, with the caller responsible for subsequently calling <code class="command">free</code> to release the storage when no longer required. In the case of the result from <code class="command">pmFetch</code>, there is a function (<code class="command">pmFreeResult</code>) to release the storage, due to the complexity of the data structure and the need to make multiple calls to <code class="command">free</code> in the correct sequence. As a general rule, if the called function returns an error status, then no allocation is done, the pointer to the variable sized result is undefined, and <code class="command">free</code> or <code class="command">pmFreeResult</code> should not be called.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140437843077872">
      ⁠</a>3.7.2. Python Specific Issues</h3></div></div></div><div class="para">
					<a id="python-issues" class="indexterm"></a> A pcp client may be written in the python language by making use of the python bindings for PMAPI. The bindings use the python ctypes module to provide an interface to the PMAPI C language data structures. The primary imports that are needed by a client are: 
					<div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
								cpmapi which provides access to PMAPI constants 
<pre class="programlisting">import cpmapi as c_api</pre>
							</div></li><li class="listitem"><div class="para">
								pmapi which provides access to PMAPI functions and data structures 
<pre class="programlisting">from pcp import pmapi</pre>
							</div></li><li class="listitem"><div class="para">
								pmErr which provides access to the python bindings exception handler 
<pre class="programlisting">from pcp.pmapi import pmErr</pre>
							</div></li><li class="listitem"><div class="para">
								pmgui which provides access to PMAPI record mode functions 
<pre class="programlisting">from pcp import ppmgui</pre>
							</div></li></ul></div>
					 Creating and destroying a PMAPI context in the python environment is done by creating and destroying an object of the pmapi class. This is done in one of two ways, either directly: 
<pre class="programlisting">    context = pmapi.pmContext()</pre>
					 or by automated processing of the command line arguments (refer to the <code class="command">pmGetOptions</code> man page for greater detail). 
<pre class="programlisting">    options = pmapi.pmOptions(...)
    context = pmapi.pmContext.fromOptions(options, sys.argv)</pre>
					 Most PMAPI C functions have python equivalents with similar, although not identical, call signatures. Some of the python functions do not return native python types, but instead return native C types wrapped by the ctypes library. In most cases these types are opaque, or nearly so; for example <em class="replaceable">pmid</em>: 
<pre class="programlisting">   pmid = context.pmLookupName("mem.freemem")
   desc = context.pmLookupDescs(pmid)
   result = context.pmFetch(pmid)
   ...</pre>
					 See the comparison of a standalone C and python client application in <a class="xref" href="#id5212839">Example 3.23, “PMAPI Error Handling”</a>.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE62826-PARENT">
      ⁠</a>3.7.3. PMAPI Error Handling</h3></div></div></div><div class="para">
					<a id="IG31340177291" class="indexterm"></a>Where error conditions may arise, the functions that compose the PMAPI conform to a single, simple error notification scheme, as follows:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							The function returns an <code class="literal">int</code>. Values greater than or equal to zero indicate no error, and perhaps some positive status: for example, the number of items processed.
						</div></li><li class="listitem"><div class="para">
							Values less than zero indicate an error, as determined by a global table of error conditions and messages.
						</div></li></ul></div><div class="para">
					A PMAPI library function along the lines of <code class="command">strerror</code> is provided to translate error conditions into error messages; see the <code class="command">pmErrStr(3)</code> and <code class="command">pmErrStr_r(3)</code> man pages. The error condition is returned as the function value from a previous PMAPI call; there is no global error indicator (unlike <code class="literal">errno</code>). This is to accommodate multi-threaded performance tools.
				</div><div class="para">
					The available error codes may be displayed with the following command:
				</div><pre class="programlisting">
          <strong class="userinput"><code>pmerr -l</code></strong>
</pre><div class="para">
					Where possible, PMAPI routines are made as tolerant to failure as possible. In particular, routines which deal with compound data structures - results structures, multiple name lookups in one call and so on, will attempt to return all data that can be returned successfully, and errors embedded in the result where there were (partial) failures. In such cases a negative failure return code from the routine indicates catastrophic failure, otherwise success is returned and indicators for the partial failures are returned embedded in the results.
				</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5199561">
      ⁠</a>3.8. PMAPI Procedural Interface</h2></div></div></div><div class="para">
				The following sections describe all of the PMAPI functions that provide access to the PCP infrastructure on behalf of a client application:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						PMAPI Name Space services
					</div></li><li class="listitem"><div class="para">
						PMAPI metric description services
					</div></li><li class="listitem"><div class="para">
						PMAPI instance domain services
					</div></li><li class="listitem"><div class="para">
						PMAPI context services
					</div></li><li class="listitem"><div class="para">
						PMAPI timezone services
					</div></li><li class="listitem"><div class="para">
						PMAPI metrics services
					</div></li><li class="listitem"><div class="para">
						PMAPI fetchgroup services
					</div></li><li class="listitem"><div class="para">
						PMAPI record-mode services
					</div></li><li class="listitem"><div class="para">
						PMAPI archive-specific services
					</div></li><li class="listitem"><div class="para">
						PMAPI time control services
					</div></li><li class="listitem"><div class="para">
						PMAPI ancillary support services
					</div></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE32034-PARENT">
      ⁠</a>3.8.1. PMAPI Name Space Services</h3></div></div></div><div class="para">
					The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) Name Space services.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5199677">
      ⁠</a>3.8.1.1.  <code class="command">pmGetChildren</code> Function</h4></div></div></div><pre class="literallayout">int pmGetChildren(const char*<em class="replaceable">name</em>, char***<em class="replaceable">offspring</em>)
<code class="command">Python:</code>
[name1, name2...] = pmGetChildren(<em class="replaceable">name</em>)</pre><div class="para">
						<a id="IG31340177292" class="indexterm"></a> <a id="IG31340177293" class="indexterm"></a>Given a full pathname to a node in the current PMNS, as identified by <em class="replaceable">name</em>, return through <em class="replaceable">offspring</em> a list of the relative names of all the immediate descendents of <em class="replaceable">name</em> in the current PMNS. As a special case, if <em class="replaceable">name</em> is an empty string, (that is, <code class="literal">""</code> but not <code class="literal">NULL</code> or <code class="literal">(char *)0</code>), the immediate descendents of the root node in the PMNS are returned.
					</div><div class="para">
						For the python bindings a tuple containing the relative names of all the immediate descendents of <em class="replaceable">name</em> in the current PMNS is returned.
					</div><div class="para">
						Normally, <code class="command">pmGetChildren</code> returns the number of descendent names discovered, or a value less than zero for an error. The value zero indicates that the <em class="replaceable">name</em> is valid, and associated with a leaf node in the PMNS.
					</div><div class="para">
						The resulting list of pointers (<em class="replaceable">offspring</em>) and the values (relative metric names) that the pointers reference are allocated by <code class="command">pmGetChildren</code> with a single call to <code class="command">malloc</code>, and it is the responsibility of the caller to issue a <code class="command">free</code><em class="replaceable">(offspring)</em> system call to release the space when it is no longer required. When the result of <code class="command">pmGetChildren</code> is less than one, <em class="replaceable">offspring</em> is undefined (no space is allocated, and so calling <code class="command">free</code> is counterproductive).
					</div><div class="para">
						The python bindings return a tuple containing the relative names of all the immediate descendents of <em class="replaceable">name</em>, where <em class="replaceable">name</em> is a full pathname to a node in the current PMNS.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5199872">
      ⁠</a>3.8.1.2.  <code class="command">pmGetChildrenStatus</code> Function</h4></div></div></div><pre class="literallayout">int pmGetChildrenStatus(const char *<em class="replaceable">name</em>, char ***<em class="replaceable">offspring</em>, int **<em class="replaceable">status</em>)
<code class="command">Python:</code>
([name1, name2...],[status1, status2...]) = pmGetChildrenStatus(<em class="replaceable">name</em>)</pre><div class="para">
						<a id="IG31340177294" class="indexterm"></a>The <code class="command">pmGetChildrenStatus</code> function is an extension of <code class="command">pmGetChildren</code> that optionally returns status information about each of the descendent names.
					</div><div class="para">
						Given a fully qualified pathname to a node in the current PMNS, as identified by <em class="replaceable">name</em>, <code class="command">pmGetChildrenStatus</code> returns by means of <em class="replaceable">offspring</em> a list of the relative names of all of the immediate descendent nodes of <em class="replaceable">name</em> in the current PMNS. If <em class="replaceable">name</em> is the empty string (””), it returns the immediate descendents of the root node in the PMNS.
					</div><div class="para">
						If <em class="replaceable">status</em> is not NULL, then <code class="command">pmGetChildrenStatus</code> also returns the status of each child by means of <em class="replaceable">status</em>. This refers to either a leaf node (with value <code class="literal">PMNS_LEAF_STATUS</code>) or a non-leaf node (with value <code class="literal">PMNS_NONLEAF_STATUS</code>).
					</div><div class="para">
						Normally, <code class="command">pmGetChildrenStatus</code> returns the number of descendent names discovered, or else a value less than zero to indicate an error. The value zero indicates that name is a valid metric name, being associated with a leaf node in the PMNS.
					</div><div class="para">
						The resulting list of pointers (<em class="replaceable">offspring</em>) and the values (relative metric names) that the pointers reference are allocated by <code class="command">pmGetChildrenStatus</code> with a single call to <code class="command">malloc</code>, and it is the responsibility of the caller to <code class="command">free</code>(<em class="replaceable">offspring</em>) to release the space when it is no longer required. The same holds true for the <em class="replaceable">status</em> array.
					</div><div class="para">
						The python bindings return a tuple containing the relative names and statuses of all the immediate descendents of <em class="replaceable">name</em>, where <em class="replaceable">name</em> is a full pathname to a node in the current PMNS.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5200032">
      ⁠</a>3.8.1.3.  <code class="command">pmGetPMNSLocation</code> Function</h4></div></div></div><pre class="literallayout">int pmGetPMNSLocation(void)
<code class="command">Python:</code>
int loc = pmGetPMNSLocation()</pre><div class="para">
						<a id="IG31340177295" class="indexterm"></a>If an application needs to know where the origin of a PMNS is, <code class="command">pmGetPMNSLocation</code> returns whether it is an archive (<code class="filename">PMNS_ARCHIVE</code>), a local PMNS file (<code class="filename">PMNS_LOCAL</code>), or a remote PMCD (<code class="filename">PMNS_REMOTE</code>). This information may be useful in determining an appropriate error message depending on PMNS location.
					</div><div class="para">
						The python bindings return whether a PMNS is an archive <em class="replaceable">cpmapi.PMNS_ARCHIVE</em>, a local PMNS file <em class="replaceable">cpmapi.PMNS_LOCAL</em>, or a remote PMCD <em class="replaceable">cpmapi.PMNS_REMOTE</em>. The constants are available by importing cpmapi.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5200074">
      ⁠</a>3.8.1.4.  <code class="command">pmLoadNameSpace</code> Function</h4></div></div></div><pre class="literallayout">int pmLoadNameSpace(const char *<em class="replaceable">filename</em>)
<code class="command">Python:</code>
int <em class="replaceable">status</em> = pmLoadNameSpace(<em class="replaceable">filename</em>)</pre><div class="para">
						<a id="IG31340177296" class="indexterm"></a>In the highly unusual situation that an application wants to force using a local Performance Metrics Name Space (PMNS), the application can load the PMNS using <code class="command">pmLoadNameSpace</code>.
					</div><div class="para">
						The <em class="replaceable">filename</em> argument designates the PMNS of interest. For applications that do not require a tailored Name Space, the special value <code class="literal">PM_NS_DEFAULT</code> may be used for <em class="replaceable">filename</em>, to force a default local PMNS to be established. Externally, a PMNS is stored in an ASCII format.
					</div><div class="para">
						The python bindings load a local tailored Name Space from <em class="replaceable">filename</em>.
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							Do not use this routine in monitor tools. The distributed PMNS services avoid the need for a local PMNS; so applications should <span class="bold bold"><strong>not</strong></span> use <code class="command">pmLoadNameSpace</code>. Without this call, the default PMNS is the one at the source of the performance metrics (PMCD or an archive).
						</div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5200342">
      ⁠</a>3.8.1.5.  <code class="command">pmLookupName</code> Function</h4></div></div></div><pre class="literallayout">int pmLookupName(int <em class="replaceable">numpmid</em>, char *<em class="replaceable">namelist</em>[], pmID <em class="replaceable">pmidlist</em>[])
<code class="command">Python:</code>
c_uint <em class="replaceable">pmid</em> [] = pmLookupName(<em class="replaceable">"MetricName"</em>)
c_uint <em class="replaceable">pmid</em> [] = pmLookupName((<em class="replaceable">"MetricName1"</em>, <em class="replaceable">"MetricName2"</em>, ...))</pre><div class="para">
						<a id="IG31340177298" class="indexterm"></a>Given a list in <em class="replaceable">namelist</em> containing <em class="replaceable">numpmid</em> full pathnames for performance metrics from the current PMNS, <code class="command">pmLookupName</code> returns the list of associated PMIDs through the <em class="replaceable">pmidlist</em> parameter. Invalid metrics names are translated to the error PMID value of <code class="literal">PM_ID_NULL</code>.
					</div><div class="para">
						The result from <code class="command">pmLookupName</code> is the number of names translated in the absence of errors, or an error indication. Note that argument definition and the error protocol guarantee a one-to-one relationship between the elements of <em class="replaceable">namelist</em> and <em class="replaceable">pmidlist</em>; both lists contain exactly <em class="replaceable">numpmid</em> elements.
					</div><div class="para">
						The python bindings return an array of associated PMIDs corresponding to a tuple of <em class="replaceable">MetricNames</em>. The returned <em class="replaceable">pmid</em> tuple is passed to <code class="command">pmLookupDescs</code> and <code class="command">pmFetch</code>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5200423">
      ⁠</a>3.8.1.6.  <code class="command">pmNameAll</code> Function</h4></div></div></div><pre class="literallayout">int pmNameAll(pmID <em class="replaceable">pmid</em>, char ***<em class="replaceable">nameset</em>)
<code class="command">Python:</code>
[name1, name2...] = pmNameAll(<em class="replaceable">pmid</em>)</pre><div class="para">
						<a id="IG31340177299" class="indexterm"></a>Given a performance metric ID in <em class="replaceable">pmid</em>, <code class="command">pmNameAll</code> determines all the corresponding metric names, if any, in the PMNS, and returns these through <em class="replaceable">nameset</em>.
					</div><div class="para">
						The resulting list of pointers <em class="replaceable">nameset</em> and the values (relative names) that the pointers reference are allocated by <code class="command">pmNameAll</code> with a single call to <code class="command">malloc</code>. It is the caller's responsibility to call <code class="command">free</code> and release the space when it is no longer required.
					</div><div class="para">
						In the absence of errors, <code class="command">pmNameAll</code> returns the number of names in <code class="command">nameset</code>.
					</div><div class="para">
						For many PMNS instances, there is a 1:1 mapping between a name and a PMID, and under these circumstances, <code class="command">pmNameID</code> provides a simpler interface in the absence of duplicate names for a particular PMID.
					</div><div class="para">
						The python bindings return a tuple of all metric names having this identical <em class="replaceable">pmid</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5200532">
      ⁠</a>3.8.1.7.  <code class="command">pmNameID</code> Function</h4></div></div></div><pre class="literallayout">int pmNameID(pmID <em class="replaceable">pmid</em>, char **<em class="replaceable">name</em>)
<code class="command">Python:</code>
"metric name" = pmNameID(<em class="replaceable">pmid</em>)</pre><div class="para">
						<a id="IG31340177300" class="indexterm"></a>Given a performance metric ID in <em class="replaceable">pmid</em>, <code class="command">pmNameID</code> determines the corresponding metric name, if any, in the current PMNS, and returns this through <em class="replaceable">name</em>.
					</div><div class="para">
						In the absence of errors, <code class="command">pmNameID</code> returns zero. The <em class="replaceable">name</em> argument is a null byte terminated string, allocated by <code class="command">pmNameID</code> using <code class="command">malloc</code>. It is the caller's responsibility to call <code class="command">free</code> and release the space when it is no longer required.
					</div><div class="para">
						The python bindings return a metric name corresponding to a <em class="replaceable">pmid</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5200683">
      ⁠</a>3.8.1.8.  <code class="command">pmTraversePMNS</code> Function</h4></div></div></div><pre class="literallayout">int pmTraversePMNS(const char *<em class="replaceable">name</em>, void (*<code class="command">dometric</code>)(const char *))
<code class="command">Python:</code>
int <em class="replaceable">status</em> = pmTraversePMNS(<em class="replaceable">name</em>, <em class="replaceable">traverse_callback</em>)</pre><div class="para">
						<a id="IG31340177301" class="indexterm"></a>The function <code class="command">pmTraversePMNS</code> may be used to perform a depth-first traversal of the PMNS. The traversal starts at the node identified by <em class="replaceable">name</em> --if <em class="replaceable">name</em> is an empty string, the traversal starts at the root of the PMNS. Usually, <em class="replaceable">name</em> would be the pathname of a non-leaf node in the PMNS.
					</div><div class="para">
						<a id="IG31340177302" class="indexterm"></a> <a id="IG31340177303" class="indexterm"></a>For each leaf node (actual performance metrics) found in the traversal, the user-supplied function <code class="command">dometric</code> is called with the full pathname of that metric in the PMNS as the single argument; this argument is a null byte-terminated string, and is constructed from a buffer that is managed internally to <code class="command">pmTraversePMNS</code>. Consequently, the value is valid only during the call to <code class="command">dometric</code>--if the pathname needs to be retained, it should be copied using <code class="command">strdup</code> before returning from <code class="command">dometric</code>; see the <code class="command">strdup(3)</code> man page.
					</div><div class="para">
						The python bindings perform a depth first traversal of the PMNS by scanning <em class="replaceable">namespace</em>, depth first, and call a python function <em class="replaceable">traverse_callback</em> for each node.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5200806">
      ⁠</a>3.8.1.9.  <code class="command">pmUnloadNameSpace</code> Function</h4></div></div></div><pre class="literallayout">int pmUnloadNameSpace(void)
<code class="command">Python:</code>
pmUnLoadNameSpace(<em class="replaceable">"NameSpace"</em>)</pre><div class="para">
						<a id="IG31340177304" class="indexterm"></a>If a local PMNS was loaded with <code class="command">pmLoadNameSpace</code>, calling <code class="command">pmUnloadNameSpace</code> frees up the memory associated with the PMNS and force all subsequent Name Space functions to use the distributed PMNS. If <code class="command">pmUnloadNameSpace</code> is called before calling <code class="command">pmLoadNameSpace</code>, it has no effect.
					</div><div class="para">
						As discussed in <a class="xref" href="#id5200074">Section 3.8.1.4, “ <code class="command">pmLoadNameSpace</code> Function”</a> there are few if any situations where clients need to call this routine in modern versions of PCP.
					</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE89521-PARENT">
      ⁠</a>3.8.2. PMAPI Metrics Description Services</h3></div></div></div><div class="para">
					The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) metric description services.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5200868">
      ⁠</a>3.8.2.1.  <code class="command">pmLookupDesc</code> Function</h4></div></div></div><pre class="literallayout">int pmLookupDesc(pmID <em class="replaceable">pmid</em>, pmDesc *<em class="replaceable">desc</em>)
<code class="command">Python:</code>
pmDesc* <em class="replaceable">pmdesc</em> = pmLookupDesc(c_uint <em class="replaceable">pmid</em>)
(pmDesc* <em class="replaceable">pmdesc</em>)[] = pmLookupDescs(c_uint <em class="replaceable">pmids</em>[N])
(pmDesc* <em class="replaceable">pmdesc</em>)[] = pmLookupDescs(c_uint <em class="replaceable">pmid</em>)</pre><div class="para">
						<a id="IG31340177305" class="indexterm"></a> <a id="IG31340177306" class="indexterm"></a> <a id="IG31340177307" class="indexterm"></a> <a id="IG31340177308" class="indexterm"></a>Given a Performance Metric Identifier (PMID) as <em class="replaceable">pmid</em>, <code class="command">pmLookupDesc</code> returns the associated <code class="literal">pmDesc</code> structure through the parameter <em class="replaceable">desc</em> from the current PMAPI context. For more information about <code class="literal">pmDesc</code>, see <a class="xref" href="#LE11914-PARENT">Section 3.4, “Performance Metric Descriptions”</a>.
					</div><div class="para">
						The python bindings return the metric description structure <code class="literal">pmDesc</code> corresponding to <em class="replaceable">pmid</em>. The returned <em class="replaceable">pmdesc</em> is passed to <code class="command">pmExtractValue</code> and <code class="command">pmLookupInDom</code>. The python bindings provide an entry <code class="command">pmLookupDescs</code> that is similar to pmLookupDesc but does a metric description lookup for each element in a PMID array <em class="replaceable">pmids</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5200999">
      ⁠</a>3.8.2.2.  <code class="command">pmLookupInDomText</code> Function</h4></div></div></div><pre class="programlisting">int pmLookupInDomText(pmInDom <em class="replaceable">indom</em>, int <em class="replaceable">level</em>, char **<em class="replaceable">buffer</em>)
<code class="command">Python:</code>
"metric description" = pmGetInDomText(pmDesc <em class="replaceable">pmdesc</em>)</pre><div class="para">
						<a id="IG31340177309" class="indexterm"></a> <a id="IG31340177310" class="indexterm"></a>Provided the source of metrics from the current PMAPI context is a host, retrieve descriptive text about the performance metrics instance domain identified by <em class="replaceable">indom</em>.
					</div><div class="para">
						<a id="IG31340177311" class="indexterm"></a>The <em class="replaceable">level</em> argument should be <code class="literal">PM_TEXT_ONELINE</code> for a one-line summary, or <code class="literal">PM_TEXT_HELP</code> for a more verbose description suited to a help dialogue. The space pointed to by <em class="replaceable">buffer</em> is allocated in <code class="command">pmLookupInDomText</code> with <code class="command">malloc</code>, and it is the responsibility of the caller to free unneeded space; see the <code class="command">malloc(3)</code> and<code class="command"> free(3)</code> man pages.
					</div><div class="para">
						The help text files used to implement <code class="filename">pmLookupInDomText</code> are often created using <code class="command">newhelp</code> and accessed by the appropriate PMDA response to requests forwarded to the PMDA by PMCD. Further details may be found in <a class="xref" href="#LE72473-PARENT">Section 2.4.4, “PMDA Help Text”</a>.
					</div><div class="para">
						The python bindings lookup the description text about the performance metrics pmDesc <em class="replaceable">pmdesc</em>. The default is a one line summary; for a more verbose description add an optional second parameter <em class="replaceable">cpmapi.PM_TEXT_HELP</em>. The constant is available by importing cpmapi.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5201140">
      ⁠</a>3.8.2.3.  <code class="command">pmLookupText</code> Function</h4></div></div></div><pre class="programlisting">int pmLookupText(pmID <em class="replaceable">pmid</em>, int <em class="replaceable">level</em>, char **<em class="replaceable">buffer</em>)
<code class="command">Python:</code>
"metric description" = pmLookupText(c_uint <em class="replaceable">pmid</em>)</pre><div class="para">
						<a id="IG31340177312" class="indexterm"></a> <a id="IG31340177313" class="indexterm"></a>Provided the source of metrics from the current PMAPI context is a host, retrieve descriptive text about the performance metric identified by <em class="replaceable">pmid</em>. The argument <em class="replaceable">level</em> should be <code class="literal">PM_TEXT_ONELINE</code> for a one-line summary, or <code class="literal">PM_TEXT_HELP</code> for a more verbose description, suited to a help dialogue.
					</div><div class="para">
						The space pointed to by <em class="replaceable">buffer</em> is allocated in <code class="command">pmLookupText</code> with <code class="command">malloc</code>, and it is the responsibility of the caller to <code class="command">free</code> the space when it is no longer required; see the <code class="command">malloc(3)</code> and <code class="command">free(3)</code> man pages.
					</div><div class="para">
						The help text files used to implement <code class="command">pmLookupText</code> are created using <code class="command">newhelp</code> and accessed by the appropriate PMDA in response to requests forwarded to the PMDA by PMCD. Further details may be found in <a class="xref" href="#LE72473-PARENT">Section 2.4.4, “PMDA Help Text”</a>.
					</div><div class="para">
						The python bindings lookup the description text about the performance metrics pmID <em class="replaceable">pmid</em>. The default is a one line summary; for a more verbose description add an optional second parameter <em class="replaceable">cpmapi.PM_TEXT_HELP</em>. The constant is available by importing cpmapi.
					</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE27200-PARENT">
      ⁠</a>3.8.3. PMAPI Instance Domain Services</h3></div></div></div><div class="para">
					The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) instance domain services.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5201278">
      ⁠</a>3.8.3.1.  <code class="command">pmGetInDom</code> Function</h4></div></div></div><pre class="literallayout">int pmGetInDom(pmInDom <em class="replaceable">indom</em>, int **<em class="replaceable">instlist</em>, char ***<em class="replaceable">namelist</em>)
<code class="command">Python:</code>
([instance1, instance2...] [name1, name2...]) pmGetInDom(pmDesc <em class="replaceable">pmdesc</em>)</pre><div class="para">
						<a id="IG31340177314" class="indexterm"></a> <a id="IG31340177315" class="indexterm"></a> <a id="IG31340177316" class="indexterm"></a> <a id="IG31340177317" class="indexterm"></a>In the current PMAPI context, locate the description of the instance domain <em class="replaceable">indom</em>, and return through <em class="replaceable">instlist</em> the internal instance identifiers for all instances, and through <em class="replaceable">namelist</em> the full external identifiers for all instances. The number of instances found is returned as the function value (or less than zero to indicate an error).
					</div><div class="para">
						The resulting lists of instance identifiers (<em class="replaceable">instlist</em> and <em class="replaceable">namelist</em>), and the names that the elements of <em class="replaceable">namelist</em> point to, are allocated by <code class="command">pmGetInDom</code> with two calls to <code class="command">malloc</code>, and it is the responsibility of the caller to use <code class="command">free</code><em class="replaceable">(instlist)</em> and <code class="command">free</code><em class="replaceable">(namelist) </em>to release the space when it is no longer required. When the result of <code class="command">pmGetInDom</code> is less than one, both <em class="replaceable">instlist</em> and <em class="replaceable">namelist</em> are undefined (no space is allocated, and so calling <code class="command">free</code> is a bad idea); see the <code class="command"> malloc(3)</code> and <code class="command">free(3)</code> man pages.
					</div><div class="para">
						The python bindings return a tuple of the instance identifiers and instance names for an instance domain <em class="replaceable">pmdesc</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5201511">
      ⁠</a>3.8.3.2.  <code class="command">pmLookupInDom</code> Function</h4></div></div></div><pre class="programlisting">int pmLookupInDom(pmInDom <em class="replaceable">indom</em>, const char *<em class="replaceable">name</em>)
<code class="command">Python:</code>
int <em class="replaceable">instid</em> = pmLookupInDom(pmDesc <em class="replaceable">pmdesc</em>, <em class="replaceable">"Instance"</em>)</pre><div class="para">
						<a id="IG31340177318" class="indexterm"></a>For the instance domain <em class="replaceable">indom</em>, in the current PMAPI context, locate the instance with the external identification given by <em class="replaceable">name</em>, and return the internal instance identifier.
					</div><div class="para">
						The python bindings return the instance id corresponding to <em class="replaceable">"Instance"</em> in the instance domain <em class="replaceable">pmdesc</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5201553">
      ⁠</a>3.8.3.3.  <code class="command">pmNameInDom</code> Function</h4></div></div></div><pre class="programlisting">int pmNameInDom(pmInDom <em class="replaceable">indom</em>, int <em class="replaceable">inst</em>, char **<em class="replaceable">name</em>)
<code class="command">Python:</code>
"instance id" = pmNameInDom(pmDesc <em class="replaceable">pmdesc</em>, c_uint <em class="replaceable">instid</em>)</pre><div class="para">
						<a id="IG31340177319" class="indexterm"></a>For the instance domain <em class="replaceable">indom</em>, in the current PMAPI context, locate the instance with the internal instance identifier given by <em class="replaceable">inst</em>, and return the full external identification through <em class="replaceable">name</em>. The space for the value of <em class="replaceable">name</em> is allocated in <code class="command">pmNameInDom</code> with <code class="command">malloc</code>, and it is the responsibility of the caller to free the space when it is no longer required; see the <code class="command">malloc(3)</code> and <code class="command">free(3)</code> man pages.
					</div><div class="para">
						The python bindings return the text name of an instance corresponding to an instance domain <em class="replaceable">pmdesc</em> with instance identifier <em class="replaceable">instid</em>.
					</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE94187-PARENT">
      ⁠</a>3.8.4. PMAPI Context Services</h3></div></div></div><div class="para">
					<a id="IG31340177320" class="indexterm"></a> <a id="IG31340177321" class="indexterm"></a> <a class="xref" href="#id5201726">Table 3.1, “Context Components of PMAPI Functions ”</a> shows which of the three components of a PMAPI context (metrics source, instance profile, and collection time) are relevant for various PMAPI functions. Those PMAPI functions not shown in this table either manipulate the PMAPI context directly, or are executed independently of the current PMAPI context.
				</div><div class="table"><a id="id5201726">
      ⁠</a><p class="title"><strong>Table 3.1. Context Components of PMAPI Functions </strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="gt-4-cols gt-14-rows" summary="Context Components of PMAPI Functions "><colgroup><col width="33%" /><col width="19%" /><col width="19%" /><col width="19%" /><col width="9%" /></colgroup><thead><tr valign="top"><th align="left" valign="bottom"> <div class="para">
									Function Name
								</div>
								 </th><th align="left" valign="bottom"> <div class="para">
									Metrics Source
								</div>
								 </th><th align="left" valign="bottom"> <div class="para">
									Instance Profile
								</div>
								 </th><th align="left" valign="bottom"> <div class="para">
									Collection Time
								</div>
								 </th><th align="left" valign="bottom"> <div class="para">
									Notes
								</div>
								 </th></tr></thead><tbody><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmAddProfile</code> <a id="IG31340177322" class="indexterm"></a>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmDelProfile<a id="IG31340177323" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmDupContext<a id="IG31340177324" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmFetch<a id="IG31340177325" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmFetchArchive<a id="IG31340177326" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									(1)
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmGetArchiveEnd<a id="IG31340177327" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									(1)
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmGetArchiveLabel<a id="IG31340177328" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									(1)
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmGetChildren<a id="IG31340177329" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmGetChildrenStatus<a id="IG31340177330" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmGetContextHostName<a id="IG31340177330nat" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmGetPMNSLocation<a id="IG31340177331" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmGetInDom<a id="IG31340177332" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									(2)
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmGetInDomArchive<a id="IG31340177333" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									(1)
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmLookupDesc<a id="IG31340177334" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									(3)
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmLookupInDom<a id="IG31340177335" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									(2)
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmLookupInDomArchive<a id="IG31340177336" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									(1,2)
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmLookupInDomText<a id="IG31340177337" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									(4)
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmLookupName<a id="IG31340177338" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmLookupText<a id="IG31340177339" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									(4)
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmNameAll</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmNameID<a id="IG31340177340" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmNameInDom<a id="IG31340177341" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									(2)
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmNameInDomArchive<a id="IG31340177342" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									(1,2)
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmSetMode<a id="IG31340177343" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmStore<a id="IG31340177344" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									(5)
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmTraversePMNS<a id="IG31340177345" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Yes
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									 
								</div>
								 </td></tr></tbody></table></div></div><div class="para">
					Notes:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="orderedlist"><ol><li class="listitem"><div class="para">
							Operation supported only for PMAPI contexts where the source of metrics is an archive.
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177346" class="indexterm"></a>A specific instance domain is included in the arguments to these functions, and the result is independent of the instance profile for any PMAPI context.
						</div></li><li class="listitem"><div class="para">
							The metadata that describes a performance metric is sensitive to the source of the metrics, but independent of any instance profile and of the collection time.
						</div></li><li class="listitem"><div class="para">
							<a id="IG31340177347" class="indexterm"></a>Operation is supported only for PMAPI contexts where the source of metrics is a host. The text associated with a metric is assumed to be invariant with time and is definitely insensitive to the current members of the instance domain. In all cases this information is unavailable from an archive context (it is not included in the archive logs), and is directly available from a PMDA via PMCD in the other cases.
						</div></li><li class="listitem"><div class="para">
							This operation is supported only for contexts where the source of the metrics is a host. Further, the instance identifiers are included in the argument to the function, and the effects upon the current values of the metrics are immediate (retrospective changes are not allowed). Consequently, from the current PMAPI context, neither the instance profile nor the collection time influence the result of this function.
						</div></li></ol></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5203779">
      ⁠</a>3.8.4.1.  <code class="command">pmNewContext</code> Function</h4></div></div></div><pre class="programlisting">int pmNewContext(int <em class="replaceable">type</em>, const char *<em class="replaceable">name</em>)</pre><div class="para">
						<a id="IG31340177348" class="indexterm"></a> <a id="IG31340177349" class="indexterm"></a> <a id="IG31340177350" class="indexterm"></a>The <code class="command">pmNewContext</code> function may be used to establish a new PMAPI context. The source of metrics is identified by <em class="replaceable">name</em>, and may be a host specification (<em class="replaceable">type</em> is <code class="literal">PM_CONTEXT_HOST</code>) or a comma-separated list of names referring to a set of archive logs (<em class="replaceable">type</em> is <code class="literal">PM_CONTEXT_ARCHIVE</code>). Each element of the list may either be the base name common to all of the physical files of an archive log or the name of a directory containing archive logs.
					</div><div class="para">
						A host specification usually contains a simple hostname, an internet address (IPv4 or IPv6), or the path to the PMCD Unix domain socket. It can also specify properties of the connection to PMCD, such as the protocol to use (secure and encrypted, or native) and whether PMCD should be reached via a <code class="command">pmproxy</code> host. Various other connection attributes, such as authentication information (user name, password, authentication method, and so on) can also be specified. Further details can be found in the <code class="command">PCPIntro(3)</code> man page, and the companion <em class="citetitle">Performance Co-Pilot Tutorials and Case Studies</em> document.
					</div><div class="para">
						In the case where <em class="replaceable">type</em> is <code class="literal">PM_CONTEXT_ARCHIVE</code>, there are some restrictions on the archives within the specified set:
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
								The archives must all have been generated on the same host.
							</div></li><li class="listitem"><div class="para">
								The archives must not overlap in time.
							</div></li><li class="listitem"><div class="para">
								The archives must all have been created using the same time zone.
							</div></li><li class="listitem"><div class="para">
								The pmID of each metric should be the same in all of the archives. Multiple pmIDs are currently tolerated by using the first pmID defined for each metric and ignoring subsequent pmIDs.
							</div></li><li class="listitem"><div class="para">
								The type of each metric must be the same in all of the archives.
							</div></li><li class="listitem"><div class="para">
								The semantics of each metric must be the same in all of the archives.
							</div></li><li class="listitem"><div class="para">
								The units of each metric must be the same in all of the archives.
							</div></li><li class="listitem"><div class="para">
								The instance domain of each metric must be the same in all of the archives.
							</div></li></ul></div><div class="para">
						In the case where <em class="replaceable">type</em> is <code class="literal">PM_CONTEXT_LOCAL</code>, <em class="replaceable">name</em> is ignored, and the context uses a stand-alone connection to the PMDA methods used by PMCD. When this type of context is in effect, the range of accessible performance metrics is constrained to DSO PMDAs listed in the <code class="command">pmcd</code> configuration file <code class="filename">${PCP_PMCDCONF_PATH}</code>. The reason this is done, as opposed to all of the DSO PMDAs found below <code class="filename">${PCP_PMDAS_DIR}</code> for example, is that DSO PMDAs listed there are very likely to have their metric names reflected in the local Name Space file, which will be loaded for this class of context.
					</div><div class="para">
						<a id="IG31340177351" class="indexterm"></a> <a id="IG31340177352" class="indexterm"></a>The initial instance profile is set up to select all instances in all instance domains, and the initial collection time is the current time at the time of each request for a host, or the time at the start of the first log for a set of archives. In the case of archives, the initial collection time results in the earliest set of metrics being returned from the set of archives at the first <code class="command">pmFetch</code>.
					</div><div class="para">
						Once established, the association between a PMAPI context and a source of metrics is fixed for the life of the context; however, functions are provided to independently manipulate both the instance profile and the collection time components of a context.
					</div><div class="para">
						<a id="IG31340177353" class="indexterm"></a>The function returns a “handle” that may be used in subsequent calls to <code class="command">pmUseContext</code>. This new PMAPI context stays in effect for all subsequent context sensitive calls across the PMAPI until another call to <code class="command">pmNewContext</code> is made, or the context is explicitly changed with a call to <code class="command">pmDupContext</code> or <code class="command">pmUseContext</code>.
					</div><div class="para">
						For the python bindings creating and destroying a PMAPI context is done by creating and destroying an object of the pmapi class.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5203964">
      ⁠</a>3.8.4.2.  <code class="command">pmDestroyContext</code> Function</h4></div></div></div><pre class="programlisting">int pmDestroyContext(int <em class="replaceable">handle</em>)</pre><div class="para">
						<a id="IG31340177354" class="indexterm"></a>The PMAPI context identified by <em class="replaceable">handle</em> is destroyed. Typically, this implies terminating a connection to PMCD or closing an archive file, and orderly clean-up. The PMAPI context must have been previously created using <code class="command">pmNewContext</code> or <code class="command">pmDupContext</code>.
					</div><div class="para">
						On success, <code class="command">pmDestroyContext</code> returns zero. If <em class="replaceable">handle</em> was the current PMAPI context, then the current context becomes undefined. This means the application must explicitly re-establish a valid PMAPI context with <code class="command">pmUseContext</code>, or create a new context with <code class="command">pmNewContext</code> or <code class="command">pmDupContext</code>, before the next PMAPI operation requiring a PMAPI context.
					</div><div class="para">
						For the python bindings creating and destroying a PMAPI context is done by creating and destroying an object of the pmapi class.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5204063">
      ⁠</a>3.8.4.3.  <code class="command">pmDupContext</code> Function</h4></div></div></div><pre class="programlisting">int pmDupContext(void)</pre><pre class="programlisting"></pre><div class="para">
						<a id="IG31340177355" class="indexterm"></a>Replicate the current PMAPI context (source, instance profile, and collection time). This function returns a handle for the new context, which may be used with subsequent calls to <code class="command">pmUseContext</code>. The newly replicated PMAPI context becomes the current context.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5204116">
      ⁠</a>3.8.4.4.  <code class="command">pmUseContext</code> Function</h4></div></div></div><pre class="programlisting">int pmUseContext(int <em class="replaceable">handle</em>)</pre><div class="para">
						<a id="IG31340177356" class="indexterm"></a>Calling <code class="command">pmUseContext</code> causes the current PMAPI context to be set to the context identified by <em class="replaceable">handle</em>. The value of <em class="replaceable">handle</em> must be one returned from an earlier call to <code class="command">pmNewContext</code> or <code class="command">pmDupContext</code>.
					</div><div class="para">
						Below the PMAPI, all contexts used by an application are saved in their most recently modified state, so <code class="command">pmUseContext</code> restores the context to the state it was in the last time the context was used, not the state of the context when it was established.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5204177">
      ⁠</a>3.8.4.5.  <code class="command">pmWhichContext</code> Function</h4></div></div></div><pre class="programlisting">int pmWhichContext(void)
<code class="command">Python:</code>
int <em class="replaceable">ctx</em>_idx = pmWhichContext()</pre><div class="para">
						<a id="IG31340177357" class="indexterm"></a> <a id="IG31340177358" class="indexterm"></a>Returns the handle for the current PMAPI context (source, instance profile, and collection time).
					</div><div class="para">
						The python bindings return the handle of the current PMAPI context.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5204210">
      ⁠</a>3.8.4.6.  <code class="command">pmAddProfile</code> Function</h4></div></div></div><pre class="programlisting">int pmAddProfile(pmInDom <em class="replaceable">indom</em>, int <em class="replaceable">numinst</em>, int <em class="replaceable">instlist</em>[])
<code class="command">Python:</code>
int <em class="replaceable">status</em> = pmAddProfile(pmDesc pmdesc, [c_uint instid])</pre><div class="para">
						<a id="IG31340177359" class="indexterm"></a> <a id="IG31340177360" class="indexterm"></a> <a id="IG31340177361" class="indexterm"></a>Add new instance specifications to the instance profile of the current PMAPI context. At its simplest, instances identified by the <em class="replaceable">instlist</em> argument for the <em class="replaceable">indom</em> instance domain are added to the instance profile. The list of instance identifiers contains <em class="replaceable">numinst</em> values.
					</div><div class="para">
						<a id="IG31340177362" class="indexterm"></a>If <em class="replaceable">indom</em> equals <code class="literal">PM_INDOM_NULL</code>, or <em class="replaceable">numinst</em> is zero, then all instance domains are selected. If <em class="replaceable">instlist</em> is NULL, then all instances are selected. To enable all available instances in all domains, use this syntax:
					</div><pre class="programlisting">pmAddProfile(PM_INDOM_NULL, 0, NULL).</pre><div class="para">
						The python bindings add the list of instances <em class="replaceable">instid</em> to the instance profile of the instance <em class="replaceable">pmdesc</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5204360">
      ⁠</a>3.8.4.7.  <code class="command">pmDelProfile</code> Function</h4></div></div></div><pre class="programlisting">int pmDelProfile(pmInDom <em class="replaceable">indom</em>, int <em class="replaceable">numinst</em>, int <em class="replaceable">instlist</em>[])
<code class="command">Python:</code>
int <em class="replaceable">status</em> = pmDelProfile(pmDesc pmdesc, c_uint instid)
int <em class="replaceable">status</em> = pmDelProfile(pmDesc pmdesc, [c_uint instid])
</pre><div class="para">
						<a id="IG31340177363" class="indexterm"></a> <a id="IG31340177364" class="indexterm"></a>Delete instance specifications from the instance profile of the current PMAPI context. In the simplest variant, the list of instances identified by the <em class="replaceable">instlist</em> argument for the <em class="replaceable">indom</em> instance domain is removed from the instance profile. The list of instance identifiers contains <em class="replaceable">numinst</em> values.
					</div><div class="para">
						If <em class="replaceable">indom</em> equals <code class="literal">PM_INDOM_NULL</code>, then all instance domains are selected for deletion. If <em class="replaceable">instlist</em> is NULL, then all instances in the selected domains are removed from the profile. To disable all available instances in all domains, use this syntax:
					</div><pre class="programlisting">pmDelProfile(PM_INDOM_NULL, 0, NULL)</pre><div class="para">
						The python bindings delete the list of instances <em class="replaceable">instid</em> from the instance profile of the instance domain <em class="replaceable">pmdesc</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5204444">
      ⁠</a>3.8.4.8.  <code class="command">pmSetMode</code> Function</h4></div></div></div><pre class="programlisting">int pmSetMode(int <em class="replaceable">mode</em>, const struct timeval *<em class="replaceable">when</em>, int <em class="replaceable">delta</em>)
<code class="command">Python:</code>
int <em class="replaceable">status</em> = pmSetMode(mode, timeVal <em class="replaceable">timeval</em>, int <em class="replaceable">delta</em>)</pre><div class="para">
						<a id="IG31340177365" class="indexterm"></a> <a id="IG31340177366" class="indexterm"></a> <a id="IG31340177367" class="indexterm"></a> <a id="IG31340177368" class="indexterm"></a> <a id="IG31340177369" class="indexterm"></a> <a id="IG31340177370" class="indexterm"></a> <a id="IG31340177371" class="indexterm"></a>This function defines the collection time and mode for accessing performance metrics and metadata in the current PMAPI context. This mode affects the semantics of subsequent calls to the following PMAPI functions: <code class="command">pmFetch</code>, <code class="command">pmFetchArchive</code>, <code class="command">pmLookupDesc</code>, <code class="command">pmGetInDom</code>, <code class="command">pmLookupInDom </code>, and <code class="command">pmNameInDom</code>.
					</div><div class="para">
						The <code class="command">pmSetMode</code> function requires the current PMAPI context to be of type <code class="literal">PM_CONTEXT_ARCHIVE</code>.
					</div><div class="para">
						The <em class="replaceable">when</em> parameter defines a time origin, and all requests for metadata (metrics descriptions and instance identifiers from the instance domains) are processed to reflect the state of the metadata as of the time origin. For example, use the last state of this information at, or before, the time origin.
					</div><div class="para">
						If the <em class="replaceable">mode</em> is <code class="literal">PM_MODE_INTERP</code> then, in the case of <code class="command">pmFetch</code>, the underlying code uses an interpolation scheme to compute the values of the metrics from the values recorded for times in the proximity of the time origin.
					</div><div class="para">
						If the <em class="replaceable">mode</em> is <code class="literal">PM_MODE_FORW</code>, then, in the case of <code class="command">pmFetch</code>, the collection of recorded metric values is scanned forward, until values for at least one of the requested metrics is located after the time origin. Then all requested metrics stored in the PCP archive at that time are returned with a corresponding time stamp. This is the default mode when an archive context is first established with <code class="command">pmNewContext</code>.
					</div><div class="para">
						If the <em class="replaceable">mode</em> is <code class="literal">PM_MODE_BACK</code>, then the situation is the same as for <code class="literal">PM_MODE_FORW</code>, except a <code class="command">pmFetch</code> is serviced by scanning the collection of recorded metrics backward for metrics before the time origin.
					</div><div class="para">
						After each successful <code class="command">pmFetch</code>, the time origin is reset to the time stamp returned through the <code class="filename">pmResult</code>.
					</div><div class="para">
						The <code class="command">pmSetMode</code> parameter <em class="replaceable">delta</em> defines an additional number of time unit that should be used to adjust the time origin (forward or backward) after the new time origin from the <code class="filename">pmResult</code> has been determined. This is useful when moving through archives with a mode of <code class="literal">PM_MODE_INTERP</code>. The high-order bits of the <em class="replaceable">mode</em> parameter field is also used to optionally set the units of time for the <code class="filename">delta</code> field. To specify the units of time, use the <code class="literal">PM_XTB_SET</code> macro with one of the values <code class="literal">PM_TIME_NSEC</code>, <code class="literal">PM_TIME_MSEC</code>, <code class="literal">PM_TIME_SEC</code>, or so on as follows:
					</div><pre class="literallayout">PM_MODE_INTERP | PM_XTB_SET(PM_TIME_<em class="replaceable">XXXX)</em></pre><div class="para">
						If no units are specified, the default is to interpret <em class="replaceable">delta</em> as milliseconds.
					</div><div class="para">
						Using these mode options, an application can implement replay, playback, fast forward, or reverse for performance metric values held in a set of PCP archive logs by alternating calls to <code class="command">pmSetMode</code> and <code class="command">pmFetch</code>.
					</div><div class="para">
						In <a class="xref" href="#Z976827209sdc">Example 3.11, “Dumping Values in Temporal Sequence”</a>, the code fragment may be used to dump only those values stored in correct temporal sequence, for the specified performance metric <code class="filename">my.metric.name</code>:
					</div><div class="example"><a id="Z976827209sdc">
      ⁠</a><p class="title"><strong>Example 3.11. Dumping Values in Temporal Sequence</strong></p><div class="example-contents"><pre class="programlisting">    int     sts;
    pmID    pmid;
    char    *name = “my.metric.name”;

    sts = pmNewContext(PM_CONTEXT_ARCHIVE, “myarchive”);
    sts = pmLookupName(1, &amp;name, &amp;pmid);
    for ( ; ; ) {
        sts = pmFetch(1, &amp;pmid, &amp;result);
        if (sts &lt; 0)
            break;
        /* dump value(s) from result-&gt;vset[0]-&gt;vlist[] */
        pmFreeResult(result);
   }</pre></div></div><div class="para">
						<a id="IG31340177372" class="indexterm"></a>Alternatively, the code fragment in <a class="xref" href="#Z976827219sdc">Example 3.12, “Replaying Interpolated Metrics”</a> may be used to replay interpolated metrics from an archive in reverse chronological order, at ten-second intervals (of recorded time):
					</div><div class="example"><a id="Z976827219sdc">
      ⁠</a><p class="title"><strong>Example 3.12. Replaying Interpolated Metrics</strong></p><div class="example-contents"><pre class="programlisting">    int             sts;
    pmID            pmid;
    char            *name = “my.metric.name”;
    struct timeval  endtime;

    sts = pmNewContext(PM_CONTEXT_ARCHIVE, “myarchive”);
    sts = pmLookupName(1, &amp;name, &amp;pmid);
    sts = pmGetArchiveEnd(&amp;endtime);
    sts = pmSetMode(PM_MODE_INTERP, &amp;endtime, -10000);
    while (pmFetch(1, &amp;pmid, &amp;result) != PM_ERR_EOL) {
        /*
         * process interpolated metric values as of result-&gt;timestamp
         */
        pmFreeResult(result);
   }</pre></div></div><div class="para">
						The python bindings define the collection <em class="replaceable">time</em> and <em class="replaceable">mode</em> for reading archive files. <em class="replaceable">mode</em> can be one of: c_api.PM_MODE_LIVE, c_api.PM_MODE_INTERP, c_api.FORW, c_api.BACK. wjocj are available by importing cpmapi.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5204926">
      ⁠</a>3.8.4.9.  <code class="command">pmReconnectContext</code> Function</h4></div></div></div><pre class="programlisting">int pmReconnectContext(int <em class="replaceable">handle</em>)
<code class="command">Python:</code>
int <em class="replaceable">status</em> = pmReconnectContext()
</pre><div class="para">
						<a id="IG31340177373" class="indexterm"></a> <a id="IG31340177374" class="indexterm"></a>As a result of network, host, or PMCD (Performance Metrics Collection Daemon) failure, an application's connection to PMCD may be established and then lost.
					</div><div class="para">
						<a id="IG31340177375" class="indexterm"></a>The function <code class="command">pmReconnectContext</code> allows an application to request that the PMAPI context identified by <em class="replaceable">handle</em> be re-established, provided the associated PMCD is accessible.
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							<em class="replaceable">handle</em> may or may not be the current context.
						</div></div></div><div class="para">
						<a id="IG31340177376" class="indexterm"></a>To avoid flooding the system with reconnect requests, <code class="command">pmReconnectContext</code> attempts a reconnection only after a suitable delay from the previous attempt. This imposed restriction on the reconnect re-try time interval uses a default exponential back-off so that the initial delay is 5 seconds after the first unsuccessful attempt, then 10 seconds, then 20 seconds, then 40 seconds, and then 80 seconds thereafter. The intervals between reconnection attempts may be modified using the environment variable <code class="literal">PMCD_RECONNECT_TIMEOUT</code> and the time to wait before an attempted connection is deemed to have failed is controlled by the <code class="literal">PMCD_CONNECT_TIMEOUT</code> environment variable; see the <code class="command">PCPIntro(1)</code> man page.
					</div><div class="para">
						If the reconnection succeeds, <code class="command">pmReconnectContext</code> returns <em class="replaceable">handle</em>. Note that even in the case of a successful reconnection, <code class="command">pmReconnectContext</code> does not change the current PMAPI context.
					</div><div class="para">
						The python bindings reestablish the connection for the context.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5205074">
      ⁠</a>3.8.4.10.  <code class="command">pmGetContextHostName</code> Function</h4></div></div></div><pre class="programlisting">const char *pmGetContextHostName(int <em class="replaceable">id</em>)
char *pmGetContextHostName_r(int <em class="replaceable">id</em>, char *<em class="replaceable">buf</em>, int <em class="replaceable">buflen</em>)
<code class="command">Python:</code>
"hostname" = pmGetContextHostName()
</pre><div class="para">
						Given a valid PCP context identifier previously created with <code class="command">pmNewContext</code> or <code class="command">pmDupContext</code>, the <code class="command">pmGetContextHostName</code> function provides a possibility to retrieve a host name associated with a context regardless of the context type.
					</div><div class="para">
						This function will use the <code class="literal">pmcd.hostname</code> metric if it is available, and so is able to provide an accurate hostname in the presence of connection tunnelling and port forwarding.
					</div><div class="para">
						If <em class="replaceable">id</em> is not a valid PCP context identifier, this function returns a zero length string and therefore never fails.
					</div><div class="para">
						In the case of <code class="command">pmGetContextHostName</code>, the string value is held in a single static buffer, so concurrent calls may not produce the desired results. The <code class="command">pmGetContextHostName_r</code> function allows a buffer and length to be passed in, into which the message is stored; this variant uses no shared storage and can be used in a thread-safe manner.
					</div><div class="para">
						The python bindings query the current context hostname.
					</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE34685-PARENT">
      ⁠</a>3.8.5. PMAPI Timezone Services</h3></div></div></div><div class="para">
					The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) timezone services.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5205140">
      ⁠</a>3.8.5.1.  <code class="command">pmNewContextZone</code> Function</h4></div></div></div><pre class="literallayout">int pmNewContextZone(void)
<code class="command">Python:</code>
pmNewContextZone()
</pre><div class="para">
						<a id="IG31340177377" class="indexterm"></a> <a id="IG31340177378" class="indexterm"></a> <a id="IG31340177379" class="indexterm"></a>If the current PMAPI context is an archive, the <code class="command">pmNewContextZone</code> function uses the timezone from the archive label record in the first archive of the set to set the current reporting timezone. The current reporting timezone affects the timezone used by <code class="command">pmCtime</code> and <code class="command">pmLocaltime</code>.
					</div><div class="para">
						If the current PMAPI context corresponds to a host source of metrics, <code class="command">pmNewContextZone</code> executes a <code class="command">pmFetch</code> to retrieve the value for the metric <code class="literal">pmcd.timezone</code> and uses that to set the current reporting timezone.
					</div><div class="para">
						In both cases, the function returns a value to identify the current reporting timezone that may be used in a subsequent call to <code class="command">pmUseZone</code> to restore this reporting timezone.
					</div><div class="para">
						<code class="literal">PM_ERR_NOCONTEXT</code> indicates the current PMAPI context is not valid. A return value less than zero indicates a fatal error from a system call, most likely <code class="command">malloc</code>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5205286">
      ⁠</a>3.8.5.2.  <code class="command">pmNewZone</code> Function</h4></div></div></div><pre class="literallayout">int pmNewZone(const char *<em class="replaceable">tz</em>)
<code class="command">Python:</code>
int <em class="replaceable">tz_handle</em> = pmNewZone(int <em class="replaceable">tz</em>)</pre><div class="para">
						<a id="IG31340177380" class="indexterm"></a>The <code class="command">pmNewZone</code> function sets the current reporting timezone, and returns a value that may be used in a subsequent call to <code class="command">pmUseZone</code> to restore this reporting timezone. The current reporting timezone affects the timezone used by <code class="command">pmCtime</code> and <code class="command">pmLocaltime</code>.
					</div><div class="para">
						The <em class="replaceable">tz</em> argument defines a timezone string, in the format described for the <code class="literal">TZ</code> environment variable. See the <code class="command">environ(7)</code> man page.
					</div><div class="para">
						A return value less than zero indicates a fatal error from a system call, most likely <code class="command">malloc</code>.
					</div><div class="para">
						The python bindings create a new zone handle and set reporting timezone for the timezone defined by <em class="replaceable">tz</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5205362">
      ⁠</a>3.8.5.3.  <code class="command">pmUseZone</code> Function</h4></div></div></div><pre class="literallayout">int pmUseZone(const int <em class="replaceable">tz_handle</em>)
<code class="command">Python:</code>
int <em class="replaceable">status</em> = pmUseZone(int <em class="replaceable">tz_handle</em>)
</pre><div class="para">
						<a id="IG31340177381" class="indexterm"></a>In the <code class="command">pmUseZone</code> function, <em class="replaceable">tz_handle</em> identifies a reporting timezone as previously established by a call to <code class="command">pmNewZone</code> or <code class="command">pmNewContextZone</code>, and this becomes the current reporting timezone. The current reporting timezone effects the timezone used by <code class="command">pmCtime</code> and <code class="command">pmLocaltime</code>).
					</div><div class="para">
						A return value less than zero indicates the value of <em class="replaceable">tz_handle</em> is not legal.
					</div><div class="para">
						The python bindings set the current reporting timezone defined by timezone <em class="replaceable">tz_handle</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5205444">
      ⁠</a>3.8.5.4.  <code class="command">pmWhichZone</code> Function</h4></div></div></div><pre class="literallayout">int pmWhichZone(char **<em class="replaceable">tz</em>)
<code class="command">Python:</code>
"zone string" = pmWhichZone()</pre><div class="para">
						<a id="IG31340177382" class="indexterm"></a>The <code class="command">pmWhichZone</code> function returns the handle of the current timezone, as previously established by a call to <code class="command">pmNewZone</code> or <code class="command">pmNewContextZone</code>. If the call is successful (that is, there exists a current reporting timezone), a non-negative integer is returned and <em class="replaceable">tz</em> is set to point to a static buffer containing the timezone string itself. The current reporting timezone effects the timezone used by <code class="command">pmCtime</code> and <code class="command">pmLocaltime</code>.
					</div><div class="para">
						A return value less than zero indicates there is no current reporting timezone.
					</div><div class="para">
						The python bindings return the current reporting timezone.
					</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE25844-PARENT">
      ⁠</a>3.8.6. PMAPI Metrics Services</h3></div></div></div><div class="para">
					The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) metrics services.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="Z1034802678tls">
      ⁠</a>3.8.6.1.  <code class="command">pmFetch</code> Function</h4></div></div></div><pre class="programlisting">int pmFetch(int <em class="replaceable">numpmid</em>, pmID <em class="replaceable">pmidlist</em>[], pmResult **<em class="replaceable">result</em>)
<code class="command">Python:</code>
pmResult* <em class="replaceable">pmresult</em> = pmFetch(c_uint <em class="replaceable">pmid[]</em>)</pre><div class="para">
						<a id="IG31340177383" class="indexterm"></a> <a id="IG31340177384" class="indexterm"></a> <a id="IG31340177385" class="indexterm"></a>The most common PMAPI operation is likely to be calls to <code class="command">pmFetch</code>, specifying a list of PMIDs (for example, as constructed by <code class="command">pmLookupName</code>) through <em class="replaceable">pmidlist</em> and <em class="replaceable">numpmid</em>. The call to <code class="command">pmFetch</code> is executed in the context of a source of metrics, instance profile, and collection time, previously established by calls to the functions described in <a class="xref" href="#LE94187-PARENT">Section 3.8.4, “PMAPI Context Services”</a>.
					</div><div class="para">
						The principal result from <code class="command">pmFetch</code> is returned as a tree structured <em class="replaceable">result</em>, described in the <a class="xref" href="#LE82331-PARENT">Section 3.5, “Performance Metrics Values”</a>.
					</div><div class="para">
						If one value (for example, associated with a particular instance) for a requested metric is unavailable at the requested time, then there is no associated <code class="command">pmValue</code> structure in the result. If there are no available values for a metric, then <em class="replaceable">numval</em> is zero and the associated <code class="command">pmValue</code>[] instance is empty; <em class="replaceable">valfmt</em> is undefined in these circumstances, but <em class="replaceable">pmid</em> is correctly set to the PMID of the metric with no values.
					</div><div class="para">
						If the source of the performance metrics is able to provide a reason why no values are available for a particular metric, this reason is encoded as a standard error code in the corresponding <em class="replaceable">numval</em>; see the <code class="command">pmerr(1)</code> and <code class="command">pmErrStr(3)</code> man pages. Since all error codes are negative, values for a requested metric are unavailable if <em class="replaceable">numval</em> is less than or equal to zero.
					</div><div class="para">
						The argument definition and the result specifications have been constructed to ensure that for each PMID in the requested <em class="replaceable">pmidlist</em> there is exactly one <code class="command">pmValueSet</code> in the result, and that the PMIDs appear in exactly the same sequence in both <em class="replaceable">pmidlist</em> and <em class="replaceable">result</em>. This makes the number and order of entries in <em class="replaceable">result</em> completely deterministic, and greatly simplifies the application programming logic after the call to <code class="command">pmFetch</code>.
					</div><div class="para">
						<a id="IG31340177386" class="indexterm"></a>The result structure returned by <code class="command">pmFetch</code> is dynamically allocated using one or more calls to <code class="command">malloc</code> and specialized allocation strategies, and should be released when no longer required by calling <code class="command">pmFreeResult</code>. Under no circumstances should <code class="command">free</code> be called directly to release this space.
					</div><div class="para">
						As common error conditions are encoded in the result data structure, only serious events (such as loss of connection to PMCD, <code class="command">malloc</code> failure, and so on) would cause an error value to be returned by <code class="command"><a id="IG31340177387" class="indexterm"></a>pmFetch</code>. Otherwise, the value returned by the <code class="command">pmFetch</code> function is zero.
					</div><div class="para">
						In <a class="xref" href="#Z976559487sdc">Example 3.13, “PMAPI Metrics Services”</a>, the code fragment dumps the values (assumed to be stored in the <em class="replaceable">lval</em> element of the <code class="filename">pmValue</code> structure) of selected performance metrics once every 10 seconds:
					</div><div class="example"><a id="Z976559487sdc">
      ⁠</a><p class="title"><strong>Example 3.13. PMAPI Metrics Services</strong></p><div class="example-contents"><pre class="programlisting">    int       i, j, sts;
    pmID      pmidlist[10];
    pmResult  *result;
    time_t    now;

    /* set up PMAPI context, numpmid and pmidlist[] ... */
    while ((sts = pmFetch(10, pmidlist, &amp;result)) &gt;= 0) {
        now = (time_t)result-&gt;timestamp.tv_sec;
        printf("\n@ %s", ctime(&amp;now));
        for (i = 0; i &lt; result-&gt;numpmid; i++) {
            printf("PMID: %s", pmIDStr(result-&gt;vset[i]-&gt;pmid));
            for (j = 0; j &lt; result-&gt;vset[i]-&gt;numval; j++) {
                printf(" 0x%x", result-&gt;vset[i]-&gt;vlist[j].value.lval);
                putchar('\n');
            }
        }
        pmFreeResult(result);
        sleep(10);
    }</pre></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							<a id="IG31340177388" class="indexterm"></a> <a id="IG31340177389" class="indexterm"></a>If a response is not received back from PMCD within 10 seconds, the <code class="command">pmFetch</code> times out and returns <code class="literal">PM_ERR_TIMEOUT</code>. This is most likely to occur when the PMAPI client and PMCD are communicating over a slow network connection, but may also occur when one of the hosts is extremely busy. The time out period may be modified using the <code class="literal">PMCD_REQUEST_TIMEOUT</code> environment variable; see the <code class="command">PCPIntro(1)</code> man page.
						</div></div></div><div class="para">
						The python bindings fetch a pmResult corresponding to a <em class="replaceable">pmid</em> list, which is returned from <code class="command">pmLookupName</code>. The returned <em class="replaceable">pmresult</em> is passed to <code class="command">pmExtractValue</code>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5205941">
      ⁠</a>3.8.6.2.  <code class="command">pmFreeResult</code> Function</h4></div></div></div><pre class="programlisting">void pmFreeResult(pmResult *<em class="replaceable">result</em>)
<code class="command">Python:</code>
pmFreeResult(pmResult* <em class="replaceable">pmresult</em>)</pre><div class="para">
						<a id="IG31340177390" class="indexterm"></a> <a id="IG31340177391" class="indexterm"></a>Release the storage previously allocated for a result by <code class="command">pmFetch</code>.
					</div><div class="para">
						THe python bindings free a <em class="replaceable">pmresult</em> previously allocated by <code class="command">pmFetch</code>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5206030">
      ⁠</a>3.8.6.3.  <code class="command">pmStore</code> Function</h4></div></div></div><pre class="programlisting">int pmStore(const pmResult *<em class="replaceable">request</em>)
<code class="command">Python:</code>
pmResult* <em class="replaceable">pmresult</em> = pmStore(pmResult* <em class="replaceable">pmresult</em>)</pre><div class="para">
						<a id="IG31340177392" class="indexterm"></a>In some special cases it may be helpful to modify the current values of performance metrics in one or more underlying domains, for example to reset a counter to zero, or to modify a <em class="firstterm">metric</em>, which is a control variable within a Performance Metric Domain.
					</div><div class="para">
						<a id="IG31340177393" class="indexterm"></a>The <code class="command">pmStore</code> function is a lightweight inverse of <code class="command">pmFetch</code>. The caller must build the <code class="filename">pmResult</code> data structure (which could have been returned from an earlier <code class="command">pmFetch</code> call) and then call <code class="command">pmStore</code>. It is an error to pass a <em class="replaceable">request</em> to <code class="command">pmStore</code> in which the <code class="literal">numval</code> field within any of the <code class="command">pmValueSet</code> structure has a value less than one.
					</div><div class="para">
						The current PMAPI context must be one with a host as the source of metrics, and the current value of the nominated metrics is changed. For example, <code class="command">pmStore</code> cannot be used to make retrospective changes to information in a PCP archive log.
					</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="fetchgroup">
      ⁠</a>3.8.7. PMAPI Fetchgroup Services</h3></div></div></div><div class="para">
					The fetchgroup functions implement a registration-based mechanism to fetch groups of performance metrics, including automation for general unit, rate, type conversions and convenient instance and value encodings. They constitute a powerful and compact alternative to the classic Performance Metrics Application Programming Interface (PMAPI) sequence of separate lookup, check, fetch, iterate, extract, and convert functions.
				</div><div class="para">
					A fetchgroup consists of a PMAPI context and a list of metrics that the application is interested in fetching. For each metric of interest, a conversion specification and a destination <code class="command">pmAtomValue</code> pointer is given. Then, at each subsequent fetchgroup-fetch operation, all metrics are fetched, decoded/converted, and deposited in the desired field of the destination <code class="command">pmAtomValue</code>s. See <a class="xref" href="#Z976562908sdc">Example 3.16, “ <code class="filename">pmAtomValue</code> Structure”</a> for more on that data type. Similarly, a per-metric-instance status value is optionally available for detailed diagnostics reflecting fetch/conversion.
				</div><div class="para">
					The <code class="command">pmfetchgroup(3)</code> man pages give detailed information on the C API; we only list some common cases here. The simplified Python binding to the same API is summarized below. One difference is that runtime errors in C are represented by status integers, but in Python are mapped to <code class="command">pmErr</code> exceptions. Another is that supplying metric type codes are mandatory in the C API but optional in Python, since the latter language supports dynamic typing. Another difference is Python's wrapping of output metric values in callable "holder" objects. We demonstrate all of these below.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm140437899310464">
      ⁠</a>3.8.7.1. Fetchgroup setup</h4></div></div></div><a id="idm140437899309664" class="indexterm"></a><a id="idm140437899308688" class="indexterm"></a><a id="idm140437899307712" class="indexterm"></a><div class="para">
						To create a fetchgroup and its private PMAPI context, the <code class="command">pmCreateFetchGroup</code> function is used, with parameters similar to <code class="command">pmNewContext</code> (see <a class="xref" href="#id5203779">Section 3.8.4.1, “ <code class="command">pmNewContext</code> Function”</a>).
					</div><pre class="programlisting">
int sts;
pmFG fg;
sts = pmCreateFetchGroup(&amp; fg, PM_CONTEXT_ARCHIVE, "./foo.meta");
assert(sts == 0);            
<code class="command">Python</code>
fg = pmapi.fetchgroup(c_api.PM_CONTEXT_ARCHIVE, './foo.meta')
</pre><div class="para">
						If special PMAPI query, PMNS enumeration, or configuration upon the context is needed, the private context may be carefully accessed.
					</div><pre class="programlisting">
int ctx = pmGetFetchGroupContext(fg);
sts = pmUseContext(ctx);
assert(sts == 0);
sts = pmSetMode(...);
<code class="command">Python</code>
ctx = fg.get_context()
ctx.pmSetMode(...)
</pre><div class="para">
						A fetchgroup is born empty. It needs to be extended with metrics to read. Scalars are easy. We specify the metric name, an instance-domain instance if necessary, a unit-scaling and/or rate-conversion directive if desired, and a type code (see <a class="xref" href="#Z976548425sdc">Example 3.2, “ <code class="command">pmDesc</code> Structure”</a>). In C, the value destination is specified by pointer. In Python, a value-holder is returned. 
<pre class="programlisting">
static pmAtomValue ncpu, loadavg, idle;
sts = pmExtendFetchGroup_item(fg, "hinv.ncpu", NULL, NULL,
                              &amp; ncpu, PM_TYPE_32, NULL);
assert (sts == 0);
sts = pmExtendFetchGroup_item(fg, "kernel.all.load", "5 minute", NULL,
                              &amp; loadavg, PM_TYPE_DOUBLE, NULL);
assert (sts == 0);
sts = pmExtendFetchGroup_item(fg, "kernel.all.cpu.idle", NULL, "s/100s",
                              &amp; idle, PM_TYPE_STRING, NULL);
assert (sts == 0);
<code class="command">Python</code>
ncpu = fg.extend_item('hinv.cpu')
loadavg = fg.extend_item('kernel.all.load', instance='5 minute')
idle = fg.extend_item('kernel.all.cpu.idle, scale='s/100s')
</pre>
						 Registering metrics with whole instance domains are also possible; these result in a vector of <code class="command">pmAtomValue</code> instances, instance names and codes, and status codes, so the fetchgroup functions take more optional parameters. In Python, a value-holder-iterator object is returned. 
<pre class="programlisting">
enum { max_disks = 100 };            
static unsigned num_disks;
static pmAtomValue disk_reads[max_disks];
static int disk_read_stss[max_disks];
static char *disk_names[max_disks];
sts = pmExtendFetchGroup_indom(fg, "disk.dm.read", NULL,
                               NULL, disk_names, disk_reads, PM_TYPE_32,
                               disk_read_stss, max_disks, &amp; num_disks,
                               NULL);
<code class="command">Python</code>
values = fg.extend_indom('disk.dm.read')
</pre>
						 Registering interest in the future fetch-operation timestamp is also possible. In python, a datetime-holder object is returned. 
<pre class="programlisting">
struct timeval tv;
sts = pmExtendFetchGroup_timestamp(fg, &amp; tv);            
<code class="command">Python</code>
tv = fg.extend_timestamp()
</pre>

					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm140437899294320">
      ⁠</a>3.8.7.2. Fetchgroup operation</h4></div></div></div><div class="para">
						Now it's time for the program to process the metrics. In the C API, each metric value is put into status integers (if requested), and one field of the <code class="command">pmAtomValue</code> union - whichever was requested with the <code class="command">PM_TYPE_*</code> code. In the Python API, each metric value is accessed by calling the value-holder objects. 
<pre class="programlisting">
sts = pmFetchGroup(fg);
assert (sts == 0);
printf("%s", ctime(&amp; tv.tv_sec));
printf("#cpus: %d, loadavg: %g, idle: %s\n", ncpu.l, loadavg.d, idle.cp);
for (i=0; i&lt;num_disks; i++)
    if (disk_read_stss[i] == 0)
        printf("disk %s reads %d\n", disk_names[i], disk_reads[i].l);
<code class="command">Python</code>
fg.fetch()
print(tv())        
print("#cpus: %d, loadavg: %g, idle: %d\n" % (ncpu(), loadavg(), idle()))
for icode, iname, value in values():
    print('disk %s reads %d' % (iname, value()))
</pre>
						 The program may fetch and process the values only once, or in a loop. The program need not - <span class="emphasis"><em>must not</em></span> - modify or free any of the output values/pointers supplied by the fetchgroup functions.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm140437899289504">
      ⁠</a>3.8.7.3. Fetchgroup shutdown</h4></div></div></div><div class="para">
						Should the program wish to shut down a fetchgroup explicitly, thereby closing the private PMAPI context, there is a function for that. 
<pre class="programlisting">
sts = pmDestroyFetchGroup(fg);
<code class="command">Python</code>
del fg # or nothing
</pre>

					</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE40692-PARENT">
      ⁠</a>3.8.8. PMAPI Record-Mode Services</h3></div></div></div><div class="para">
					The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) record-mode services. These services allow a monitor tool to establish connections to <code class="command">pmlogger</code> co-processes, which they create and control for the purposes of recording live performance data from (possibly) multiple hosts. Since <code class="command">pmlogger</code> records for one host only, these services can administer a group of loggers, and set up archive folios to track the logs. Tools like <code class="command">pmafm</code> can subsequently use those folios to replay recorded data with the initiating tool. <code class="command">pmchart</code> uses these concepts when providing its Record mode functionality.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="LE13213-PARENT">
      ⁠</a>3.8.8.1.  <code class="command">pmRecordAddHost</code> Function</h4></div></div></div><pre class="literallayout">int pmRecordAddHost(const char *<em class="replaceable">host</em>, int <em class="replaceable">isdefault</em>, pmRecordHost **<em class="replaceable">rhp</em>)
<code class="command">Python:</code>
(int <em class="replaceable">status</em>, pmRecordHost* <em class="replaceable">rhp</em>) = pmRecordAddHost("host string", 1, "configure string")</pre><div class="para">
						<a id="IG31340177394" class="indexterm"></a> <a id="IG31340177395" class="indexterm"></a> <a id="IG31340177396" class="indexterm"></a>The <code class="command">pmRecordAddHost</code> function adds hosts once <code class="command">pmRecordSetup</code> has established a new recording session. The <code class="command">pmRecordAddHost</code> function along with the <code class="command">pmRecordSetup</code> and <code class="command">pmRecordControl</code> functions are used to create a PCP archive.
					</div><div class="para">
						<code class="command">pmRecordAddHost</code> is called for each host that is to be included in the recording session. A new <code class="filename">pmRecordHost</code> structure is returned via <em class="replaceable">rhp</em>. It is assumed that PMCD is running on the host as this is how <code class="command">pmlogger</code> retrieves the required performance metrics.
					</div><div class="para">
						If this host is the default host for the recording session, <em class="replaceable">isdefault</em> is nonzero. This ensures that the corresponding archive appears first in the PCP archive <em class="replaceable">folio</em>. Hence the tools used to replay the archive <em class="replaceable">folio</em> make the correct determination of the archive associated with the default host. At most one host per recording session may be nominated as the default host.
					</div><div class="para">
						The calling application writes the desired <code class="command">pmlogger</code> configuration onto the stdio stream returned via the <code class="literal">f_config</code> field in the <code class="filename">pmRecordHost</code> structure.
					</div><div class="para">
						<code class="command">pmRecordAddHost</code> returns 0 on success and a value less than 0 suitable for decoding with <code class="command">pmErrStr</code> on failure. The value <code class="literal">EINVAL</code> has the same interpretation as <code class="literal">errno</code> being set to <code class="literal">EINVAL</code>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="LE35969-PARENT">
      ⁠</a>3.8.8.2.  <code class="command">pmRecordControl</code> Function</h4></div></div></div><pre class="literallayout">int pmRecordControl(pmRecordHost *<em class="replaceable">rhp</em>, int <em class="replaceable">request</em>, const char *<em class="replaceable">options</em>)
<code class="command">Python:</code>
int <em class="replaceable">status</em> = pmRecordControl("host string", 1, "configure string")</pre><div class="para">
						<a id="IG31340177397" class="indexterm"></a>Arguments may be optionally added to the command line that is used to launch <code class="command">pmlogger</code> by calling the <code class="command">pmRecordControl</code> function with a request of <code class="literal">PM_REC_SETARG</code>. The <code class="command">pmRecordControl</code> along with the <code class="command">pmRecordSetup</code> and <code class="command">pmRecordAddHost</code> functions are used to create a PCP archive.
					</div><div class="para">
						The argument is passed via <em class="replaceable">options</em> and one call to <code class="command">pmRecordControl</code> is required for each distinct argument. An argument may be added for a particular <code class="command">pmlogger</code> instance identified by <em class="replaceable">rhp</em>. If the <em class="replaceable">rhp</em> argument is NULL, the argument is added for all <code class="command">pmlogger</code> instances that are launched in the current recording session.
					</div><div class="para">
						Independent of any calls to <code class="command">pmRecordControl</code> with a request of <code class="literal">PM_REC_SETARG</code>, each <code class="command">pmlogger</code> instance is automatically launched with the following arguments: <code class="literal">-c</code>, <code class="literal">-h</code>, <code class="literal">-l</code>, <code class="literal">-x</code>, and the basename for the PCP archive log.
					</div><div class="para">
						To commence the recording session, call <code class="command">pmRecordControl</code> with a request of <code class="literal">PM_REC_ON</code>, and <em class="replaceable">rhp</em> must be NULL. This launches one <code class="command">pmlogger</code> process for each host in the recording session and initializes the <code class="literal">fd_ipc</code>, <code class="literal">logfile</code>, <code class="literal">pid</code>, and <code class="literal">status</code> fields in the associated <code class="filename">pmRecordHost</code> structure(s).
					</div><div class="para">
						To terminate a <code class="command">pmlogger</code> instance identified by <em class="replaceable">rhp</em>, call <code class="command">pmRecordControl</code> with a request of <code class="literal">PM_REC_OFF</code>. If the <em class="replaceable">rhp</em> argument to <code class="command">pmRecordControl</code> is NULL, the termination request is broadcast to all <code class="command">pmlogger</code> processes in the current recording session. An informative dialogue is generated directly by each <code class="command">pmlogger</code> process.
					</div><div class="para">
						To display the current status of the <code class="command">pmlogger</code> instance identified by <em class="replaceable">rhp</em>, call <code class="command">pmRecordControl</code> with a request of <code class="literal">PM_REC_STATUS</code>. If the <em class="replaceable">rhp</em> argument to <code class="command">pmRecordControl</code> is NULL, the status request is broadcast to all <code class="command">pmlogger</code> processes in the current recording session. The display is generated directly by each <code class="command">pmlogger</code> process.
					</div><div class="para">
						To detach a <code class="command">pmlogger</code> instance identified by <em class="replaceable">rhp</em>, allow it to continue independent of the application that launched the recording session and call <code class="command">pmRecordControl</code> with a request of <code class="literal">PM_REC_DETACH</code>. If the <em class="replaceable">rhp</em> argument to <code class="command">pmRecordControl</code> is NULL, the detach request is broadcast to all <code class="command">pmlogger</code> processes in the current recording session.
					</div><div class="para">
						<code class="command">pmRecordControl</code> returns 0 on success and a value less than 0 suitable for decoding with <code class="command">pmErrStr</code> on failure. The value <code class="literal">EINVAL</code> has the same interpretation as <code class="literal">errno</code> being set to <code class="literal">EINVAL</code>.
					</div><div class="para">
						<code class="command">pmRecordControl</code> returns <code class="literal">PM_ERR_IPC</code> if the associated <code class="command">pmlogger</code> process has already exited.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5206798">
      ⁠</a>3.8.8.3.  <code class="command">pmRecordSetup</code> Function</h4></div></div></div><pre class="literallayout">FILE *pmRecordSetup(const char *<em class="replaceable">folio</em>, const char *<em class="replaceable">creator</em>, int <em class="replaceable">replay</em>)
<code class="command">Python:</code>
int <em class="replaceable">status</em> = pmRecordSetup("folio string", "creator string", int replay)</pre><div class="para">
						<a id="IG31340177398" class="indexterm"></a>The <code class="command">pmRecordSetup</code> function along with the <code class="command">pmRecordAddHost</code> and <code class="command">pmRecordControl</code> functions may be used to create a PCP archive on the fly to support record-mode services for PMAPI client applications.
					</div><div class="para">
						Each record mode session involves one or more PCP archive logs; each is created using a dedicated <code class="command">pmlogger</code> process, with an overall Archive Folio format as understood by the <code class="command">pmafm</code> command, to name and collect all of the archive logs associated with a single recording session.
					</div><div class="para">
						The <code class="filename">pmRecordHost</code> structure is used to maintain state information between the creator of the recording session and the associated <code class="command">pmlogger</code> process(es). The structure, shown in <a class="xref" href="#Z976560662sdc">Example 3.14, “ <code class="filename">pmRecordHost</code> Structure”</a>, is defined as:
					</div><div class="example"><a id="Z976560662sdc">
      ⁠</a><p class="title"><strong>Example 3.14.  <code class="filename">pmRecordHost</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">typedef struct {
    FILE   *f_config;    /* caller writes pmlogger configuration here */
    int    fd_ipc;       /* IPC channel to pmlogger */
    char   *logfile;     /* full pathname for pmlogger error logfile */
    pid_t  pid;          /* process id for pmlogger */
    int    status;       /* exit status, -1 if unknown */
} pmRecordHost;</pre></div></div><div class="para">
						In <a class="xref" href="#id5206969">Procedure 3.1, “Creating a Recording Session”</a>, the functions are used in combination to create a recording session.
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="procedure"><a id="id5206969">
      ⁠</a><p class="title"><strong>Procedure 3.1. Creating a Recording Session</strong></p><ol class="1"><li class="step"><div class="para">
								Call <code class="command">pmRecordSetup</code> to establish a new recording session. A new Archive Folio is created using the name <em class="replaceable">folio</em>. If the <em class="replaceable">folio</em> file or directory already exists, or if it cannot be created, this is an error. The application that is creating the session is identified by creator (most often this would be the same as the global PMAPI application name, <code class="literal">pmProgname</code>). If the application knows how to create its own configuration file to replay the recorded session, replay should be nonzero. The <code class="command">pmRecordSetup</code> function returns a stdio stream onto which the application writes the text of any required replay configuration file.
							</div></li><li class="step"><div class="para">
								For each host that is to be included in the recording session, call <code class="command">pmRecordAddHost</code>. A new <code class="filename">pmRecordHost</code> structure is returned via <em class="replaceable">rhp</em>. It is assumed that PMCD is running on the host as this is how <code class="command">pmlogger</code> retrieves the required performance metrics. See <a class="xref" href="#LE13213-PARENT">Section 3.8.8.1, “ <code class="command">pmRecordAddHost</code> Function”</a> for more information.
							</div></li><li class="step"><div class="para">
								Optionally, add arguments to the command line that is used to launch <code class="command">pmlogger</code> by calling <code class="command">pmRecordControl</code> with a request of <code class="literal">PM_REC_SETARG</code>. The argument is passed via options and one call to <code class="command">pmRecordControl</code> is required for each distinct argument. See <a class="xref" href="#LE35969-PARENT">Section 3.8.8.2, “ <code class="command">pmRecordControl</code> Function”</a> for more information.
							</div></li><li class="step"><div class="para">
								To commence the recording session, call <code class="command">pmRecordControl</code> with a request of <code class="literal">PM_REC_ON</code>, and <em class="replaceable">rhp</em> must be NULL.
							</div></li><li class="step"><div class="para">
								To terminate a <code class="command">pmlogger</code> instance identified by <em class="replaceable">rhp</em>, call <code class="command">pmRecordControl</code> with a request of <code class="literal">PM_REC_OFF</code>.
							</div></li><li class="step"><div class="para">
								To display the current status of the <code class="command">pmlogger</code> instance identified by <em class="replaceable">rhp</em>, call <code class="command">pmRecordControl</code> with a request of <code class="literal">PM_REC_STATUS</code>.
							</div></li><li class="step"><div class="para">
								To detach a <code class="command">pmlogger</code> instance identified by <em class="replaceable">rhp</em>, allow it to continue independent of the application that launched the recording session, call <code class="command">pmRecordControl</code> with a request of <code class="literal">PM_REC_DETACH</code>.
							</div></li></ol></div><div class="para">
						The calling application should not close any of the returned stdio streams; <code class="command">pmRecordControl</code> performs this task when recording is commenced.
					</div><div class="para">
						Once <code class="command">pmlogger</code> has been started for a recording session, <code class="command">pmlogger</code> assumes responsibility for any dialogue with the user in the event that the application that launched the recording session should exit, particularly without terminating the recording session.
					</div><div class="para">
						By default, information and dialogues from <code class="command">pmlogger</code> is displayed using <code class="command">pmconfirm</code>. This default is based on the assumption that most applications launching a recording session are GUI-based. In the event that <code class="command">pmconfirm</code> fails to display the information (for example, because the <code class="literal">DISPLAY</code> environment variable is not set), <code class="command">pmlogger</code> writes on its own stderr stream (not the stderr stream of the launching process). The output is assigned to the <code class="filename"><em class="replaceable">xxxxxx</em>.host.log</code> file. For convenience, the full pathname to this file is provided via the <code class="literal">logfile</code> field in the <code class="filename">pmRecordHost</code> structure.
					</div><div class="para">
						If the <em class="replaceable">options</em> argument to <code class="command">pmRecordControl</code> is not NULL, this string may be used to pass additional arguments to <code class="command">pmconfirm</code> in those cases where a dialogue is to be displayed. One use of this capability is to provide a -geometry string to control the placement of the dialogue.
					</div><div class="para">
						Premature termination of a launched <code class="command">pmlogger</code> process may be determined using the <code class="filename">pmRecordHost</code> structure, by calling <code class="command">select</code> on the <code class="literal">fd_ipc</code> field or polling the <code class="literal">status</code> field that will contain the termination status from <code class="command">waitpid</code> if known, or -1.
					</div><div class="para">
						These functions create a number of files in the same directory as the <em class="replaceable">folio</em> file named in the call to <code class="command">pmRecordSetup</code>. In all cases, the <em class="replaceable">xxxxxx</em> component is the result of calling <code class="command">mkstemp</code>.
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
								If replay is nonzero, <em class="replaceable">xxxxxx</em> is the creator's replay configuration file, else an empty control file, used to guarantee uniqueness.
							</div></li><li class="listitem"><div class="para">
								The <em class="replaceable">folio</em> file is the PCP Archive Folio, suitable for use with the <code class="command">pmafm</code> command.
							</div></li><li class="listitem"><div class="para">
								The <code class="filename"><em class="replaceable">xxxxxx</em>.host.confi</code>g file is the <code class="command">pmlogger</code> configuration for each host. If the same host is used in different calls to <code class="command">pmRecordAddHost</code> within the same recording session, one of the letters 'a' through 'z' is appended to the <em class="replaceable">xxxxxx</em> part of all associated file names to ensure uniqueness.
							</div></li><li class="listitem"><div class="para">
								<code class="filename"> <em class="replaceable">xxxxxx</em>.host.log</code> is stdout and stderr for the <code class="command">pmlogger</code> instance for each host.
							</div></li><li class="listitem"><div class="para">
								The <code class="filename"><em class="replaceable">xxxxxx</em>.host.{0,meta,index}</code> files comprise a single PCP archive for each host.
							</div></li></ul></div><div class="para">
						<code class="command">pmRecordSetup</code> may return NULL in the event of an error. Check <code class="literal">errno</code> for the real cause. The value <code class="literal">EINVAL</code> typically means that the order of calls to these functions is not correct; that is, there is an obvious state associated with the current recording session that is maintained across calls to the functions.
					</div><div class="para">
						For example, calling <code class="command">pmRecordControl</code> before calling <code class="command">pmRecordAddHost</code> at least once, or calling <code class="command">pmRecordAddHost</code> before calling <code class="command">pmRecordSetup</code> would produce an <code class="literal">EINVAL</code> error.
					</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE85604-PARENT">
      ⁠</a>3.8.9. PMAPI Archive-Specific Services</h3></div></div></div><div class="para">
					The functions described in this section provide archive-specific services.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5207510">
      ⁠</a>3.8.9.1.  <code class="command">pmGetArchiveLabel</code> Function</h4></div></div></div><pre class="programlisting">int pmGetArchiveLabel(pmLogLabel *<em class="replaceable">lp</em>)
<code class="command">Python:</code>
pmLogLabel <em class="replaceable">loglabel</em> = pmGetArchiveLabel()</pre><div class="para">
						<a id="IG31340177399" class="indexterm"></a> <a id="IG31340177400" class="indexterm"></a> <a id="IG31340177401" class="indexterm"></a>Provided the current PMAPI context is associated with a set of PCP archive logs, the <code class="command">pmGetArchiveLabel</code> function may be used to fetch the label record from the first archive in the set of archives. The structure returned through <em class="replaceable">lp</em> is as shown in <a class="xref" href="#Z976561683sdc">Example 3.15, “ <code class="filename">pmLogLabel</code> Structure”</a>:
					</div><div class="example"><a id="Z976561683sdc">
      ⁠</a><p class="title"><strong>Example 3.15.  <code class="filename">pmLogLabel</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">/*
 * Label Record at the start of every log file - as exported above the PMAPI ...
 */
#define PM_TZ_MAXLEN    40
#define PM_LOG_MAXHOSTLEN   64
#define PM_LOG_MAGIC    0x50052600
#define PM_LOG_VERS01   0x1
#define PM_LOG_VERS02   0x2
#define PM_LOG_VOL_TI   -2      /* temporal index */
#define PM_LOG_VOL_META -1      /* meta data */
typedef struct {
    int            ll_magic;          /* PM_LOG_MAGIC | log format version no. */
    pid_t          ll_pid;            /* PID of logger */
    struct timeval ll_start;          /* start of this log */
    char           ll_hostname[PM_LOG_MAXHOSTLEN]; /* name of collection host */
    char           ll_tz[PM_TZ_MAXLEN];            /* $TZ at collection host */
} pmLogLabel;</pre></div></div><div class="para">
						The python bindings get the label record from the archive.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5207673">
      ⁠</a>3.8.9.2.  <code class="command">pmGetArchiveEnd</code> Function</h4></div></div></div><pre class="programlisting">int pmGetArchiveEnd(struct timeval *<em class="replaceable">tvp</em>)
<code class="command">Python:</code>
timeval <em class="replaceable">tv</em> = <em class="replaceable">status</em> = pmGetArchiveEnd()</pre><div class="para">
						<a id="IG31340177402" class="indexterm"></a> <a id="IG31340177403" class="indexterm"></a> <a id="IG31340177404" class="indexterm"></a>Provided the current PMAPI context is associated with a set of PCP archive logs, <code class="command">pmGetArchiveEnd</code> finds the logical end of the last archive file in the set (after the last complete record in the archive), and returns the last recorded time stamp with <em class="replaceable">tvp</em>. This timestamp may be passed to <code class="command">pmSetMode</code> to reliably position the context at the last valid log record, for example, in preparation for subsequent reading in reverse chronological order.
					</div><div class="para">
						For archive logs that are not concurrently being written, the physical end of file and the logical end of file are co-incident. However, if an archive log is being written by <code class="command">pmlogger</code> at the same time that an application is trying to read the archive, the logical end of file may be before the physical end of file due to write buffering that is not aligned with the logical record boundaries.
					</div><div class="para">
						The python bindings get the last recorded timestamp from the archive.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5207751">
      ⁠</a>3.8.9.3.  <code class="command">pmGetInDomArchive</code> Function</h4></div></div></div><pre class="programlisting">int pmGetInDomArchive(pmInDom <em class="replaceable">indom</em>, int **<em class="replaceable">instlist</em>, char ***<em class="replaceable">namelist</em> )
<code class="command">Python:</code>
((instance1, instance2...) (name1, name2...)) pmGetInDom(pmDesc <em class="replaceable">pmdesc</em>)</pre><div class="para">
						<a id="IG31340177405" class="indexterm"></a> <a id="IG31340177406" class="indexterm"></a> <a id="IG31340177407" class="indexterm"></a>Provided the current PMAPI context is associated with a set of PCP archive logs, <code class="command">pmGetInDomArchive</code> scans the metadata to generate the union of all instances for the instance domain <em class="replaceable">indom</em> that can be found in the set of archive logs, and returns through <em class="replaceable">instlist</em> the internal instance identifiers, and through <em class="replaceable">namelist</em> the full external identifiers.
					</div><div class="para">
						<a id="IG31340177408" class="indexterm"></a>This function is a specialized version of the more general PMAPI function <code class="command">pmGetInDom</code>.
					</div><div class="para">
						The function returns the number of instances found (a value less than zero indicates an error).
					</div><div class="para">
						The resulting lists of instance identifiers (<em class="replaceable">instlist</em> and <em class="replaceable">namelist</em>), and the names that the elements of <em class="replaceable">namelist</em> point to, are allocated by <code class="command">pmGetInDomArchive</code> with two calls to <code class="command">malloc</code>, and it is the responsibility of the caller to use <code class="command">free</code><em class="replaceable">(instlist)</em> and <code class="command">free</code><em class="replaceable">(namelist)</em> to release the space when it is no longer required; see the <code class="command">malloc(3)</code> and <code class="command">free(3)</code> man pages.
					</div><div class="para">
						When the result of <code class="command">pmGetInDomArchive</code> is less than one, both <em class="replaceable">instlist</em> and <em class="replaceable">namelist</em> are undefined (no space is allocated; so calling <code class="command">free</code> is a singularly bad idea).
					</div><div class="para">
						The python bindings return a tuple of the instance IDs and names for the union of all instances for the instance domain <em class="replaceable">pmdesc</em> that can be found in the archive log.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5207937">
      ⁠</a>3.8.9.4.  <code class="command">pmLookupInDomArchive</code> Function</h4></div></div></div><pre class="literallayout">int pmLookupInDomArchive(pmInDom <em class="replaceable">indom</em>, const char *<em class="replaceable">name</em>)
<code class="command">Python:</code>
c_uint <em class="replaceable">instid</em> = pmLookupInDomArchive(pmDesc <em class="replaceable">pmdesc</em>, "Instance")</pre><div class="para">
						<a id="IG31340177409" class="indexterm"></a>Provided the current PMAPI context is associated with a set of PCP archive logs, <code class="command">pmLookupInDomArchive</code> scans the metadata for the instance domain <em class="replaceable">indom</em>, locates the first instance with the external identification given by <em class="replaceable">name</em>, and returns the internal instance identifier.
					</div><div class="para">
						This function is a specialized version of the more general PMAPI function <code class="command">pmLookupInDom</code>.
					</div><div class="para">
						The <code class="command">pmLookupInDomArchive</code> function returns a positive instance identifier on success.
					</div><div class="para">
						The python bindings return the instance id in <em class="replaceable">pmdesc</em> corresponding to <em class="replaceable">Instance</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5208032">
      ⁠</a>3.8.9.5.  <code class="command">pmNameInDomArchive</code> Function</h4></div></div></div><pre class="literallayout">int pmNameInDomArchive(pmInDom <em class="replaceable">indom</em>, int <em class="replaceable">inst</em>, char **<em class="replaceable">name</em>)
<code class="command">Python:</code>
"instance id" = pmNameInDomArchive(pmDesc <em class="replaceable">pmdesc</em>, c_uint <em class="replaceable">instid</em>)</pre><div class="para">
						<a id="IG31340177410" class="indexterm"></a>Provided the current PMAPI context is associated with a set of PCP archive logs, <code class="command">pmNameInDomArchive</code> scans the metadata for the instance domain <em class="replaceable">indom</em>, locates the first instance with the internal instance identifier given by <code class="command">inst</code>, and returns the full external instance identification through <em class="replaceable">name</em>. This function is a specialized version of the more general PMAPI function <code class="command">pmNameInDom</code>.
					</div><div class="para">
						The space for the value of <em class="replaceable">name</em> is allocated in <code class="command">pmNameInDomArchive</code> with <code class="command">malloc</code>, and it is the responsibility of the caller to free the space when it is no longer required; see the <code class="command">malloc(3)</code> and<code class="command">free(3)</code> man pages.
					</div><div class="para">
						The python bindings return the text name of an instance corresponding to an instance domain <em class="replaceable">pmdesc</em> with instance identifier <em class="replaceable">instid</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5208144">
      ⁠</a>3.8.9.6.  <code class="command">pmFetchArchive</code> Function</h4></div></div></div><pre class="literallayout">int pmFetchArchive(pmResult **<em class="replaceable">result</em>)
<code class="command">Python:</code>
pmResult* <em class="replaceable">pmresult</em> = pmFetchArchive()</pre><div class="para">
						<a id="IG31340177411" class="indexterm"></a> <a id="IG31340177412" class="indexterm"></a>This is a variant of <code class="command">pmFetch</code> that may be used only when the current PMAPI context is associated with a set of PCP archive logs. The <em class="replaceable">result</em> is instantiated with all of the metrics (and instances) from the next archive record; consequently, there is no notion of a list of desired metrics, and the instance profile is ignored.
					</div><div class="para">
						It is expected that <code class="command">pmFetchArchive</code> would be used to create utilities that scan archive logs (for example, <code class="command">pmdumplog</code> and <code class="command">pmlogsummary</code>), and the more common access to the archives would be through the <code class="command">pmFetch</code> interface.
					</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE73955-PARENT">
      ⁠</a>3.8.10. PMAPI Time Control Services</h3></div></div></div><div class="para">
					<a id="IG31340177413" class="indexterm"></a> <a id="IG31340177414" class="indexterm"></a>The PMAPI provides a common framework for client applications to control time and to synchronize time with other applications. The user interface component of this service is fully described in the companion <em class="citetitle">Performance Co-Pilot User's and Administrator's Guide</em>. See also the <code class="command">pmtime(1)</code> man page.
				</div><div class="para">
					<a id="IG31340177415" class="indexterm"></a>This service is most useful when processing sets of PCP archive logs, to control parameters such as the current archive position, update interval, replay rate, and timezone, but it can also be used in live mode to control a subset of these parameters. Applications such as <code class="command">pmchart</code>, <code class="command">pmgadgets</code>, <code class="command">pmstat</code>, and <code class="command">pmval</code> use the time control services to connect to an instance of the time control server process, <code class="command">pmtime</code>, which provides a uniform graphical user interface to the time control services.
				</div><div class="para">
					<a id="IG31340177416" class="indexterm"></a>A full description of the PMAPI time control functions along with code examples can be found in man pages as listed in <a class="xref" href="#id5208351">Table 3.2, “Time Control Functions in PMAPI”</a>:
				</div><div class="table"><a id="id5208351">
      ⁠</a><p class="title"><strong>Table 3.2. Time Control Functions in PMAPI</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-7-rows" summary="Time Control Functions in PMAPI"><colgroup><col width="35%" /><col width="65%" /></colgroup><thead><tr valign="top"><th align="left" valign="bottom"> <div class="para">
									Man Page
								</div>
								 </th><th align="left" valign="bottom"> <div class="para">
									Synopsis of Time Control Function
								</div>
								 </th></tr></thead><tbody><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmCtime(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Formats the date and time for a reporting timezone.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmLocaltime(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Converts the date and time for a reporting timezone.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmParseTimeWindow(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Parses time window command line arguments.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmTimeConnect(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Connects to a time control server via a command socket.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmTimeDisconnect(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Closes the command socket to the time control server.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmTimeGetPort(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Obtains the port name of the current time control server.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmTimeRecv(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Blocks until the time control server sends a command message.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmTimeSendAck(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Acknowledges completion of the step command.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmTimeSendBounds(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Specifies beginning and end of archive time period.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmTimeSendMode(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Requests time control server to change to a new VCR mode.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmTimeSendPosition(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Requests time control server to change position or update intervals.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmTimeSendTimezone(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Requests time control server to change timezones.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmTimeShowDialog(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Changes the visibility of the time control dialogue.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="command">pmTimeGetStatePixmap(3)</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Returns array of pixmaps representing supplied time control state.
								</div>
								 </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="LE44064-PARENT">
      ⁠</a>3.8.11. PMAPI Ancillary Support Services</h3></div></div></div><div class="para">
					<a id="IG31340177417" class="indexterm"></a> <a id="IG31340177418" class="indexterm"></a>The functions described in this section provide services that are complementary to, but not necessarily a part of, the distributed manipulation of performance metrics delivered by the PCP components.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5208965">
      ⁠</a>3.8.11.1.  <code class="command">pmGetConfig</code> Function</h4></div></div></div><pre class="literallayout">char *pmGetConfig(const char <em class="replaceable">*variable</em>)
<code class="command">Python:</code>
"env variable value = pmGetConfig("env variable")</pre><div class="para">
						The <code class="command">pmGetConfig</code> function searches for a variable first in the environment and then, if one is not found, in the PCP configuration file and returns the string result. If a variable is not already in the environment, it is added with a call to the <code class="command">putenv</code> function before returning.
					</div><div class="para">
						The default location of the PCP configuration file is <code class="filename">/etc/pcp.conf</code>, but this location may be changed by setting <code class="literal">PCP_CONF</code> in the environment to a new location, as described in the <code class="command">pcp.conf(5)</code> man page.
					</div><div class="para">
						If the variable is not found in either the environment or the PCP configuration file (or the PCP configuration file is not found and <code class="literal">PCP_CONF</code> is not set in the environment), then a fatal error message is printed and the process will exit. Although this sounds drastic, it is the only course of action available because the PCP configuration or installation is fatally flawed.
					</div><div class="para">
						If this function returns, the returned value points to a string in the environment; and so although the function returns the same type as the <code class="command">getenv</code> function (which should probably be a <code class="literal">const char *</code>), changing the content of the string is not recommended.
					</div><div class="para">
						The python bindings return a value for environment variable <em class="replaceable">"env variable"</em> from environment or pcp config file.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5209050">
      ⁠</a>3.8.11.2.  <code class="command">pmErrStr</code> Function</h4></div></div></div><pre class="literallayout">const char *pmErrStr(int <em class="replaceable">code</em>)
char *pmErrStr_r(int <em class="replaceable">code</em>, char *<em class="replaceable">buf</em>, int <em class="replaceable">buflen</em>);
<code class="command">Python:</code>
"error string text" = pmErrStr(int <em class="replaceable">error_code</em>)</pre><div class="para">
						<a id="IG31340177419" class="indexterm"></a>This function translates an error code into a text string, suitable for generating a diagnostic message. By convention within PCP, all error codes are negative. The small values are assumed to be negated versions of the platform error codes as defined in <code class="filename">errno.h</code>, and the strings returned are according to <code class="command">strerror</code>. The large, negative error codes are PMAPI error conditions, and <code class="command">pmErrStr</code> returns an appropriate PMAPI error string, as determined by <em class="replaceable">code</em>.
					</div><div class="para">
						In the case of <code class="command">pmErrStr</code>, the string value is held in a single static buffer, so concurrent calls may not produce the desired results. The <code class="command">pmErrStr_r</code> function allows a buffer and length to be passed in, into which the message is stored; this variant uses no shared storage and can be used in a thread-safe manner.
					</div><div class="para">
						The python bindings return the error string corresponding to the <em class="replaceable">error code</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5209112">
      ⁠</a>3.8.11.3.  <code class="command">pmExtractValue</code> Function</h4></div></div></div><pre class="literallayout">int pmExtractValue(int <em class="replaceable">valfmt</em>, const pmValue *<em class="replaceable">ival</em>, int <em class="replaceable">itype</em>,
pmAtomValue *<em class="replaceable">oval</em>, int <em class="replaceable">otype</em>)
<code class="command">Python:</code>
pmAtomValue <em class="replaceable">atomval</em> = pmExtractValue(int <em class="replaceable">valfmt</em>, const pmValue * <em class="replaceable">ival</em>,
	  int <em class="replaceable">itype</em>,
	  pmAtomValue *<em class="replaceable">oval</em>,
	  int <em class="replaceable">otype</em>)</pre><div class="para">
						<a id="IG31340177420" class="indexterm"></a>The <code class="command">pmValue</code> structure is embedded within the <code class="filename">pmResult</code> structure, which is used to return one or more performance metrics; see the <code class="command">pmFetch</code> man page.
					</div><div class="para">
						All performance metric values may be encoded in a <code class="filename">pmAtomValue</code> union, defined in <a class="xref" href="#Z976562908sdc">Example 3.16, “ <code class="filename">pmAtomValue</code> Structure”</a>:
					</div><div class="example"><a id="Z976562908sdc">
      ⁠</a><p class="title"><strong>Example 3.16.  <code class="filename">pmAtomValue</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">/* Generic Union for Value-Type conversions */
typedef union {
    __int32_t  l;     /* 32-bit signed */
    __uint32_t ul;    /* 32-bit unsigned */
    __int64_t  ll;    /* 64-bit signed */
    __uint64_t ull;   /* 64-bit unsigned */
    float      f;     /* 32-bit floating point */
    double     d;     /* 64-bit floating point */
    char       *cp;   /* char ptr */
    void       *vp;   /* void ptr */
} pmAtomValue;</pre></div></div><div class="para">
						The <code class="command">pmExtractValue</code> function provides a convenient mechanism for extracting values from the <code class="command">pmValue</code> part of a <code class="filename">pmResult</code> structure, optionally converting the data type, and making the result available to the application programmer.
					</div><div class="para">
						<a id="IG31340177421" class="indexterm"></a>The <em class="replaceable">itype</em> argument defines the data type of the input value held in <em class="replaceable">ival</em> according to the storage format defined by <em class="replaceable">valfmt</em> (see the <code class="command">pmFetch</code> man page). The <em class="replaceable">otype</em> argument defines the data type of the result to be placed in <em class="replaceable">oval</em>. The value for <em class="replaceable">itype</em> is typically extracted from a <code class="filename">pmDesc</code> structure, following a call to <code class="command">pmLookupDesc</code> for a particular performance metric.
					</div><div class="para">
						<a class="xref" href="#id5209524">Table 3.3, “PMAPI Type Conversion”</a> defines the various possibilities for the type conversion. The input type (<em class="replaceable">itype</em>) is shown vertically, and the output type (<em class="replaceable">otype</em>) horizontally. The following rules apply:
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
								Y means the conversion is always acceptable.
							</div></li><li class="listitem"><div class="para">
								<a id="IG31340177422" class="indexterm"></a>N means conversion can never be performed (function returns <code class="literal">PM_ERR_CONV</code>).
							</div></li><li class="listitem"><div class="para">
								P means the conversion may lose accuracy (but no error status is returned).
							</div></li><li class="listitem"><div class="para">
								<a id="IG31340177423" class="indexterm"></a>T means the result may be subject to high-order truncation (if this occurs the function returns <code class="literal">PM_ERR_TRUNC</code>).
							</div></li><li class="listitem"><div class="para">
								<a id="IG31340177424" class="indexterm"></a>S means the conversion may be impossible due to the sign of the input value (if this occurs the function returns <code class="literal">PM_ERR_SIGN</code>).
							</div></li></ul></div><div class="para">
						<a id="IG31340177425" class="indexterm"></a>If an error occurs, <em class="replaceable">oval</em> is set to zero (or NULL).
					</div><div class="para">
						<div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
								Note that some of the conversions involving the <code class="literal">PM_TYPE_STRING</code> and <code class="literal">PM_TYPE_AGGREGATE</code> types are indeed possible, but are marked N; the rationale is that <code class="command">pmExtractValue</code> should not attempt to duplicate functionality already available in the C library through <code class="command">sscanf</code> and <code class="command">sprintf</code>. No conversion involving the type <code class="literal">PM_TYPE_EVENT</code> is supported.
							</div></div></div>

					</div><div class="table"><a id="id5209524">
      ⁠</a><p class="title"><strong>Table 3.3. PMAPI Type Conversion</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="gt-8-cols gt-7-rows" summary="PMAPI Type Conversion"><colgroup><col /><col /><col /><col /><col /><col /><col /><col /><col /><col /></colgroup><thead><tr valign="top"><th align="left" valign="bottom"> <div class="para">
										TYPE
									</div>
									 </th><th align="left" valign="bottom"> <div class="para">
										32
									</div>
									 </th><th align="left" valign="bottom"> <div class="para">
										U32
									</div>
									 </th><th align="left" valign="bottom"> <div class="para">
										64
									</div>
									 </th><th align="left" valign="bottom"> <div class="para">
										U64
									</div>
									 </th><th align="left" valign="bottom"> <div class="para">
										FLOAT
									</div>
									 </th><th align="left" valign="bottom"> <div class="para">
										DBLE
									</div>
									 </th><th align="left" valign="bottom"> <div class="para">
										STRING
									</div>
									 </th><th align="left" valign="bottom"> <div class="para">
										AGGR
									</div>
									 </th><th align="left" valign="bottom"> <div class="para">
										EVENT
									</div>
									 </th></tr></thead><tbody><tr valign="top"><td align="left" valign="top"> <div class="para">
										<code class="literal">32</code>
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										Y
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										S
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										Y
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										S
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
										<code class="literal">U32</code>
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										T
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										Y
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										Y
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										Y
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
										<code class="literal">64</code>
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										T
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										T,S
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										Y
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										S
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
										<code class="literal">u64</code>
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										T
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										T
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										T
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										Y
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
										<code class="literal">FLOAT</code>
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P, T
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P, T, S
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P, T
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P, T, S
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										Y
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										Y
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
										<code class="literal">DBLE</code>
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P, T
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P, T, S
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P, T
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P, T, S
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										P
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										Y
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
										<code class="literal">STRING</code>
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										Y
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
										<code class="literal">AGGR</code>
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										Y
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
										<code class="literal">EVENT</code>
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td><td align="left" valign="top"> <div class="para">
										N
									</div>
									 </td></tr></tbody></table></div></div><div class="para">
						In the cases where multiple conversion errors could occur, the first encountered error is returned, and the order of checking is not defined.
					</div><div class="para">
						If the output conversion is to one of the pointer types, such as <em class="replaceable">otype</em> <code class="literal">PM_TYPE_STRING</code> or <code class="literal">PM_TYPE_AGGREGATE</code>, then the value buffer is allocated by <code class="command">pmExtractValue</code> using <code class="command">malloc</code>, and it is the caller's responsibility to free the space when it is no longer required; see the <code class="command">malloc(3)</code> and <code class="command">free(3)</code> man pages.
					</div><div class="para">
						Although this function appears rather complex, it has been constructed to assist the development of performance tools that convert values, whose type is known only through the <code class="literal">type</code> field in a <code class="command">pmDesc</code> structure, into a canonical type for local processing.
					</div><div class="para">
						The python bindings extract a value from a pmValue struct <em class="replaceable">ival</em> stored in format <em class="replaceable">valfmt</em> (see <code class="command">pmFetch</code>), and convert its type from <em class="replaceable">itype</em> to <em class="replaceable">otype</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5210752">
      ⁠</a>3.8.11.4.  <code class="command">pmConvScale</code> Function</h4></div></div></div><pre class="programlisting">int
pmConvScale(int <em class="replaceable">type</em>, const pmAtomValue *<em class="replaceable">ival</em>, const pmUnits *<em class="replaceable">iunit</em>,
pmAtomValue *<em class="replaceable">oval</em>, pmUnits *<em class="replaceable">ounit</em>)
<code class="command">Python:</code>
pmAtomValue <em class="replaceable">atomval</em> = pmConvScale(int <em class="replaceable">itype</em>, pmAtomValue value,
	  pmDesc* pmdesc , int descidx, int otype)</pre><div class="para">
						<a id="IG31340177426" class="indexterm"></a>Given a performance metric value pointed to by <em class="replaceable">ival</em>, multiply it by a scale factor and return the value in <em class="replaceable">oval</em>. The scaling takes place from the units defined by <em class="replaceable">iunit</em> into the units defined by <em class="replaceable">ounit</em>. Both input and output units must have the same dimensionality.
					</div><div class="para">
						<a id="IG31340177427" class="indexterm"></a>The performance metric type for both input and output values is determined by <em class="replaceable">type</em>, the value for which is typically extracted from a <code class="filename">pmDesc</code> structure, following a call to <code class="command">pmLookupDesc</code> for a particular performance metric.
					</div><div class="para">
						<a id="IG31340177428" class="indexterm"></a> <code class="command">pmConvScale</code> is most useful when values returned through <code class="command">pmFetch</code> (and possibly extracted using <code class="command">pmExtractValue</code>) need to be normalized into some canonical scale and units for the purposes of computation.
					</div><div class="para">
						The python bindings convert a <em class="replaceable">value</em> pointed to by <em class="replaceable">pmdesc</em> entry <em class="replaceable">descidx</em> to a different scale <em class="replaceable">otype</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5210895">
      ⁠</a>3.8.11.5.  <code class="command">pmUnitsStr</code> Function</h4></div></div></div><pre class="literallayout">const char *pmUnitsStr(const pmUnits *<em class="replaceable">pu</em>)
char *pmUnitsStr_r(const pmUnits *<em class="replaceable">pu</em>, char *<em class="replaceable">buf</em>, int <em class="replaceable">buflen</em>)
<code class="command">Python:</code>
"units string" = pmUnitsStr(pmUnits <em class="replaceable">pmunits</em>)</pre><div class="para">
						<a id="IG31340177429" class="indexterm"></a>As an aid to labeling graphs and tables, or for error messages, <code class="command">pmUnitsStr</code> takes a dimension and scale specification as per <em class="replaceable">pu</em>, and returns the corresponding text string.
					</div><div class="para">
						<em class="replaceable">pu</em> is typically from a <code class="filename">pmDesc</code> structure, for example, as returned by <code class="command">pmLookupDesc</code>.
					</div><div class="para">
						If <em class="replaceable">*pu</em> were <code class="literal">{1, -2, 0, PM_SPACE_MBYTE, PM_TIME_MSEC, 0}</code>, then the result string would be <code class="literal">Mbyte/sec^2</code>.
					</div><div class="para">
						In the case of <code class="command">pmUnitsStr</code>, the string value is held in a single static buffer; so concurrent calls may not produce the desired results. The <code class="command">pmUnitsStr_r</code> function allows a buffer and length to be passed in, into which the units are stored; this variant uses no shared storage and can be used in a thread-safe manner.
					</div><div class="para">
						The python bindings translate a pmUnits struct <em class="replaceable">pmunits</em> to a readable string.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5210994">
      ⁠</a>3.8.11.6.  <code class="command">pmIDStr</code> Function</h4></div></div></div><pre class="literallayout">const char *pmIDStr(pmID <em class="replaceable">pmid</em>)
char *pmIDStr_r(pmID <em class="replaceable">pmid</em>, char *<em class="replaceable">buf</em>, int <em class="replaceable">buflen</em>)
<code class="command">Python:</code>
"ID string" = pmIDStr(int <em class="replaceable">pmID</em>)</pre><div class="para">
						<a id="IG31340177430" class="indexterm"></a>For use in error and diagnostic messages, return a human readable version of the specified PMID, with each of the internal <code class="literal">domain</code>, <code class="literal">cluster</code>, and <code class="literal">item</code> subfields appearing as decimal numbers, separated by periods.
					</div><div class="para">
						In the case of <code class="command">pmIDStr</code>, the string value is held in a single static buffer; so concurrent calls may not produce the desired results. The <code class="command">pmIDStr_r</code> function allows a buffer and length to be passed in, into which the identifier is stored; this variant uses no shared storage and can be used in a thread-safe manner.
					</div><div class="para">
						The python bindings translate a pmID <em class="replaceable">pmid</em> to a readable string.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5211046">
      ⁠</a>3.8.11.7.  <code class="command">pmInDomStr</code> Function</h4></div></div></div><pre class="literallayout">const char *pmInDomStr(pmInDom <em class="replaceable">indom</em>)
char *pmInDomStr_r(pmInDom <em class="replaceable">indom</em>, char *<em class="replaceable">buf</em>, int <em class="replaceable">buflen</em>)
<code class="command">Python:</code>
"indom" = pmGetInDom(pmDesc <em class="replaceable">pmdesc</em>)</pre><div class="para">
						<a id="IG31340177431" class="indexterm"></a>For use in error and diagnostic messages, return a human readable version of the specified instance domain identifier, with each of the internal <code class="literal">domain</code> and <code class="literal">serial</code> subfields appearing as decimal numbers, separated by periods.
					</div><div class="para">
						In the case of <code class="command">pmInDomStrr</code>, the string value is held in a single static buffer; so concurrent calls may not produce the desired results. The <code class="command">pmInDomStr_r</code> function allows a buffer and length to be passed in, into which the identifier is stored; this variant uses no shared storage and can be used in a thread-safe manner.
					</div><div class="para">
						The python bindings translate an instance domain ID pointed to by a pmDesc <em class="replaceable">pmdesc</em> to a readable string.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5211095">
      ⁠</a>3.8.11.8.  <code class="command">pmTypeStr</code> Function</h4></div></div></div><pre class="literallayout">const char *pmTypeStr(int <em class="replaceable">type</em>)
char *pmTypeStr_r(int <em class="replaceable">type</em>, char *<em class="replaceable">buf</em>, int <em class="replaceable">buflen</em>)
<code class="command">Python:</code>
"type" = pmTypeStr(int <em class="replaceable">type</em>)</pre><div class="para">
						<a id="IG31340177432" class="indexterm"></a>Given a performance metric type, produce a terse ASCII equivalent, appropriate for use in error and diagnostic messages.
					</div><div class="para">
						Examples are “32” (for <code class="literal">PM_TYPE_32</code>), “U64” (for <code class="literal">PM_TYPE_U64</code>), “AGGREGATE” (for <code class="literal">PM_TYPE_AGGREGATE</code>), and so on.
					</div><div class="para">
						In the case of <code class="command">pmTypeStr</code>, the string value is held in a single static buffer; so concurrent calls may not produce the desired results. The <code class="command">pmTypeStr_r</code> function allows a buffer and length to be passed in, into which the identifier is stored; this variant uses no shared storage and can be used in a thread-safe manner.
					</div><div class="para">
						The python bindings translate a performance metric type to a readable string. Constants are available for the types, e.g. c_api.PM_TYPE_FLOAT, by importing cpmapi.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5211169">
      ⁠</a>3.8.11.9.  <code class="command">pmAtomStr</code> Function</h4></div></div></div><pre class="literallayout">const char *pmAtomStr(const pmAtomValue *<em class="replaceable">avp</em>, int <em class="replaceable">type</em>)
char *pmAtomStr_r(const pmAtomValue *<em class="replaceable">avp</em>, int <em class="replaceable">type</em>char *<em class="replaceable">buf</em>, int <em class="replaceable">buflen</em>)
<code class="command">Python:</code>
"value" = pmAtomStr(<em class="replaceable">atom</em>, <em class="replaceable">type</em>)</pre><div class="para">
						<a id="IG31340177433" class="indexterm"></a>Given the <code class="command">pmAtomValue</code> identified by <em class="replaceable">avp</em>, and a performance metric <em class="replaceable">type</em>, generate the corresponding metric value as a string, suitable for diagnostic or report output.
					</div><div class="para">
						In the case of <code class="command">pmAtomStr</code>, the string value is held in a single static buffer; so concurrent calls may not produce the desired results. The <code class="command">pmAtomStr_r</code> function allows a buffer and length to be passed in, into which the identifier is stored; this variant uses no shared storage and can be used in a thread-safe manner.
					</div><div class="para">
						The python bindings translate a pmAtomValue <em class="replaceable">atom</em> having performance metric <em class="replaceable">type</em> to a readable string. Constants are available for the types, e.g. c_api.PM_TYPE_U32, by importing cpmapi.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5211303">
      ⁠</a>3.8.11.10.  <code class="command">pmNumberStr</code> Function</h4></div></div></div><pre class="literallayout">const char *pmNumberStr(double <em class="replaceable">value</em>)
char *pmNumberStr_r(double <em class="replaceable">value</em>, char *<em class="replaceable">buf</em>, int <em class="replaceable">buflen</em>)</pre><div class="para">
						<a id="IG31340177434" class="indexterm"></a>The <code class="command">pmNumberStr</code> function returns the address of a static 8-byte buffer that holds a null-byte terminated representation of value suitable for output with fixed-width fields.
					</div><div class="para">
						The value is scaled using multipliers in powers of one thousand (the decimal kilo) and has a bias that provides greater precision for positive numbers as opposed to negative numbers. The format depends on the sign and magnitude of <em class="replaceable">value</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5211350">
      ⁠</a>3.8.11.11.  <code class="command">pmPrintValue</code> Function</h4></div></div></div><pre class="literallayout">void pmPrintValue(FILE *<em class="replaceable">f</em>, int <em class="replaceable">valfmt</em>, int <em class="replaceable">type</em>, const pmValue *<em class="replaceable">val</em>,
int <em class="replaceable">minwidth</em>)
<code class="command">Python:</code>
pmPrintValue(FILE* <em class="replaceable">file</em>, pmResult <em class="replaceable">pmresult</em>, <em class="replaceable">pmdesc</em>, <em class="replaceable">vset_index</em>, <em class="replaceable">vlist_index</em>, <em class="replaceable">min_width</em>)</pre><div class="para">
						<a id="IG31340177435" class="indexterm"></a> <a id="IG31340177436" class="indexterm"></a>The value of a single performance metric (as identified by <em class="replaceable">val</em>) is printed on the standard I/O stream identified by <em class="replaceable">f</em>. The value of the performance metric is interpreted according to the format of <em class="replaceable">val</em> as defined by <em class="replaceable">valfmt</em> (from a <code class="command">pmValueSet</code> within a <code class="filename">pmResult</code>) and the generic description of the metric's type from a <code class="command">pmDesc</code> structure, passed in through.
					</div><div class="para">
						If the converted value is less than <em class="replaceable">minwidth</em> characters wide, it will have leading spaces to pad the output to a width of <em class="replaceable">minwidth</em> characters.
					</div><div class="para">
						<a class="xref" href="#Z976565414sdc">Example 3.17, “Using <code class="command">pmPrintValue</code> to Print Values”</a> illustrates using <code class="command">pmPrintValue</code> to print the values from a <code class="filename">pmResult</code> structure returned via <code class="command">pmFetch</code>:
					</div><div class="example"><a id="Z976565414sdc">
      ⁠</a><p class="title"><strong>Example 3.17. Using <code class="command">pmPrintValue</code> to Print Values</strong></p><div class="example-contents"><pre class="programlisting">    int         numpmid, i, j, sts;
    pmID        pmidlist[10];
    pmDesc      desc[10];
    pmResult    *result;

    /* set up PMAPI context, numpmid and pmidlist[] ... */
    /* get metric descriptors */
    for (i = 0; i &lt; numpmid; i++) {
        if ((sts = pmLookupDesc(pmidlist[i], &amp;desc[i])) &lt; 0) {
            printf("pmLookupDesc(pmid=%s): %s\n",
                          pmIDStr(pmidlist[i]), pmErrStr(sts));
            exit(1);
        }
    }
    if ((sts = pmFetch(numpmid, pmidlist, &amp;result)) &gt;= 0) {
        /* once per metric */
        for (i = 0; i &lt; result-&gt;numpmid; i++) {
            printf("PMID: %s", pmIDStr(result-&gt;vset[i]-&gt;pmid));
            /* once per instance for this metric */
            for (j = 0; j &lt; result-&gt;vset[i]-&gt;numval; j++) {
                printf(" [%d]", result-&gt;vset[i]-&gt;vlist[j].inst);
                pmPrintValue(stdout, result-&gt;vset[i]-&gt;valfmt,
                             desc[i].type,
                             &amp;result-&gt;vset[i]-&gt;vlist[j],
                             8);
            }
            putchar('\n');
        }
        pmFreeResult(result);
    }
    else
        printf("pmFetch: %s\n", pmErrStr(sts));</pre></div></div><div class="para">
						Print the value of a <em class="replaceable">pmresult</em> pointed to by <em class="replaceable">vset_index</em>/<em class="replaceable">vlist_index</em> and described by <em class="replaceable">pmdesc</em>. The format of a pmResult is described in <a class="link" href="#IG31340177277"><span class="emphasis"><em>pmResult</em></span></a> The python bindings can use sys.__stdout__ as a value for <em class="replaceable">file</em> to display to stdout.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5211504">
      ⁠</a>3.8.11.12.  <code class="command">pmflush</code> Function</h4></div></div></div><pre class="literallayout">int pmflush(void);
<code class="command">Python:</code>
int <em class="replaceable">status</em> = pmflush()</pre><div class="para">
						<a id="IG31340177437" class="indexterm"></a>The <code class="command">pmflush</code> function causes the internal buffer which is shared with <code class="command">pmprintf</code> to be either displayed in a window, printed on standard error, or flushed to a file and the internal buffer to be cleared.
					</div><div class="para">
						The <code class="literal">PCP_STDERR</code> environment variable controls the output technique used by <code class="command">pmflush</code>:
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
								If <code class="literal">PCP_STDERR</code> is unset, the text is written onto the stderr stream of the caller.
							</div></li><li class="listitem"><div class="para">
								If <code class="literal">PCP_STDERR</code> is set to the literal reserved word <code class="literal">DISPLAY</code>, then the text is displayed as a GUI dialogue using <code class="command">pmconfirm</code>.
							</div></li></ul></div><div class="para">
						The <code class="command">pmflush</code> function returns a value of zero on successful completion. A negative value is returned if an error was encountered, and this can be passed to <code class="command">pmErrStr</code> to obtain the associated error message.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5211641">
      ⁠</a>3.8.11.13.  <code class="command">pmprintf</code> Function</h4></div></div></div><pre class="literallayout">int pmprintf(const char *<em class="replaceable">fmt</em>, ... /*<em class="replaceable">args</em>*/);
<code class="command">Python:</code>
pmprintf("fmt", ... /*<em class="replaceable">args</em>*/);</pre><div class="para">
						<a id="IG31340177438" class="indexterm"></a>The <code class="command">pmprintf</code> function appends the formatted message string to an internal buffer shared by the <code class="command">pmprintf</code> and <code class="command">pmflush </code> functions, without actually producing any output. The <em class="replaceable">fmt</em> argument is used to control the conversion, formatting, and printing of the variable length <em class="replaceable">args</em> list.
					</div><div class="para">
						The <code class="command">pmprintf</code> function uses the <code class="command">mkstemp</code> function to securely create a <code class="literal">pcp</code>-prefixed temporary file in <code class="filename">${PCP_TMP_DIR}</code>. This temporary file is deleted when <code class="command">pmflush</code> is called.
					</div><div class="para">
						On successful completion, <code class="command">pmprintf</code> returns the number of characters transmitted. A negative value is returned if an error was encountered, and this can be passed to <code class="command">pmErrStr</code> to obtain the associated error message.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5211762">
      ⁠</a>3.8.11.14.  <code class="command">pmSortInstances</code> Function</h4></div></div></div><pre class="literallayout">void pmSortInstances(pmResult *<em class="replaceable">result</em>)
<code class="command">Python:</code>
pmSortInstances (pmResult* pmresult)</pre><div class="para">
						<a id="IG31340177439" class="indexterm"></a> <a id="IG31340177440" class="indexterm"></a>The <code class="command">pmSortInstances</code> function may be used to guarantee that for each performance metric in the result from <code class="command">pmFetch</code>, the instances are in ascending internal instance identifier sequence. This is useful when trying to compute rates from two consecutive <code class="command">pmFetch</code> results, where the underlying instance domain or metric availability is not static.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5211834">
      ⁠</a>3.8.11.15.  <code class="command">pmParseInterval</code> Function</h4></div></div></div><pre class="literallayout">int pmParseInterval(const char *<em class="replaceable">string</em>, struct timeval *<em class="replaceable">rslt</em>, char **<em class="replaceable">errmsg</em>)
<code class="command">Python:</code>
(struct <em class="replaceable">timeval</em>, "error message") = pmParseInterval("time string")</pre><div class="para">
						<a id="IG31340177441" class="indexterm"></a>The <code class="command">pmParseInterval</code> function parses the argument string specifying an interval of time and fills in the <code class="literal">tv_sec</code> and <code class="literal">tv_usec</code> components of the <code class="filename">rslt</code> structure to represent that interval. The input string is most commonly the argument following a <code class="literal">-t</code> command line option to a PCP application, and the syntax is fully described in the <code class="command">PCPIntro(1)</code> man page.
					</div><div class="para">
						<code class="command">pmParseInterval</code> returns 0 and <em class="replaceable">errmsg</em> is undefined if the parsing is successful. If the given string does not conform to the required syntax, the function returns -1 and a dynamically allocated error message string in <em class="replaceable">errmsg</em>.
					</div><div class="para">
						The error message is terminated with a newline and includes the text of the input string along with an indicator of the position at which the error was detected as shown in the following example:
					</div><pre class="programlisting">              4minutes 30mumble
                         ^ -- unexpected value</pre><div class="para">
						In the case of an error, the caller is responsible for calling <code class="command">free</code> to release the space allocated for <em class="replaceable">errmsg</em>.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5211943">
      ⁠</a>3.8.11.16.  <code class="command">pmParseMetricSpec</code> Function</h4></div></div></div><pre class="literallayout">int pmParseMetricSpec(const char *<em class="replaceable">string</em>, int <em class="replaceable">isarch</em>, char *<em class="replaceable">source</em>,
                      pmMetricSpec **<em class="replaceable">rsltp</em>, char **<em class="replaceable">errmsg</em>)
<code class="command">Python:</code>
(pmMetricSpec <em class="replaceable">metricspec</em>, "error message") = 
                      pmParseMetricSpec("metric specification", isarch, source)</pre><div class="para">
						<a id="IG31340177442" class="indexterm"></a>The <code class="command">pmParseMetricSpec</code> function accepts a <em class="replaceable">string</em> specifying the name of a PCP performance metric, and optionally the source (either a hostname, a set of PCP archive logs, or a local context) and instances for that metric. The syntax is described in the <code class="command">PCPIntro(1)</code> man page.
					</div><div class="para">
						If neither host nor archive component of the metric specification is provided, the <code class="literal">isarch</code> and <code class="literal">source</code> arguments are used to fill in the returned <code class="filename">pmMetricSpec</code> structure. In <a class="xref" href="#Z976566126sdc">Example 3.18, “ <code class="filename">pmMetricSpec</code> Structure”</a>, the <code class="filename">pmMetricSpec</code> structure, which is returned via <em class="replaceable">rsltp,</em> represents the parsed string.
					</div><div class="example"><a id="Z976566126sdc">
      ⁠</a><p class="title"><strong>Example 3.18.  <code class="filename">pmMetricSpec</code> Structure</strong></p><div class="example-contents"><pre class="programlisting">typedef struct {
    int     isarch;      /* source type: 0 -&gt; host, 1 -&gt; archive, 2 -&gt; local context */
    char    *source;     /* name of source host or archive */
    char    *metric;     /* name of metric */
    int     ninst;       /* number of instances, 0 -&gt; all */
    char    *inst[1];    /* array of instance names */
} pmMetricSpec;</pre></div></div><div class="para">
						The <code class="command">pmParseMetricSpec</code> function returns 0 if the given string was successfully parsed. In this case, all the storage allocated by <code class="command">pmParseMetricSpec</code> can be released by a single call to the <code class="command">free</code> function by using the address returned from <code class="command">pmMetricSpec</code> via <em class="replaceable">rsltp</em>. The convenience macro <code class="command">pmFreeMetricSpec</code> is a thinly disguised wrapper for <code class="command">free</code>.
					</div><div class="para">
						The <code class="command">pmParseMetricSpec</code> function returns 0 if the given string was successfully parsed. It returns <code class="literal">PM_ERR_GENERIC</code> and a dynamically allocated error message string in <em class="replaceable">errmsg</em> if the given string does not parse. In this situation, the error message string can be released with the <code class="command">free</code> function.
					</div><div class="para">
						In the case of an error, <em class="replaceable">rsltp</em> is undefined. In the case of success, <em class="replaceable">errmsg</em> is undefined. If <em class="replaceable">rsltp</em>-&gt;<em class="replaceable">ninst</em> is 0, then <em class="replaceable">rsltp</em>-&gt;<em class="replaceable">inst</em>[0] is undefined.
					</div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5212196">
      ⁠</a>3.9. PMAPI Programming Issues and Examples</h2></div></div></div><div class="para">
				<a id="IG31340177443" class="indexterm"></a> <a id="IG31340177444" class="indexterm"></a> <a id="IG31340177445" class="indexterm"></a>The following issues and examples are provided to enable you to create better custom performance monitoring tools.
			</div><div class="para">
				The source code for a sample client (<code class="command">pmclient</code>) using the PMAPI is shipped as part of the PCP package. See the <code class="command">pmclient(1)</code> man page, and the source code, located in <code class="filename">${PCP_DEMOS_DIR}/pmclient</code>.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5212297">
      ⁠</a>3.9.1. Symbolic Association between a Metric's Name and Value</h3></div></div></div><div class="para">
					<a id="IG31340177446" class="indexterm"></a> <a id="IG31340177447" class="indexterm"></a>A common problem in building specific performance tools is how to maintain the association between a performance metric's name, its access (instantiation) method, and the application program variable that contains the metric's value. Generally this results in code that is easily broken by bug fixes or changes in the underlying data structures. The PMAPI provides a uniform method for instantiating and accessing the values independent of the underlying implementation, although it does not solve the name-variable association problem. However, it does provide a framework within which a manageable solution may be developed.
				</div><div class="para">
					Fundamentally, the goal is to be able to name a metric and reference the metric's value in a manner that is independent of the order of operations on other metrics; for example, to associate the <code class="command">LOADAV</code> macro with the name <code class="command">kernel.all.load</code>, and then be able to use <code class="command">LOADAV</code> to get at the value of the corresponding metric.
				</div><div class="para">
					<a id="IG31340177448" class="indexterm"></a> <a id="IG31340177449" class="indexterm"></a>The one-to-one association between the ordinal position of the metric names is input to <code class="command">pmLookupName</code> and the PMIDs returned by this function, and the one-to-one association between the PMIDs input to <code class="command">pmFetch</code> and the values returned by this function provide the basis for an automated solution.
				</div><div class="para">
					The tool <code class="command">pmgenmap</code> takes the specification of a list of metric names and symbolic tags, in the order they should be passed to <code class="command">pmLookupName</code> and <code class="command">pmFetch</code>. For example, <code class="command">pmclient</code>:
				</div><pre class="programlisting">
          <strong class="userinput"><code>cat ${PCP_DEMOS_DIR}/pmclient/pmnsmap.spec</code></strong>
pmclient_init {
    hinv.ncpu			NUMCPU
}

pmclient_sample {
    kernel.all.load	LOADAV
    kernel.percpu.cpu.user	CPU_USR
    kernel.percpu.cpu.sys	CPU_SYS
    mem.freemem		FREEMEM
    disk.all.total		DKIOPS
}</pre><div class="para">
					This <code class="command">pmgenmap</code> input produces the C code in <a class="xref" href="#Z976566536sdc">Example 3.19, “C Code Produced by <code class="command">pmgenmap</code> Input”</a>. It is suitable for including with the <code class="literal">#include</code> statement:
				</div><div class="example"><a id="Z976566536sdc">
      ⁠</a><p class="title"><strong>Example 3.19. C Code Produced by <code class="command">pmgenmap</code> Input</strong></p><div class="example-contents"><pre class="programlisting">/*
 * Performance Metrics Name Space Map
 * Built by runme.sh from the file
 * pmnsmap.spec
 * on Thu Jan  9 14:13:49 EST 2014
 *
 * Do not edit this file!
 */

char *pmclient_init[] = {
#define NUMCPU	0
	"hinv.ncpu",

};


char *pmclient_sample[] = {
#define LOADAV	0
	"kernel.all.load",
#define CPU_USR	1
	"kernel.percpu.cpu.user",
#define CPU_SYS	2
	"kernel.percpu.cpu.sys",
#define FREEMEM	3
	"mem.freemem",
#define DKIOPS	4
	"disk.all.total",

};</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5212519">
      ⁠</a>3.9.2. Initializing New Metrics</h3></div></div></div><div class="para">
					<a id="IG31340177450" class="indexterm"></a> <a id="IG31340177451" class="indexterm"></a> <a id="IG31340177452" class="indexterm"></a>Using the code generated by <code class="command">pmgenmap</code>, you are now able to easily initialize the application's metric specifications as shown in <a class="xref" href="#Z976566793sdc">Example 3.20, “Initializing Metric Specifications”</a>:
				</div><div class="example"><a id="Z976566793sdc">
      ⁠</a><p class="title"><strong>Example 3.20. Initializing Metric Specifications</strong></p><div class="example-contents"><pre class="programlisting">/* C code fragment from pmclient.c */
numpmid = sizeof(pmclient_sample) / sizeof(char *);
if ((pmidlist = (pmID *)malloc(numpmid * sizeof(pmidlist[0]))) == NULL) {...}
if ((sts = pmLookupName(numpmid, pmclient_sample, pmidlist)) &lt; 0) {...}
</pre><pre class="programlisting"># The equivalent python code would be
pmclient_sample = ("kernel.all.load", "kernel.percpu.cpu.user",
	"kernel.percpu.cpu.sys", "mem.freemem", "disk.all.total")
pmidlist = context.pmLookupName(pmclient_sample)
</pre></div></div><div class="para">
					At this stage, <code class="command">pmidlist</code> contains the PMID for the five metrics of interest.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5212595">
      ⁠</a>3.9.3. Iterative Processing of Values</h3></div></div></div><div class="para">
					<a id="IG31340177453" class="indexterm"></a> <a id="IG31340177454" class="indexterm"></a>Assuming the tool is required to report values every <em class="replaceable">delta</em> seconds, use code similar to that in <a class="xref" href="#Z976567058sdc">Example 3.21, “Iterative Processing”</a>:
				</div><div class="example"><a id="Z976567058sdc">
      ⁠</a><p class="title"><strong>Example 3.21. Iterative Processing</strong></p><div class="example-contents"><pre class="programlisting">/* censored C code fragment from pmclient.c */
while (samples == -1 || samples-- &gt; 0) {
   if ((sts = pmFetch(numpmid, pmidlist, &amp;crp)) &lt; 0) { ... }
   for (i = 0; i &lt; numpmid; i++)
      if ((sts = pmLookupDesc(pmidlist[i], &amp;desclist[i])) &lt; 0) { ... }
   ...
   pmExtractValue(crp-&gt;vset[FREEMEM]-&gt;valfmt, crp-&gt;vset[FREEMEM]-&gt;vlist,
                  desclist[FREEMEM].type, &amp;tmp, PM_TYPE_FLOAT);
   pmConvScale(PM_TYPE_FLOAT, &amp;tmp, &amp;desclist[FREEMEM].units,
                    &amp;atom, &amp;mbyte_scale);
   ip-&gt;freemem = atom.f;
   ...
   __pmtimevalSleep(delta);
}</pre><pre class="programlisting"># The equivalent python code would be
FREEMEM = 3
desclist = context.pmLookupDescs(metric_names)
while (samples &gt; 0):
    crp = context.pmFetch(metric_names)
    val = context.pmExtractValue(crp.contents.get_valfmt(FREEMEM),
                             crp.contents.get_vlist(FREEMEM, 0),
                             desclist[FREEMEM].contents.type,
                             c_api.PM_TYPE_FLOAT)
    atom = ctx.pmConvScale(c_api.PM_TYPE_FLOAT, val, desclist, FREEMEM,
    			   c_api.PM_SPACE_MBYTE)
    (tvdelta, errmsg) = c_api.pmParseInterval(delta)
    c_api.pmtimevalSleep(delta)
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5212682">
      ⁠</a>3.9.4. Accommodating Program Evolution</h3></div></div></div><div class="para">
					<a id="IG31340177455" class="indexterm"></a> <a id="IG31340177456" class="indexterm"></a>The flexibility provided by the PMAPI and the <code class="command">pmgenmap</code> utility is demonstrated by <a class="xref" href="#Z976567218sdc">Example 3.22, “Adding a Metric”</a>. Consider the requirement for reporting a third metric <code class="literal">mem.physmem</code>. This example shows how to add the line to the specification file:
				</div><div class="example"><a id="Z976567218sdc">
      ⁠</a><p class="title"><strong>Example 3.22. Adding a Metric</strong></p><div class="example-contents"><pre class="literallayout">mem.freemem PHYSMEM</pre><div class="para">
						Then regenerate the <code class="filename">#include</code> file, and augment pmclient.c:
					</div><pre class="programlisting">   pmExtractValue(crp-&gt;vset[PHYSMEM]-&gt;valfmt, crp-&gt;vset[PHYSMEM]-&gt;vlist,
                  desclist[PHYSMEM].type, &amp;tmp, PM_TYPE_FLOAT);
   pmConvScale(PM_TYPE_FLOAT, &amp;tmp, &amp;desclist[PHYSMEM].units,
                    &amp;atom, &amp;mbyte_scale);
</pre><pre class="programlisting"># The equivalent python code would be:
val = context.pmExtractValue(crp.contents.get_valfmt(PHYSMEM),
			crp.contents.get_vlist(PHYSMEM, 0),
			desclist[PHYSMEM].contents.type,
			c_api.PM_TYPE_FLOAT);
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5212805">
      ⁠</a>3.9.5. Handling PMAPI Errors</h3></div></div></div><div class="para">
					<a id="IG31340177457" class="indexterm"></a> <a id="IG31340177458" class="indexterm"></a>In <a class="xref" href="#id5212839">Example 3.23, “PMAPI Error Handling”</a>, the simple but complete PMAPI application demonstrates the recommended style for handling PMAPI error conditions. The python bindings use the exception mechanism to raise an exception in error cases. The python client can handle this condition by catching the <code class="literal">pmErr</code> exception. For simplicity, no command line argument processing is shown here - in practice most tools use the <code class="command">pmGetOptions</code> helper interface to assist with initial context creation and setup.
				</div><div class="example"><a id="id5212839">
      ⁠</a><p class="title"><strong>Example 3.23. PMAPI Error Handling</strong></p><div class="example-contents"><pre class="programlisting">#include &lt;pcp/pmapi.h&gt;

int
main(int argc, char* argv[])
{
    int                 sts = 0;
    char                *host = "local:";
    char                *metric = "mem.freemem";
    pmID                pmid;
    pmDesc              desc;
    pmResult            *result;

    sts = pmNewContext(PM_CONTEXT_HOST, host);
    if (sts &lt; 0) {
        fprintf(stderr, "Error connecting to pmcd on %s: %s\n",
                host, pmErrStr(sts));
        exit(1);
    }
    sts = pmLookupName(1, &amp;metric, &amp;pmid);
    if (sts &lt; 0) {
        fprintf(stderr, "Error looking up %s: %s\n", metric,
                pmErrStr(sts));
        exit(1);
    }
    sts = pmLookupDesc(pmid, &amp;desc);
    if (sts &lt; 0) {
        fprintf(stderr, "Error getting descriptor for %s:%s: %s\n",
                host, metric, pmErrStr(sts));
        exit(1);
    }
    sts = pmFetch(1, &amp;pmid, &amp;result);
    if (sts &lt; 0) {
        fprintf(stderr, "Error fetching %s:%s: %s\n", host, metric,
                pmErrStr(sts));
        exit(1);
    }
    sts = result-&gt;vset[0]-&gt;numval;
    if (sts &lt; 0) {
        fprintf(stderr, "Error fetching %s:%s: %s\n", host, metric,
                pmErrStr(sts));
        exit(1);
    }
    fprintf(stdout, "%s:%s = ", host, metric);
    if (sts == 0)
        puts("(no value)");
    else {
        pmValueSet      *vsp = result-&gt;vset[0];
        pmPrintValue(stdout, vsp-&gt;valfmt, desc.type,
                             &amp;vsp-&gt;vlist[0], 5);
        printf(" %s\n", pmUnitsStr(&amp;desc.units));
    }
    return 0;
}</pre><pre class="programlisting"># The equivalent python code would be:
import sys
import traceback
from pcp import pmapi
from cpmapi import PM_TYPE_U32

try:
    context = pmapi.pmContext()
    pmid = context.pmLookupName("mem.freemem")
    desc = context.pmLookupDescs(pmid)
    result = context.pmFetch(pmid)
    freemem = context.pmExtractValue(result.contents.get_valfmt(0),
                                 result.contents.get_vlist(0, 0),
                                 desc[0].contents.type,
                                 PM_TYPE_U32)
    print "freemem is " + str(int(freemem.ul))

except pmapi.pmErr, error:
    print "%s: %s" % (sys.argv[0], error.message())
except Exception, error:
    sys.stderr.write(str(error) + "\n")
    sys.stderr.write(traceback.format_exc() + "\n")
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5212855">
      ⁠</a>3.9.6. Compiling and Linking PMAPI Applications</h3></div></div></div><div class="para">
					<a id="IG31340177459" class="indexterm"></a> <a id="IG31340177460" class="indexterm"></a> <a id="IG31340177461" class="indexterm"></a>Typical PMAPI applications require the following line to include the function prototype and data structure definitions used by the PMAPI.
				</div><pre class="programlisting">#include &lt;pcp/pmapi.h&gt;</pre><div class="para">
					Some applications may also require these header files: <code class="filename">&lt;pcp/impl.h&gt;</code> and <code class="filename">&lt;pcp/pmda.h&gt;</code>.
				</div><div class="para">
					The run-time environment of the PMAPI is mostly found in the <code class="filename">libpcp</code> library; so to link a generic PMAPI application requires something akin to the following command:
				</div><pre class="literallayout">
          <strong class="userinput"><code>cc</code></strong> <em class="replaceable">mycode</em><strong class="userinput"><code>.c -lpcp</code></strong></pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="LE25915-PARENT">
      ⁠</a>Chapter 4. Instrumenting Applications</h1></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="#id5213105">4.1. Application and Performance Co-Pilot Relationship</a></span></dt><dt><span class="section"><a href="#id5213104">4.2. Performance Instrumentation and Sampling</a></span></dt><dt><span class="section"><a href="#id5213287nat">4.3. MMV PMDA Design</a></span></dt><dt><span class="section"><a href="#id5213288nat">4.4. Memory Mapped Values API</a></span></dt><dd><dl><dt><span class="section"><a href="#id5214320nat">4.4.1. Starting and Stopping Instrumentation</a></span></dt><dt><span class="section"><a href="#idm140437898995056">4.4.2. Getting a Handle on Mapped Values</a></span></dt><dt><span class="section"><a href="#idm140437898986192">4.4.3. Updating Mapped Values</a></span></dt><dt><span class="section"><a href="#id5214734">4.4.4. Elapsed Time Measures</a></span></dt></dl></dd><dt><span class="section"><a href="#id5213106">4.5. Performance Instrumentation and Tracing</a></span></dt><dt><span class="section"><a href="#id5213287">4.6. Trace PMDA Design</a></span></dt><dd><dl><dt><span class="section"><a href="#id5213308">4.6.1. Application Interaction</a></span></dt><dt><span class="section"><a href="#id5213449">4.6.2. Sampling Techniques</a></span></dt><dt><span class="section"><a href="#id5213903">4.6.3. Configuring the Trace PMDA</a></span></dt></dl></dd><dt><span class="section"><a href="#LE26087-PARENT">4.7. Trace API</a></span></dt><dd><dl><dt><span class="section"><a href="#id5214320">4.7.1. Transactions </a></span></dt><dt><span class="section"><a href="#id5214714">4.7.2. Point Tracing </a></span></dt><dt><span class="section"><a href="#id5214931">4.7.3. Observations and Counters</a></span></dt><dt><span class="section"><a href="#id5215241">4.7.4. Configuring the Trace Library</a></span></dt></dl></dd></dl></div><div class="para">
			<a id="IG31340177462nat" class="indexterm"></a> <a id="IG31340177462" class="indexterm"></a> <a id="IG31340177463" class="indexterm"></a>This chapter provides an introduction to ways of instrumenting applications using PCP.
		</div><div class="para">
			<a id="IG31340177565" class="indexterm"></a> The first section covers the use of the Memory Mapped Value (MMV) Performance Metrics Domain Agent (PMDA) to generate customized metrics from an application. This provides a robust, extremely efficient mechanism for transferring custom instrumentation into the PCP infrastructure. It has been successfully deployed in production environments for many years, has proven immensely valuable in these situations, and can be used to instrument applications written in a number of programming languages.
		</div><div class="para">
			The Memory Mapped Value library and PMDA is supported on every PCP platform, and is enabled by default.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				A particularly expansive Java API is available from the separate <a href="http://code.google.com/p/parfait/">Parfait</a> project. It supports both the existing JVM instrumentation, and custom application metric extensions.
			</div></div></div><div class="para">
			<a id="IG31340177464nat" class="indexterm"></a><a id="IG31340177465nat" class="indexterm"></a> The chapter also includes information on how to use the MMV library (<code class="filename">libpcp_mmv</code>) for instrumenting an application. The example programs are installed in <code class="filename">${PCP_DEMOS_DIR}/mmv</code>.
		</div><div class="para">
			The second section covers the design of the Trace PMDA, in an effort to explain how to configure the agent optimally for a particular problem domain. This information supplements the functional coverage which the man pages provide to both the agent and the library interfaces.
		</div><div class="para">
			<a id="IG31340177464" class="indexterm"></a><a id="IG31340177465" class="indexterm"></a> This part of the chapter also includes information on how to use the Trace PMDA and its associated library (<code class="filename">libpcp_trace</code>) for instrumenting applications. The example programs are installed in <code class="filename">${PCP_DEMOS_DIR}/trace</code>.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
				The current PCP trace library is a relatively heavy-weight solution, issuing multiple system calls per trace point, runs over a TCP/IP socket even locally and performs no event batching. As such it is not appropriate for production application instrumentation at this stage.
			</div></div></div><div class="para">
			A revised application tracing library and PMDA are planned which will be light-weight, suitable for production system tracing, and support event metrics and other advances in end-to-end distributed application tracing.
		</div><div class="para">
			<a id="IG31340177554" class="indexterm"></a> <a id="IG31340177555" class="indexterm"></a>The application instrumentation libraries are designed to encourage application developers to embed calls in their code that enable application performance data to be exported. When combined with system-level performance data, this feature allows total performance and resource demands of an application to be correlated with application activity.
		</div><div class="para">
			For example, developers can provide the following application performance metrics:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a id="IG31340177556" class="indexterm"></a>Computation state (especially for codes with major shifts in resource demands between phases of their execution)
				</div></li><li class="listitem"><div class="para">
					<a id="IG31340177557" class="indexterm"></a>Problem size and parameters, that is, degree of parallelism throughput in terms of sub-problems solved, iteration count, transactions, data sets inspected, and so on
				</div></li><li class="listitem"><div class="para">
					<a id="IG31340177558" class="indexterm"></a>Service time by operation type
				</div></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5213105">
      ⁠</a>4.1. Application and Performance Co-Pilot Relationship</h2></div></div></div><div class="para">
				<a id="IG31340177550" class="indexterm"></a> <a id="IG31340177551" class="indexterm"></a> <a id="IG31340177552" class="indexterm"></a>The relationship between an application, the <code class="filename">pcp_mmv</code> and <code class="filename">pcp_trace</code> instrumentation libraries, the MMV and Trace PMDAs, and the rest of the PCP infrastructure is shown in <a class="xref" href="#id5216302">Figure 4.1, “Application and PCP Relationship”</a>:
			</div><div class="para">
				<div class="figure"><a id="id5216302">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><object data="images/instrumentation.svg" type="image/svg+xml"><img src="images/instrumentation.png" alt="Application and PCP Relationship" /></object></div></div><p class="title"><strong>Figure 4.1. Application and PCP Relationship</strong></p></div>

			</div><div class="para">
				Once the application performance metrics are exported into the PCP framework, all of the PCP tools may be leveraged to provide performance monitoring and management, including:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						Two- and three-dimensional visualization of resource demands and performance, showing concurrent system activity and application activity.
					</div></li><li class="listitem"><div class="para">
						<a id="IG31340177561" class="indexterm"></a>Transport of performance data over the network for distributed performance management.
					</div></li><li class="listitem"><div class="para">
						<a id="IG31340177562" class="indexterm"></a>Archive logging for historical records of performance, most useful for problem diagnosis, postmortem analysis, performance regression testing, capacity planning, and benchmarking.
					</div></li><li class="listitem"><div class="para">
						<a id="IG31340177563" class="indexterm"></a>Automated alarms when bad performance is observed. These apply both in real-time or when scanning archives of historical application performance.
					</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5213104">
      ⁠</a>4.2. Performance Instrumentation and Sampling</h2></div></div></div><div class="para">
				<a id="IG31340177467nat" class="indexterm"></a> <a id="IG31340177468nat" class="indexterm"></a>The <code class="filename">pcp_mmv</code> library provides function calls to assist with extracing important performance metrics from a program into a shared, in-memory location such that the MMV PMDA can examine and serve that information on behalf of PCP client tool requests. The <code class="filename">pcp_mmv</code> library is described in the <code class="command">mmv_stats_init(3)</code>, <code class="command">mmv_lookup_value_desc(3)</code>, <code class="command">mmv_inc_value(3)</code> man pages. Additionally, the format of the shared memory mappings is described in detail in <code class="command">mmv(5)</code>.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5213287nat">
      ⁠</a>4.3. MMV PMDA Design</h2></div></div></div><div class="para">
				<a id="IG31340177470nat" class="indexterm"></a>An application instrumented with memory mapped values directly updates the memory that backs the metric values it exports. The MMV PMDA reads those values directly, from the <code class="literal">same</code> memory that the application is updating, when current values are sampled on behalf of PMAPI client tools. This relationship, and a simplified MMV API, are shown in <a class="xref" href="#id5214410nat">Figure 4.2, “Memory Mapped Page Sharing”</a>.
			</div><div class="para">
				<div class="figure"><a id="id5214410nat">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><object data="images/pmdammv.svg" type="image/svg+xml"><img src="images/pmdammv.png" alt="" /></object></div></div><p class="title"><strong>Figure 4.2. Memory Mapped Page Sharing</strong></p></div>

			</div><div class="para">
				It is worth noting that once the metrics of an application have been registered via the <code class="filename">pcp_mmv</code> library initialisation API, subsequent interactions with the library are not intrusive to the instrumented application. At the points where values are updated, the only cost involved is the memory mapping update, which is a single memory store operation. There is no need to explicitly transfer control to the MMV PMDA, nor allocate memory, nor make system or library calls. The PMDA will only sample the values at times driven by PMAPI client tools, and this places no overhead on the instrumented application.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5213288nat">
      ⁠</a>4.4. Memory Mapped Values API</h2></div></div></div><div class="para">
				<a id="IG31340177502nat" class="indexterm"></a> <a id="IG31340177503nat" class="indexterm"></a>The <code class="filename">libpcp_mmv</code> Application Programming Interface (API) can be called from C, C++, Perl and Python (a separate project, Parfait, services the needs of Java applications). Each language has access to the complete set of functionality offered by <code class="filename">libpcp_mmv</code>. In most cases, the calling conventions differ only slightly between languages - in the case of Java and Parfait, they differ significantly however.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5214320nat">
      ⁠</a>4.4.1. Starting and Stopping Instrumentation</h3></div></div></div><div class="para">
					<a id="IG31340177504nat" class="indexterm"></a> <a id="IG31340177505nat" class="indexterm"></a> Instrumentation is begun with an initial call to <code class="literal">mmv_stats_init</code>, and ended with a call to <code class="literal">mmv_stats_stop</code>. These calls manipulate global state shared by the library and application. These are the only calls requiring synchonization and a single call to each is typically performed early and late in the life of the application (although they can be used to reset the library state as well, at any time). As such, the choice of synchonization primitive is left to the application, and none is currently performed by the library.
				</div><pre class="literallayout">void *mmv_stats_init(const char *<em class="replaceable">name</em>, int <em class="replaceable">cluster</em>, mmv_stats_flags_t <em class="replaceable">flags</em>,
                     const mmv_metric_t *<em class="replaceable">stats</em>, int <em class="replaceable">nstats</em>,
                     const mmv_indom_t *<em class="replaceable">indoms</em>, int <em class="replaceable">nindoms</em>)</pre><div class="para">
					The <em class="replaceable">name</em> should be a simple symbolic name identifying the application. It is usually used as the first application-specific part of the exported metric names, as seen from the MMV PMDA. This behavior can be overriden using the <em class="replaceable">flags</em> parameter, with the MMV_FLAG_NOPREFIX flag. In the example below, full metric names such as <code class="literal">mmv.acme.products.count</code> will be created by the MMV PMDA. With the MMV_FLAG_NOPREFIX flag set, that would instead become <code class="literal">mmv.products.count</code>. It is recommended to not disable the prefix - doing so requires the applications to ensure naming conflicts do not arise in the MMV PMDA metric names.
				</div><div class="para">
					The <em class="replaceable">cluster</em> identifier is used by the MMV PMDA to further distinguish different applications, and is directly used for the MMV PMDA PMID cluster field described in <a class="xref" href="#Z1033577630tls">Example 2.3, “ <code class="filename">__pmID_int</code> Structure”</a>, for all MMV PMDA metrics.
				</div><div class="para">
					All remaining parameters to <code class="literal">mmv_stats_init</code> define the metrics and instance domains that exist within the application. These are somewhat analagous to the final parameters of <code class="literal">pmdaInit(3)</code>, and are best explained using <a class="xref" href="#Z1033577630nat">Example 4.1, “Memory Mapped Value Instance Structures”</a> and <a class="xref" href="#Z1033577631nat">Example 4.2, “Memory Mapped Value Metrics Structures”</a>. As mentioned earlier, the full source code for this example instrumented application can be found in <code class="filename">${PCP_DEMOS_DIR}/mmv</code>.
				</div><div class="para">
					<div class="example"><a id="Z1033577630nat">
      ⁠</a><p class="title"><strong>Example 4.1. Memory Mapped Value Instance Structures</strong></p><div class="example-contents"><pre class="programlisting">#include &lt;pcp/pmapi.h&gt;
#include &lt;pcp/mmv_stats.h&gt;

static mmv_instances_t products[] = {
    {   .internal = 0, .external = "Anvils" },
    {   .internal = 1, .external = "Rockets" },
    {   .internal = 2, .external = "Giant_Rubber_Bands" },
};
#define ACME_PRODUCTS_INDOM 61
#define ACME_PRODUCTS_COUNT (sizeof(products)/sizeof(products[0]))

static mmv_indom_t indoms[] = {
    {   .serial = ACME_PRODUCTS_INDOM,
        .count = ACME_PRODUCTS_COUNT,
        .instances = products,
        .shorttext = "Acme products",
        .helptext = "Most popular products produced by the Acme Corporation",
    },
};</pre></div></div>

				</div><div class="para">
					The above data structures initialize an instance domain of the set of products produced in a factory by the fictional "Acme Corporation". These structures are directly comparable to several concepts we have seen already (and for good reason - the MMV PMDA must interpret the applications intentions and properly export instances on its behalf):
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							mmv_instances_t maps to pmdaInstid, as in <a class="xref" href="#Z975964618sdc">Example 2.7, “ <code class="filename">pmdaInstid</code> Structure”</a>
						</div></li><li class="listitem"><div class="para">
							mmv_indom_t maps to pmdaIndom, as in <a class="xref" href="#Z975964773sdc">Example 2.8, “ <code class="filename">pmdaIndom</code> Structure”</a> - the major difference is the addition of oneline and long help text, the purpose of which should be self-explanatory at this stage.
						</div></li><li class="listitem"><div class="para">
							<em class="replaceable">serial</em> numbers, as in <a class="xref" href="#Z1033578294tls">Example 2.9, “ <code class="literal">__pmInDom_int</code> Structure”</a>
						</div></li></ul></div><div class="para">
					Next, we shall create three metrics, all of which use this instance domain. These are the <code class="literal">mmv.acme.products</code> metrics, and they reflect the rates at which products are built by the machines in the factory, how long these builds take for each product, and how long each product type spends queued (while waiting for factory capacity to become available).
				</div><div class="para">
					<div class="example"><a id="Z1033577631nat">
      ⁠</a><p class="title"><strong>Example 4.2. Memory Mapped Value Metrics Structures</strong></p><div class="example-contents"><pre class="programlisting">static mmv_metric_t metrics[] = {
    {   .name = "products.count",
        .item = 7,
        .type = MMV_TYPE_U64,
        .semantics = MMV_SEM_COUNTER,
        .dimension = MMV_UNITS(0,0,1,0,0,PM_COUNT_ONE),
        .indom = ACME_PRODUCTS_INDOM,
        .shorttext = "Acme factory product throughput",
        .helptext =
"Monotonic increasing counter of products produced in the Acme Corporation\n"
"factory since starting the Acme production application.  Quality guaranteed.",
    },
    {   .name = "products.time",
        .item = 8,
        .type = MMV_TYPE_U64,
        .semantics = MMV_SEM_COUNTER,
        .dimension = MMV_UNITS(0,1,0,0,PM_TIME_USEC,0),
        .indom = ACME_PRODUCTS_INDOM,
        .shorttext = "Machine time spent producing Acme products",
        .helptext =
"Machine time spent producing Acme Corporation products.  Does not include\n"
"time in queues waiting for production machinery.",
    },
    {   .name = "products.queuetime",
        .item = 10,
        .type = MMV_TYPE_U64,
        .semantics = MMV_SEM_COUNTER,
        .dimension = MMV_UNITS(0,1,0,0,PM_TIME_USEC,0),
        .indom = ACME_PRODUCTS_INDOM,
        .shorttext = "Queued time while producing Acme products",
        .helptext =
"Time spent in the queue waiting to build Acme Corporation products,\n"
"while some other Acme product was being built instead of this one.",
    },
};
#define INDOM_COUNT (sizeof(indoms)/sizeof(indoms[0]))
#define METRIC_COUNT (sizeof(metrics)/sizeof(metrics[0]))</pre></div></div>

				</div><div class="para">
					As was the case with the "products" instance domain before, these metric-defining data structures are directly comparable to PMDA data structures described earlier:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							mmv_metric_t maps to a pmDesc structure, as in <a class="xref" href="#Z976548425sdc">Example 3.2, “ <code class="command">pmDesc</code> Structure”</a>
						</div></li><li class="listitem"><div class="para">
							MMV_TYPE, MMV_SEM, and MMV_UNITS map to PMAPI constructs for type, semantics, dimensionality and scale, as in <a class="xref" href="#Z1034792511tls">Example 3.3, “ <code class="filename">pmUnits</code> and <code class="filename">pmDesc</code> Structures”</a>
						</div></li><li class="listitem"><div class="para">
							<em class="replaceable">item</em> number, as in <a class="xref" href="#Z1033577630tls">Example 2.3, “ <code class="filename">__pmID_int</code> Structure”</a>
						</div></li></ul></div><div class="para">
					For the most part, all types and macros map directly to their core PCP counterparts, which the MMV PMDA will use when exporting the metrics. One important exception is the introduction of the metric type MMV_TYPE_ELAPSED, which is discussed further in <a class="xref" href="#id5214734">Section 4.4.4, “Elapsed Time Measures”</a>.
				</div><div class="para">
					The compound metric types - aggregate and event type metrics - are not supported by the MMV format.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140437898995056">
      ⁠</a>4.4.2. Getting a Handle on Mapped Values</h3></div></div></div><div class="para">
					<a id="Z1033577633nat" class="indexterm"></a>Once metrics (and the instance domains they use) have been registered, the memory mapped file has been created and is ready for use. In order to be able to update the individual metric values, however, we must find get a handle to the value. This is done using the <code class="command">mmv_lookup_value_desc</code> function, as shown in <a class="xref" href="#Z1033577632nat">Example 4.3, “Memory Mapped Value Handles”</a>.
				</div><div class="para">
					<div class="example"><a id="Z1033577632nat">
      ⁠</a><p class="title"><strong>Example 4.3. Memory Mapped Value Handles</strong></p><div class="example-contents"><pre class="programlisting">#define ACME_CLUSTER 321        /* PMID cluster identifier */

int
main(int argc, char * argv[])
{
    void *base;
    pmAtomValue *count[ACME_PRODUCTS_COUNT];
    pmAtomValue *machine[ACME_PRODUCTS_COUNT];
    pmAtomValue *inqueue[ACME_PRODUCTS_COUNT];
    unsigned int working;
    unsigned int product;
    unsigned int i;

    base = mmv_stats_init("acme", ACME_CLUSTER, 0,
                          metrics, METRIC_COUNT, indoms, INDOM_COUNT);
    if (!base) {
        perror("mmv_stats_init");
        return 1;
    }

    for (i = 0; i &lt; ACME_PRODUCTS_COUNT; i++) {
        count[i] = mmv_lookup_value_desc(base,
                        "products.count", products[i].external);
        machine[i] = mmv_lookup_value_desc(base,
                        "products.time", products[i].external);
        inqueue[i] = mmv_lookup_value_desc(base,
                        "products.queuetime", products[i].external);
    }</pre></div></div>

				</div><div class="para">
					Space in the mapping file for every value is set aside at initialization time (by the <code class="command">mmv_stats_init</code> function) - that is, space for each and every metric, and each value (instance) of each metric when an instance domain is used. To find the handle to the space set aside for one individual value requires the tuple of base memory address of the mapping, metric name, and instance name. In the case of metrics with no instance domain, the final instance name parameter should be either NULL or the empty string.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140437898986192">
      ⁠</a>4.4.3. Updating Mapped Values</h3></div></div></div><div class="para">
					<a id="Z1033577634nat" class="indexterm"></a>At this stage we have individual handles (pointers) to each instrumentation point, we can now start modifying these values and observing changes through the PCP infrastructure. Notice that each handle is simply the canonical <code class="command">pmAtomValue</code> pointer, as defined in <a class="xref" href="#Z976562908sdc">Example 3.16, “ <code class="filename">pmAtomValue</code> Structure”</a>, which is a union providing sufficient space to hold any single value.
				</div><div class="para">
					This pointer can be either manipulated directly, or using helper functions provided by the <code class="command">pcp_mmv</code> API, such as the <code class="command">mmv_stats_inc</code> and <code class="command">mmv_stats_set</code> functions.
				</div><div class="para">
					<div class="example"><a id="Z1033577636">
      ⁠</a><p class="title"><strong>Example 4.4. Memory Mapped Value Updates</strong></p><div class="example-contents"><pre class="programlisting">    while (1) {
        /* choose a random number between 0-N -&gt; product */
        product = rand() % ACME_PRODUCTS_COUNT;

        /* assign a time spent "working" on this product */
        working = rand() % 50000;

        /* pretend to "work" so process doesn't burn CPU */
        usleep(working);

        /* update the memory mapped values for this one: */
        /* one more product produced and work time spent */
        mmv_inc_value(base, machine[product], working); /* API */
        count[product]-&gt;ull += 1;     /* or direct mmap update */

        /* all other products are "queued" for this time */
        for (i = 0; i &lt; ACME_PRODUCTS_COUNT; i++)
            if (i != product)
                mmv_inc_value(base, inqueue[i], working);
    }</pre></div></div>

				</div><div class="para">
					At this stage, it will be informative to compile and run the complete example program, which can be found in <code class="filename">${PCP_DEMOS_DIR}/mmv/acme.c</code>. There is an associated <code class="filename">Makefile</code> to build it, in the same directory. Running the <code class="filename">acme</code> binary creates the instrumentation shown in <a class="xref" href="#Z1033577637">Example 4.5, “Memory Mapped Value Reports”</a>, with live values letting us explore simple queueing effects in products being created on the ACME factory floor.
				</div><div class="para">
					<div class="example"><a id="Z1033577637">
      ⁠</a><p class="title"><strong>Example 4.5. Memory Mapped Value Reports</strong></p><div class="example-contents"><pre class="programlisting">
              <strong class="userinput"><code>pminfo -m mmv.acme</code></strong>
mmv.acme.products.queuetime PMID: 70.321.10
mmv.acme.products.time PMID: 70.321.8
mmv.acme.products.count PMID: 70.321.7

<strong class="userinput"><code>pmval -f2 -s3 mmv.acme.products.time</code></strong>
metric:    mmv.acme.products.time
host:      localhost
semantics: cumulative counter (converting to rate)
units:     microsec (converting to time utilization)
samples:   3
interval:  1.00 sec

               Anvils               Rockets    Giant_Rubber_Bands 
                 0.37                  0.12                  0.50 
                 0.35                  0.25                  0.38 
                 0.57                  0.20                  0.23</pre></div></div>

				</div><div class="para">
					Experimentation with the algorithm from <a class="xref" href="#Z1033577636">Example 4.4, “Memory Mapped Value Updates”</a> is encouraged. In particular, observe the effects of rate conversion (counter metric type) of a metric with units of "time" (PM_TIME_*). The reported values are calculated over a sampling interval, which also has units of "time", forming a utilization. This is extremely valuable performance analysis currency - comparable metrics would include processor utilization, disk spindle utilization, and so forth.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5214734">
      ⁠</a>4.4.4. Elapsed Time Measures</h3></div></div></div><div class="para">
					<a id="Z1033577635nat" class="indexterm"></a> <a id="Z1033577636nat" class="indexterm"></a>One problem with the instrumentation model embodied by the <code class="command">pcp_mmv</code> library is providing timing information for long-running operations. For instrumenting long-running operations, like uploading downloading a file, the overall operation may be broken into smaller, discrete units of work which can be easily instrumented in terms of operations and througput measures. In other cases, there are no divisible units for long-running operations (for example a black-box library call) and instrumenting these operations presents a challenge. Sometimes the best that can be done is adding the instrumentation point at the completion of the operation, and simply accept the "bursty" nature of this approach. In these problematic cases, the work completed in one sampling-interval may have begun several intervals before, from the point of view of the monitoring tool, which can lead to misleading results.
				</div><div class="para">
					One technique that is available to combat this is through use of the MMV_TYPE_ELAPSED metric type, which provides the concept of a "timed section" of code. This mechanism stores the start time of an operation along with the mapped metric value (an "elapsed time" counter), via the <code class="command">mmv_stats_interval_start</code> instrumentation function. Then, with help from the MMV PMDA which recognizes this type, the act of sampling the metric value causes an <span class="bold bold"><strong>interim</strong></span> timestamp to be taken (by the MMV PMDA, not the application) and <span class="bold bold"><strong>combined</strong></span> with the initial timestamp to form a more accurate reflection of time spent within the timed section, which effectively smooths out the bursty nature of the instrumentation.
				</div><div class="para">
					The completion of each timed section of code is marked by a call to <code class="command">mmv_stats_interval_end</code> which signifies to the MMV PMDA that the operation is not active, and no extra "in-progress" time should be applied to the exported value. At that time, the elapsed time for the entire operation is calculated and accounted toward metrics value.
				</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5213106">
      ⁠</a>4.5. Performance Instrumentation and Tracing</h2></div></div></div><div class="para">
				<a id="IG31340177466" class="indexterm"></a> <a id="IG31340177467" class="indexterm"></a> <a id="IG31340177468" class="indexterm"></a>The <code class="filename">pcp_trace</code> library provides function calls for identifying sections of a program as transactions or events for examination by the trace PMDA, a user command called <code class="command">pmdatrace</code>. The <code class="filename">pcp_trace</code> library is described in the <code class="command">pmdatrace(3)</code> man page
			</div><div class="para">
				The monitoring of transactions using the Performance Co-Pilot (PCP) infrastructure begins with a <code class="command">pmtracebegin</code> call. Time is recorded from there to the corresponding <code class="command">pmtraceend</code> call (with matching tag identifier). A transaction in progress can be cancelled by calling <code class="command">pmtraceabort</code>.
			</div><div class="para">
				A second form of program instrumentation is available with the <code class="command">pmtracepoint</code> function. This is a simpler form of monitoring that exports only the number of times a particular point in a program is passed. The <code class="command">pmtraceobs</code> and <code class="command">pmtracecount</code> functions have similar semantics, but the former allows an arbitrary numeric value to be passed to the trace PMDA.
			</div><div class="para">
				<a id="IG31340177469" class="indexterm"></a>The <code class="command">pmdatrace</code> command is a PMDA that exports transaction performance metrics from application processes using the <code class="filename">pcp_trace</code> library; see the <code class="command">pmdatrace(1)</code> man page for details.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="id5213287">
      ⁠</a>4.6. Trace PMDA Design</h2></div></div></div><div class="para">
				<a id="IG31340177470" class="indexterm"></a>Trace PMDA design covers application interaction, sampling techniques, and configuring the trace PMDA.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5213308">
      ⁠</a>4.6.1. Application Interaction</h3></div></div></div><div class="para">
					<a id="IG31340177471" class="indexterm"></a> <a class="xref" href="#id5213335">Figure 4.3, “Trace PMDA Overview”</a> describes the general state maintained within the trace PMDA.
				</div><div class="para">
					<div class="figure"><a id="id5213335">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><object data="images/trace.svg" type="image/svg+xml"><img src="images/trace.png" alt="Trace PMDA Overview" /></object></div></div><p class="title"><strong>Figure 4.3. Trace PMDA Overview</strong></p></div>

				</div><div class="para">
					<a id="IG31340177472" class="indexterm"></a> <a id="IG31340177473" class="indexterm"></a> <a id="IG31340177474" class="indexterm"></a>Applications that are linked with the <code class="filename">libpcp_trace</code> library make calls through the trace Application Programming Interface (API). These calls result in interprocess communication of trace data between the application and the trace PMDA. This data consists of an identification tag and the performance data associated with that particular tag. The trace PMDA aggregates the incoming information and periodically updates the exported summary information to describe activity in the recent past.
				</div><div class="para">
					<a id="IG31340177475" class="indexterm"></a> <a id="IG31340177476" class="indexterm"></a>As each protocol data unit (PDU) is received, its data is stored in the current working buffer. At the same time, the global counter associated with the particular tag contained within the PDU is incremented. The working buffer contains all performance data that has arrived since the previous time interval elapsed. For additional information about the working buffer, see <a class="xref" href="#LE42586-PARENT">Section 4.6.2.2, “Rolling-Window Periodic Sampling”</a>.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5213449">
      ⁠</a>4.6.2. Sampling Techniques</h3></div></div></div><div class="para">
					<a id="IG31340177477" class="indexterm"></a> <a id="IG31340177478" class="indexterm"></a>The trace PMDA employs a rolling-window periodic sampling technique. The arrival time of the data at the trace PMDA in conjunction with the length of the sampling period being maintained by the PMDA determines the recency of the data exported by the PMDA. Through the use of rolling-window sampling, the trace PMDA is able to present a more accurate representation of the available trace data at any given time than it could through use of simple periodic sampling.
				</div><div class="para">
					<a id="IG31340177479" class="indexterm"></a> <a id="IG31340177480" class="indexterm"></a> <a id="IG31340177481" class="indexterm"></a> <a id="IG31340177482" class="indexterm"></a> <a id="IG31340177483" class="indexterm"></a> <a id="IG31340177484" class="indexterm"></a>The rolling-window sampling technique affects the metrics in <a class="xref" href="#Z976568222sdc">Example 4.6, “Rolling-Window Sampling Technique”</a>:
				</div><div class="example"><a id="Z976568222sdc">
      ⁠</a><p class="title"><strong>Example 4.6. Rolling-Window Sampling Technique</strong></p><div class="example-contents"><pre class="literallayout">trace.observe.rate
trace.counter.rate
trace.point.rate
trace.transact.ave_time
trace.transact.max_time
trace.transact.min_time
trace.transact.rate</pre></div></div><div class="para">
					The remaining metrics are either global counters, control metrics, or the last seen observation value. <a class="xref" href="#LE26087-PARENT">Section 4.7, “Trace API”</a>, documents in more detail all metrics exported by the trace PMDA.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5213576">
      ⁠</a>4.6.2.1. Simple Periodic Sampling</h4></div></div></div><div class="para">
						<a id="IG31340177485" class="indexterm"></a> <a id="IG31340177486" class="indexterm"></a> <a id="IG31340177487" class="indexterm"></a>The simple periodic sampling technique uses a single historical buffer to store the history of events that have occurred over the sampling interval. As events occur, they are recorded in the working buffer. At the end of each sampling interval, the working buffer (which at that time holds the historical data for the sampling interval just finished) is copied into the historical buffer, and the working buffer is cleared. It is ready to hold new events from the sampling interval now starting.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="LE42586-PARENT">
      ⁠</a>4.6.2.2. Rolling-Window Periodic Sampling</h4></div></div></div><div class="para">
						<a id="IG31340177488" class="indexterm"></a>In contrast to simple periodic sampling with its single historical buffer, the rolling-window periodic sampling technique maintains a number of separate buffers. One buffer is marked as the current working buffer, and the remainder of the buffers hold historical data. As each event occurs, the current working buffer is updated to reflect it.
					</div><div class="para">
						At a specified interval, the current working buffer and the accumulated data that it holds is moved into the set of historical buffers, and a new working buffer is used. The specified interval is a function of the number of historical buffers maintained.
					</div><div class="para">
						The primary advantage of the rolling-window sampling technique is seen at the point where data is actually exported. At this point, the data has a higher probability of reflecting a more recent sampling period than the data exported using simple periodic sampling.
					</div><div class="para">
						<a id="IG31340177489" class="indexterm"></a>The data collected over each sample duration and exported using the rolling-window sampling technique provides a more up-to-date representation of the activity during the most recently completed sample duration than simple periodic sampling as shown in <a class="xref" href="#id5213739">Figure 4.4, “Sample Duration Comparison”</a>.
					</div><div class="para">
						<div class="figure"><a id="id5213739">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><object data="images/trace-sampling.svg" type="image/svg+xml"><img src="images/trace-sampling.png" alt="Sample Duration Comparison" /></object></div></div><p class="title"><strong>Figure 4.4. Sample Duration Comparison</strong></p></div>

					</div><div class="para">
						<a id="IG31340177490" class="indexterm"></a>The trace PMDA allows the length of the sample duration to be configured, as well as the number of historical buffers that are maintained. The rolling-window approach is implemented in the trace PMDA as a ring buffer (see <a class="xref" href="#id5213335">Figure 4.3, “Trace PMDA Overview”</a>).
					</div><div class="para">
						<a id="IG31340177491" class="indexterm"></a> <a id="IG31340177492" class="indexterm"></a>When the current working buffer is moved into the set of historical buffers, the least recent historical buffer is cleared of data and becomes the new working buffer.
					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id5213803">
      ⁠</a>4.6.2.3. Rolling-Window Periodic Sampling Example</h4></div></div></div><div class="para">
						<a id="IG31340177493" class="indexterm"></a>Consider the scenario where you want to know the rate of transactions over the last 10 seconds. You set the sampling rate for the trace PMDA to 10 seconds and fetch the metric <code class="literal">trace.transact.rate</code>. So if in the last 10 seconds, 8 transactions took place, the transaction rate would be 8/10 or 0.8 transactions per second.
					</div><div class="para">
						The trace PMDA does not actually do this. It instead does its calculations automatically at a subinterval of the sampling interval. Reconsider the 10-second scenario. It has a calculation subinterval of 2 seconds as shown in <a class="xref" href="#id5213848">Figure 4.5, “Sampling Intervals”</a>.
					</div><div class="para">
						<div class="figure"><a id="id5213848">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><object data="images/trace-example.svg" type="image/svg+xml"><img src="images/trace-example.png" alt="Sampling Intervals" /></object></div></div><p class="title"><strong>Figure 4.5. Sampling Intervals</strong></p></div>

					</div><div class="para">
						If at 13.5 seconds, you request the transaction rate, you receive a value of 0.7 transactions per second. In actual fact, the transaction rate was 0.8, but the trace PMDA did its calculations on the sampling interval from 2 seconds to 12 seconds, and not from 3.5 seconds to 13.5 seconds. For efficiency, the trace PMDA calculates the metrics on the last 10 seconds every 2 seconds. As a result, the PMDA is not driven each time a fetch request is received to do a calculation.
					</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5213903">
      ⁠</a>4.6.3. Configuring the Trace PMDA</h3></div></div></div><div class="para">
					<a id="IG31340177494" class="indexterm"></a>The trace PMDA is configurable primarily through command-line options. The list of command-line options in <a class="xref" href="#id5213936">Table 4.1, “Selected Command-Line Options”</a> is not exhaustive, but it identifies those options which are particularly relevant to tuning the manner in which performance data is collected.
				</div><div class="table"><a id="id5213936">
      ⁠</a><p class="title"><strong>Table 4.1. Selected Command-Line Options</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="Selected Command-Line Options"><colgroup><col width="38%" /><col width="62%" /></colgroup><thead><tr valign="top"><th align="left" valign="bottom"> <div class="para">
									Option
								</div>
								 </th><th align="left" valign="bottom"> <div class="para">
									Description
								</div>
								 </th></tr></thead><tbody><tr valign="top"><td align="left" valign="top"> <div class="para">
									Access controls<a id="IG31340177495" class="indexterm"></a>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The trace PMDA offers host-based access control. This control allows and disallows connections from instrumented applications running on specified hosts or groups of hosts. Limits to the number of connections allowed from individual hosts can also be mandated.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									Sample duration<a id="IG31340177496" class="indexterm"></a>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The interval over which metrics are to be maintained before being discarded is called the sample duration.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									Number of historical buffers<a id="IG31340177497" class="indexterm"></a>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The data maintained for the sample duration is held in a number of internal buffers within the trace PMDA. These are referred to as historical buffers. This number is configurable so that the rolling window effect can be tuned within the sample duration.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									Counter and observation metric units<a id="IG31340177498" class="indexterm"></a>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<a id="IG31340177499" class="indexterm"></a> Since the data being exported by the <code class="literal">trace.observe.value</code> and <code class="literal">trace.counter.count</code> metrics are user-defined, the trace PMDA by default exports these metrics with a type of “none.” A framework is provided that allows the user to make the type more specific (for example, bytes per second) and allows the exported values to be plotted along with other performance metrics of similar units by tools like <code class="command">pmchart</code>.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									Instance domain refresh<a id="IG31340177500" class="indexterm"></a>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The set of instances exported for each of the <code class="literal">trace</code> metrics can be cleared through the storable <code class="literal"><a id="IG31340177501" class="indexterm"></a> trace.control.reset</code> metric.
								</div>
								 </td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="LE26087-PARENT">
      ⁠</a>4.7. Trace API</h2></div></div></div><div class="para">
				<a id="IG31340177502" class="indexterm"></a> <a id="IG31340177503" class="indexterm"></a>The <code class="filename">libpcp_trace</code> Application Programming Interface (API) is called from C, C++, Fortran, and Java. Each language has access to the complete set of functionality offered by <code class="filename">libpcp_trace</code>. In some cases, the calling conventions differ slightly between languages. This section presents an overview of each of the different tracing mechanisms offered by the API, as well as an explanation of their mappings to the actual performance metrics exported by the trace PMDA.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5214320">
      ⁠</a>4.7.1. Transactions </h3></div></div></div><div class="para">
					<a id="IG31340177504" class="indexterm"></a> <a id="IG31340177505" class="indexterm"></a> <a id="IG31340177506" class="indexterm"></a> <a id="IG31340177507" class="indexterm"></a>Paired calls to the <code class="command">pmtracebegin</code> and <code class="command">pmtraceend</code> API functions result in transaction data being sent to the trace PMDA with a measure of the time interval between the two calls. This interval is the transaction service time. Using the <code class="command">pmtraceabort</code> call causes data for that particular transaction to be discarded. The trace PMDA exports transaction data through the following <code class="literal">trace.transact</code> metrics listed in <a class="xref" href="#id5214410">Table 4.2, “ <code class="literal">trace.transact</code> Metrics”</a>:
				</div><div class="table"><a id="id5214410">
      ⁠</a><p class="title"><strong>Table 4.2.  <code class="literal">trace.transact</code> Metrics</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary=" trace.transact Metrics"><colgroup><col width="44%" /><col width="56%" /></colgroup><thead><tr valign="top"><th align="left" valign="bottom"> <div class="para">
									Metric
								</div>
								 </th><th align="left" valign="bottom"> <div class="para">
									Description
								</div>
								 </th></tr></thead><tbody><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal"> <a id="IG31340177508" class="indexterm"></a> trace.transact.ave_time</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The average service time per transaction type. This time is calculated over the last sample duration.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal"> <a id="IG31340177509" class="indexterm"></a> trace.transact.count</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The running count for each transaction type seen since the trace PMDA started.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal"> <a id="IG31340177510" class="indexterm"></a> trace.transact.max_time</code>
								</div>
								 <div class="para">
									<code class="literal"></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The maximum service time per transaction type within the last sample duration.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal"> <a id="IG31340177511" class="indexterm"></a> trace.transact.min_time</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The minimum service time per transaction type within the last sample duration.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal"> <a id="IG31340177512" class="indexterm"></a> trace.transact.rate</code>
								</div>
								 <div class="para">
									 
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The average rate at which each transaction type is completed. The rate is calculated over the last sample duration.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal"> <a id="IG31340177513" class="indexterm"></a> trace.transact.total_time</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The cumulative time spent processing each transaction since the trace PMDA started running.
								</div>
								 </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5214714">
      ⁠</a>4.7.2. Point Tracing </h3></div></div></div><div class="para">
					<a id="IG31340177514" class="indexterm"></a> <a id="IG31340177515" class="indexterm"></a>Point tracing allows the application programmer to export metrics related to salient events. The <code class="command">pmtracepoint</code> function is most useful when start and end points are not well defined. For example, this function is useful when the code branches in such a way that a transaction cannot be clearly identified, or when processing does not follow a transactional model, or when the desired instrumentation is akin to event rates rather than event service times. This data is exported through the <code class="literal">trace.point</code> metrics listed in <a class="xref" href="#id5214762">Table 4.3, “<code class="literal">trace.point</code> Metrics”</a>:
					<div class="table"><a id="id5214762">
      ⁠</a><p class="title"><strong>Table 4.3. <code class="literal">trace.point</code> Metrics</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="trace.point Metrics"><colgroup><col width="38%" /><col width="62%" /></colgroup><thead><tr valign="top"><th align="left" valign="bottom">
									<div class="para">
										Metric
									</div>
									</th><th align="left" valign="bottom">
									<div class="para">
										Description
									</div>
									</th></tr></thead><tbody><tr valign="top"><td align="left" valign="top">
									<div class="para">
										<code class="literal">trace.point.count<a id="IG31340177516" class="indexterm"></a></code>
									</div>
									</td><td align="left" valign="top">
									<div class="para">
										Running count of point observations for each tag seen since the trace PMDA started.
									</div>
									</td></tr><tr valign="top"><td align="left" valign="top">
									<div class="para">
										<code class="literal">trace.point.rate<a id="IG31340177517" class="indexterm"></a></code>
									</div>
									</td><td align="left" valign="top">
									<div class="para">
										The average rate at which observation points occur for each tag within the last sample duration.
									</div>
									</td></tr></tbody></table></div></div>
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5214931">
      ⁠</a>4.7.3. Observations and Counters</h3></div></div></div><div class="para">
					<a id="IG31340177518" class="indexterm"></a> <a id="IG31340177519" class="indexterm"></a> <a id="IG31340177520" class="indexterm"></a>The <code class="command">pmtraceobs</code> and <code class="command">pmtracecount</code> functions have similar semantics to <code class="command">pmtracepoint</code>, but also allow an arbitrary numeric value to be passed to the trace PMDA. The most recent value for each tag is then immediately available from the PMDA. Observation data is exported through the <code class="literal">trace.observe</code> metrics listed in <a class="xref" href="#id5215021">Table 4.4, “ <code class="literal">trace.observe</code> Metrics”</a>:
				</div><div class="table"><a id="id5215021">
      ⁠</a><p class="title"><strong>Table 4.4.  <code class="literal">trace.observe</code> Metrics</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary=" trace.observe Metrics"><colgroup><col width="38%" /><col width="62%" /></colgroup><thead><tr valign="top"><th align="left" valign="bottom"> <div class="para">
									Metric
								</div>
								 </th><th align="left" valign="bottom"> <div class="para">
									Description
								</div>
								 </th></tr></thead><tbody><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">trace.observe.count</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Running count of observations seen since the trace PMDA started.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">trace.observe.rate</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The average rate at which observations for each tag occur. This rate is calculated over the last sample duration.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">trace.observe.value</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The numeric value associated with the observation last seen by the trace PMDA.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">trace.counter</code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Counter data is exported through the <code class="literal">trace.counter</code> metrics. The only difference between <code class="literal">trace.counter</code> and <code class="literal">trace.observe</code> metrics is that the numeric value of <code class="literal">trace.counter</code> must be a monotonic increasing count.
								</div>
								 </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id5215241">
      ⁠</a>4.7.4. Configuring the Trace Library</h3></div></div></div><div class="para">
					<a id="IG31340177521" class="indexterm"></a> <a id="IG31340177522" class="indexterm"></a> <a id="IG31340177523" class="indexterm"></a> <a id="IG31340177524" class="indexterm"></a>The trace library is configurable through the use of environment variables listed in <a class="xref" href="#id5215299">Table 4.5, “Environment Variables”</a> as well as through the state flags listed in <a class="xref" href="#id5215745">Table 4.6, “State Flags”</a>. Both provide diagnostic output and enable or disable the configurable functionality within the library.
				</div><div class="table"><a id="id5215299">
      ⁠</a><p class="title"><strong>Table 4.5. Environment Variables</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="Environment Variables"><colgroup><col width="38%" /><col width="62%" /></colgroup><thead><tr valign="top"><th align="left" valign="bottom"> <div class="para">
									Name
								</div>
								 </th><th align="left" valign="bottom"> <div class="para">
									Description
								</div>
								 </th></tr></thead><tbody><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">PCP_TRACE_HOST</code> <a id="IG31340177525" class="indexterm"></a>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The name of the host where the trace PMDA is running.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">PCP_TRACE_PORT</code> <a id="IG31340177526" class="indexterm"></a>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<a id="IG31340177527" class="indexterm"></a> TCP/IP port number on which the trace PMDA is accepting client connections.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">PCP_TRACE_TIMEOUT</code> <a id="IG31340177528" class="indexterm"></a>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The number of seconds to wait until assuming that the initial connection is not going to be made, and timeout will occur. The default is three seconds.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">PCP_TRACE_REQTIMEOUT</code> <a id="IG31340177529" class="indexterm"></a>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<a id="IG31340177530" class="indexterm"></a> The number of seconds to allow before timing out on awaiting acknowledgment from the trace PMDA after trace data has been sent to it. This variable has no effect in the asynchronous trace protocol (refer to <a class="xref" href="#id5215745">Table 4.6, “State Flags”</a>).
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">PCP_TRACE_RECONNECT</code> <a id="IG31340177531" class="indexterm"></a>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									A list of values which represents the backoff approach that the <code class="filename">libpcp_trace</code> library routines take when attempting to reconnect to the trace PMDA after a connection has been lost. The list of values should be a positive number of seconds for the application to delay before making the next reconnection attempt. When the final value in the list is reached, that value is used for all subsequent reconnection attempts.
								</div>
								 </td></tr></tbody></table></div></div><div class="para">
					<a id="IG31340177532" class="indexterm"></a> <a id="IG31340177533" class="indexterm"></a> <a id="IG31340177534" class="indexterm"></a> <a id="IG31340177535" class="indexterm"></a>The <a class="xref" href="#id5215745">Table 4.6, “State Flags”</a> are used to customize the operation of the <code class="filename">libpcp_trace</code> routines. These are registered through the <code class="command">pmtracestate</code> call, and they can be set either individually or together.
				</div><div class="table"><a id="id5215745">
      ⁠</a><p class="title"><strong>Table 4.6. State Flags</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-7-rows" summary="State Flags"><colgroup><col width="43%" /><col width="57%" /></colgroup><thead><tr valign="top"><th align="left" valign="bottom"> <div class="para">
									Flag
								</div>
								 </th><th align="left" valign="bottom"> <div class="para">
									Description
								</div>
								 </th></tr></thead><tbody><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">PMTRACE_STATE_NONE<a id="IG31340177536" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<a id="IG31340177537" class="indexterm"></a> The default. No state flags have been set, the fault-tolerant, synchronous protocol is used for communicating with the trace PMDA, and no diagnostic messages are displayed by the <code class="filename"></code><code class="filename">libpcp_trace</code> routines.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">PMTRACE_STATE_API<a id="IG31340177538" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									High-level diagnostics. This flag simply displays entry into each of the API routines.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">PMTRACE_STATE_COMMS<a id="IG31340177539" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									Diagnostic messages related to establishing and maintaining the communication channel between application and PMDA.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">PMTRACE_STATE_PDU<a id="IG31340177540" class="indexterm"></a> <a id="IG31340177541" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<a id="IG31340177542" class="indexterm"></a> The low-level details of the trace protocol data units (PDU) is displayed as each PDU is transmitted or received.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">PMTRACE_STATE_PDUBUF<a id="IG31340177543" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									The full contents of the PDU buffers are dumped as PDUs are transmitted and received.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">PMTRACE_STATE_NOAGENT<a id="IG31340177544" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<a id="IG31340177545" class="indexterm"></a> <a id="IG31340177546" class="indexterm"></a> Interprocess communication control. If this flag is set, it causes interprocess communication between the instrumented application and the trace PMDA to be skipped. This flag is a debugging aid for applications using <code class="filename">libpcp_trace</code>.
								</div>
								 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
									<code class="literal">PMTRACE_STATE_ASYNC<a id="IG31340177547" class="indexterm"></a></code>
								</div>
								 </td><td align="left" valign="top"> <div class="para">
									<a id="IG31340177548" class="indexterm"></a> <a id="IG31340177549" class="indexterm"></a> Asynchronous trace protocol. This flag enables the asynchronous trace protocol so that the application does not block awaiting acknowledgment PDUs from the trace PMDA. In order for the flag to be effective, it must be set before using the other <code class="filename"></code><code class="filename">libpcp_trace</code> entry points.
								</div>
								 </td></tr></tbody></table></div></div></div></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a id="LE54271-PARENT">
      ⁠</a>Appendix A. Acronyms</h1></div></div></div><div class="para">
			<a class="xref" href="#id5216717">Table A.1, “Performance Co-Pilot Acronyms and Their Meanings”</a> provides a glossary of the acronyms used in the Performance Co-Pilot (PCP) documentation, help cards, man pages, and user interface.<a id="IG31340177566" class="indexterm"></a><a id="IG31340177567" class="indexterm"></a>
		</div><div class="table"><a id="id5216717">
      ⁠</a><p class="title"><strong>Table A.1. Performance Co-Pilot Acronyms and Their Meanings</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-7-rows" summary="Performance Co-Pilot Acronyms and Their Meanings"><colgroup><col width="23%" /><col width="77%" /></colgroup><thead><tr valign="top"><th align="left" valign="bottom"> <div class="para">
							Acronym
						</div>
						 </th><th align="left" valign="bottom"> <div class="para">
							Meaning
						</div>
						 </th></tr></thead><tbody><tr valign="top"><td align="left" valign="top"> <div class="para">
							API
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Application Programming Interface
						</div>
						 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
							DBMS
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Database Management System
						</div>
						 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
							<a id="IG31340177568" class="indexterm"></a> DNS
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Domain Name Service
						</div>
						 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
							<a id="IG31340177569" class="indexterm"></a> DSO
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Dynamic Shared Object
						</div>
						 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
							I/O
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Input/Output
						</div>
						 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
							IPC
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Interprocess Communication
						</div>
						 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
							<a id="IG31340177570" class="indexterm"></a> PCP
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Performance Co-Pilot
						</div>
						 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
							<a id="IG31340177571" class="indexterm"></a> PDU
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Protocol data unit
						</div>
						 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
							<a id="IG31340177572" class="indexterm"></a> PMAPI
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Performance Metrics Application Programming Interface
						</div>
						 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
							<a id="IG31340177573" class="indexterm"></a> PMCD
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Performance Metrics Collection Daemon
						</div>
						 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
							<a id="IG31340177575" class="indexterm"></a> PMDA
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Performance Metrics Domain Agent
						</div>
						 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
							<a id="IG31340177576" class="indexterm"></a> PMID
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Performance Metric Identifier
						</div>
						 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
							<a id="IG31340177577" class="indexterm"></a> PMNS
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Performance Metrics Name Space
						</div>
						 </td></tr><tr valign="top"><td align="left" valign="top"> <div class="para">
							<a id="IG31340177578" class="indexterm"></a> TCP/IP
						</div>
						 </td><td align="left" valign="top"> <div class="para">
							Transmission Control Protocol/Internet Protocol
						</div>
						 </td></tr></tbody></table></div></div></div><div class="index"><div class="titlepage"><div><div><h1 class="title"><a id="sgi-index">
      ⁠</a>Index</h1></div></div></div><dl><dt>__pmID_int structure <a class="link" href="#IG31340177121">Data Structures</a></dt><dd></dd><dt>__pmInDom_int structure <a class="link" href="#IG31340177141">Data Structures</a></dt><dd></dd><dt>access controls <a class="link" href="#IG31340177495">Configuring the Trace PMDA</a></dt><dd></dd><dt>acronyms <a class="link" href="#IG31340177567">Acronyms</a></dt><dd></dd><dt>ancillary support services <a class="link" href="#IG31340177417">PMAPI Ancillary Support Services</a></dt><dd></dd><dt>Application Programming Interface <a class="link" href="#IG31340177257">PMAPI--The Performance Metrics API</a> <a class="link" href="#IG31340177502nat">Memory Mapped Values API</a> <a class="link" href="#IG31340177502">Trace API</a> <a class="link" href="#IG31340177472">Application Interaction</a> <a class="link" href="#IG31340177502">Trace API</a></dt><dd></dd><dt>application developers<a class="link" href="#IG31340177554">Instrumenting Applications</a></dt><dd></dd><dt>application programs <a class="link" href="#ITch01-114">Application and Agent Development</a></dt><dd></dd><dt>applications</dt><dd><dl><dt>compiling <a class="link" href="#IG31340177460">Compiling and Linking PMAPI Applications</a></dt><dd></dd></dl><dl><dt>instrumentation <a class="link" href="#IG31340177550">Application and PCP Relationship</a></dt><dd></dd></dl><dl><dt>interaction <a class="link" href="#IG31340177471">Application Interaction</a></dt><dd></dd></dl></dd><dt>architecture <a class="link" href="#IG313401778">PCP Architecture</a> <a class="link" href="#IG3134017777">PMDA Architecture</a></dt><dd></dd><dt>archive logs</dt><dd><dl><dt>context services <a class="link" href="#IG31340177347">PMAPI Context Services</a></dt><dd></dd></dl><dl><dt>performance data <a class="link" href="#IG31340177258">PMAPI--The Performance Metrics API</a> <a class="link" href="#IG31340177266">Current PMAPI Context</a></dt><dd></dd></dl><dl><dt>performance management <a class="link" href="#IG31340177562">Application and PCP Relationship</a></dt><dd></dd></dl><dl><dt>pmGetArchiveEnd function <a class="link" href="#IG31340177402"><code class="command">pmGetArchiveEnd</code> Function</a></dt><dd></dd></dl><dl><dt>pmGetInDomArchive function <a class="link" href="#IG31340177405"><code class="command">pmGetInDomArchive</code> Function</a></dt><dd></dd></dl><dl><dt>retrospective sources <a class="link" href="#IG3134017731">Retrospective Sources of Performance Metrics</a></dt><dd></dd></dl><dl><dt>time control services <a class="link" href="#IG31340177415">PMAPI Time Control Services</a></dt><dd></dd></dl></dd><dt>archive-specific services <a class="link" href="#IG31340177401"><code class="command">pmGetArchiveLabel</code> Function</a></dt><dd></dd><dt>Cluster PMDA <a class="link" href="#IG3134017717">Distributed Collection</a></dt><dd></dd><dt>arrays</dt><dd><dl><dt>instance description <a class="link" href="#IG31340177140">Data Structures</a></dt><dd></dd></dl><dl><dt>N dimensional data <a class="link" href="#IG31340177134">N Dimensional Data</a></dt><dd></dd></dl><dl><dt>performance metrics <a class="link" href="#IG31340177278">Performance Metrics Values</a> <a class="link" href="#IG31340177283">Variable Length Argument and Results Lists</a></dt><dd></dd></dl></dd><dt>asynchronous trace protocol <a class="link" href="#IG31340177530">Configuring the Trace Library</a> <a class="link" href="#IG31340177548">Configuring the Trace Library</a></dt><dd></dd><dt>audience <a class="link" href="#IG313401772">Programming Performance Co-Pilot</a></dt><dd></dd><dt>automated alarms <a class="link" href="#IG31340177563">Application and PCP Relationship</a></dt><dd></dd><dt>caching PMDA <a class="link" href="#IG31340177106">Caching PMDA</a> <a class="link" href="#IG31340177153">Latency and Threads of Control</a></dt><dd></dd><dt>chkhelp tool <a class="link" href="#IG3134017735">Application and Agent Development</a></dt><dd></dd><dt>Cisco PMDA <a class="link" href="#IG3134017716">Distributed Collection</a> <a class="link" href="#IG31340177107">Caching PMDA</a></dt><dd></dd><dt>client development <a class="link" href="#IG3134017752">Client Development and PMAPI</a></dt><dd></dd><dt>clusters <a class="link" href="#IG3134017725">Name Space</a></dt><dd></dd><dt>collection time <a class="link" href="#IG31340177267">Current PMAPI Context</a> <a class="link" href="#IG31340177352"><code class="command">pmNewContext</code> Function</a> <a class="link" href="#IG31340177357"><code class="command">pmWhichContext</code> Function</a></dt><dd></dd><dt>collection tools <a class="link" href="#IG3134017712">PCP Architecture</a></dt><dd></dd><dt>collector hosts <a class="link" href="#IG3134017719">Distributed Collection</a></dt><dd></dd><dt>COLOR_INDOM <a class="link" href="#IG31340177143">Data Structures</a></dt><dd></dd><dt>compiling and linking <a class="link" href="#IG31340177461">Compiling and Linking PMAPI Applications</a></dt><dd></dd><dt>component software <a class="link" href="#IG3134017733">Overview of Component Software</a></dt><dd></dd><dt>computation state <a class="link" href="#IG31340177556">Instrumenting Applications</a></dt><dd></dd><dt>configuration <a class="link" href="#IG31340177521">Configuring the Trace Library</a> <a class="link" href="#IG31340177251">Configuring PCP Tools</a></dt><dd></dd><dt>context services <a class="link" href="#IG31340177320">PMAPI Context Services</a></dt><dd></dd><dt>control threads <a class="link" href="#IG31340177150">Latency and Threads of Control</a></dt><dd></dd><dt>counter semantics <a class="link" href="#IG31340177131">Semantics</a></dt><dd></dd><dt>customization <a class="link" href="#IG313401777">Programming Performance Co-Pilot</a> <a class="link" href="#IG31340177565">Instrumenting Applications</a></dt><dd></dd><dt>daemon process method <a class="link" href="#IG3134017750">Daemon Process Method</a></dt><dd></dd><dt>data export <a class="link" href="#IG31340177552">Application and PCP Relationship</a></dt><dd></dd><dt>data structures <a class="link" href="#IG31340177118">Data Structures</a> <a class="link" href="#IG31340177137">Data Structures</a></dt><dd></dd><dt>dbpmda man page <a class="link" href="#IG3134017768">Implementing a PMDA</a> <a class="link" href="#IG31340177229">Overview</a> <a class="link" href="#IG31340177236"><code class="command">dbpmda</code> Debug Utility</a></dt><dd></dd><dt>dbx man page <a class="link" href="#IG31340177228">Overview</a></dt><dd></dd><dt>debugging and testing <a class="link" href="#IG31340177227">Testing and Debugging a PMDA</a> <a class="link" href="#IG31340177546">Configuring the Trace Library</a></dt><dd></dd><dt>debugging flags</dt><dd><dt>(see flags)</dt></dd><dt>delays <a class="link" href="#IG31340177151">Latency and Threads of Control</a></dt><dd></dd><dt>design requirements <a class="link" href="#IG3134017761">Implementing a PMDA</a></dt><dd></dd><dt>diagnostic output <a class="link" href="#IG31340177524">Configuring the Trace Library</a></dt><dd></dd><dt>dimensionality and scale <a class="link" href="#IG31340177272">Performance Metric Descriptions</a></dt><dd></dd><dt>discrete semantics <a class="link" href="#IG31340177133">Semantics</a></dt><dd></dd><dt>distributed performance management</dt><dd><dl><dt>data transportation <a class="link" href="#IG31340177561">Application and PCP Relationship</a></dt><dd></dd></dl><dl><dt>metrics collection <a class="link" href="#IG3134017715">Distributed Collection</a></dt><dd></dd></dl></dd><dt>dlopen man page <a class="link" href="#IG3134017746">In-Process (DSO) Method</a> <a class="link" href="#IG3134017796">DSO PMDA</a></dt><dd></dd><dt>DNS <a class="link" href="#IG31340177568">Acronyms</a></dt><dd></dd><dt>domains</dt><dd><dl><dt>definition <a class="link" href="#IG31340177110">Overview</a></dt><dd></dd></dl><dl><dt>fields <a class="link" href="#IG3134017727">Name Space</a></dt><dd></dd></dl><dl><dt>numbers <a class="link" href="#IG31340177113">Domains</a></dt><dd></dd></dl></dd><dt>dometric function <a class="link" href="#IG31340177302"><code class="command">pmTraversePMNS</code> Function</a></dt><dd></dd><dt>DSO <a class="link" href="#IG31340177569">Acronyms</a></dt><dd><dl><dt>architecture <a class="link" href="#IG3134017779">PMDA Architecture</a></dt><dd></dd></dl><dl><dt>disadvantages <a class="link" href="#IG31340177100">Daemon PMDA</a></dt><dd></dd></dl><dl><dt>implementation <a class="link" href="#IG3134017795">DSO PMDA</a></dt><dd></dd></dl><dl><dt>interface <a class="link" href="#IG31340177178">PMDA Interface</a></dt><dd></dd></dl><dl><dt>PMDA building <a class="link" href="#IG3134017745">In-Process (DSO) Method</a></dt><dd></dd></dl><dl><dt>PMDA initialization <a class="link" href="#IG31340177209">Common Initialization</a></dt><dd></dd></dl></dd><dt>dynamic shared object</dt><dd><dt>(see DSO)</dt></dd><dt>embedded calls <a class="link" href="#IG31340177555">Instrumenting Applications</a></dt><dd></dd><dt>environment variables <a class="link" href="#IG31340177522">Configuring the Trace Library</a></dt><dd></dd><dt>error handling <a class="link" href="#IG31340177458">Handling PMAPI Errors</a></dt><dd></dd><dt>examples</dt><dd><dl><dt>alarm tools <a class="link" href="#IG3134017775">Implementing a PMDA</a></dt><dd></dd></dl><dl><dt>Install script <a class="link" href="#IG31340177243">Installing a PMDA</a></dt><dd></dd></dl><dl><dt>MMV PMDA <a class="link" href="#IG31340177465nat">Instrumenting Applications</a></dt><dd></dd></dl><dl><dt>programming issues <a class="link" href="#IG31340177445">PMAPI Programming Issues and Examples</a></dt><dd></dd></dl><dl><dt>Remove script <a class="link" href="#IG31340177249">Removing a PMDA</a></dt><dd></dd></dl><dl><dt>rolling-window sampling <a class="link" href="#IG31340177493">Rolling-Window Periodic Sampling Example</a></dt><dd></dd></dl><dl><dt>simple and trivial PMDAs <a class="link" href="#IG31340177109">Domains, Metrics, and Instances</a></dt><dd></dd></dl><dl><dt>time control functions <a class="link" href="#IG31340177416">PMAPI Time Control Services</a></dt><dd></dd></dl><dl><dt>trace PMDA <a class="link" href="#IG31340177465">Instrumenting Applications</a></dt><dd></dd></dl><dl><dt>visualization tools <a class="link" href="#IG3134017774">Implementing a PMDA</a></dt><dd></dd></dl></dd><dt>execv system call <a class="link" href="#IG31340177102">Daemon PMDA</a></dt><dd></dd><dt>exporting data <a class="link" href="#IG31340177147">Extracting the Information</a></dt><dd></dd><dt>flags</dt><dd><dl><dt>debugging <a class="link" href="#IG31340177233">Debugging Information</a></dt><dd></dd></dl><dl><dt>state <a class="link" href="#IG31340177533">Configuring the Trace Library</a></dt><dd></dd></dl></dd><dt>fork system call <a class="link" href="#IG31340177101">Daemon PMDA</a></dt><dd></dd><dt>glossary <a class="link" href="#IG31340177566">Acronyms</a></dt><dd></dd><dt>handle context <a class="link" href="#IG31340177375"><code class="command">pmReconnectContext</code> Function</a></dt><dd></dd><dt>help text</dt><dd><dl><dt>creation <a class="link" href="#IG31340177241">Installing a PMDA</a></dt><dd></dd></dl><dl><dt>initialization <a class="link" href="#IG31340177210">Common Initialization</a></dt><dd></dd></dl><dl><dt>location <a class="link" href="#IG31340177239">Installing a PMDA</a></dt><dd></dd></dl><dl><dt>PDU_TEXT_REQ <a class="link" href="#IG3134017792">Overview</a></dt><dd></dd></dl><dl><dt>pmLookupInDomText function <a class="link" href="#IG31340177311"><code class="command">pmLookupInDomText</code> Function</a></dt><dd></dd></dl><dl><dt>pmLookupText function <a class="link" href="#IG31340177169">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177313"><code class="command">pmLookupText</code> Function</a></dt><dd></dd></dl><dl><dt>structure specification <a class="link" href="#IG3134017767">Implementing a PMDA</a></dt><dd></dd></dl><dl><dt>terse and extended descriptions <a class="link" href="#IG31340177158">PMDA Help Text</a></dt><dd></dd></dl></dd><dt>historical buffers <a class="link" href="#IG31340177487">Simple Periodic Sampling</a> <a class="link" href="#IG31340177492">Rolling-Window Periodic Sampling</a> <a class="link" href="#IG31340177497">Configuring the Trace PMDA</a></dt><dd></dd><dt>identification tags <a class="link" href="#IG31340177473">Application Interaction</a></dt><dd></dd><dt>implementation <a class="link" href="#IG3134017760">Implementing a PMDA</a></dt><dd></dd><dt>indom instance domain <a class="link" href="#IG31340177309"><code class="command">pmLookupInDomText</code> Function</a> <a class="link" href="#IG31340177359"><code class="command">pmAddProfile</code> Function</a> <a class="link" href="#IG31340177406"><code class="command">pmGetInDomArchive</code> Function</a></dt><dd></dd><dt>information extraction <a class="link" href="#IG31340177146">Extracting the Information</a></dt><dd></dd><dt>initialization <a class="link" href="#IG31340177451">Initializing New Metrics</a></dt><dd></dd><dt>instance domain refresh <a class="link" href="#IG31340177500">Configuring the Trace PMDA</a></dt><dd></dd><dt>instance domain services <a class="link" href="#IG31340177314"><code class="command">pmGetInDom</code> Function</a></dt><dd></dd><dt>instantaneous semantics <a class="link" href="#IG31340177132">Semantics</a></dt><dd></dd><dt>instlist argument <a class="link" href="#IG31340177315"><code class="command">pmGetInDom</code> Function</a> <a class="link" href="#IG31340177360"><code class="command">pmAddProfile</code> Function</a></dt><dd></dd><dt>instrumentation <a class="link" href="#IG31340177468nat">Performance Instrumentation and Sampling</a> <a class="link" href="#IG31340177468">Performance Instrumentation and Tracing</a> <a class="link" href="#IG31340177551">Application and PCP Relationship</a></dt><dd></dd><dt>integrating a PMDA <a class="link" href="#IG31340177238">Integration of a PMDA</a></dt><dd></dd><dt>internal instance identifier <a class="link" href="#IG31340177277">Performance Metrics Values</a></dt><dd></dd><dt>interpolated metrics <a class="link" href="#IG31340177372"><code class="command">pmSetMode</code> Function</a></dt><dd></dd><dt>interprocess communication</dt><dd><dt>(see IPC)</dt><dl><dt>PMTRACE_STATE_NOAGENT flag <a class="link" href="#IG31340177545">Configuring the Trace Library</a></dt><dd></dd></dl></dd><dt>IPC</dt><dd><dl><dt>DSO <a class="link" href="#IG3134017749">In-Process (DSO) Method</a></dt><dd></dd></dl><dl><dt>PMDA <a class="link" href="#IG3134017765">Implementing a PMDA</a></dt><dd></dd></dl><dl><dt>trace API <a class="link" href="#IG31340177474">Application Interaction</a></dt><dd></dd></dl></dd><dt>item numbers <a class="link" href="#IG3134017726">Name Space</a></dt><dd></dd><dt>iterative processing <a class="link" href="#IG31340177454">Iterative Processing of Values</a></dt><dd></dd><dt>latency <a class="link" href="#IG31340177149">Latency and Threads of Control</a></dt><dd></dd><dt>leaf node <a class="link" href="#IG31340177303"><code class="command">pmTraversePMNS</code> Function</a></dt><dd></dd><dt>libpcp_mmv library</dt><dd><dl><dt>Application Programming Interface <a class="link" href="#IG31340177503nat">Memory Mapped Values API</a></dt><dd></dd></dl><dl><dt>instrumenting applications <a class="link" href="#IG31340177464nat">Instrumenting Applications</a></dt><dd></dd></dl></dd><dt>libpcp_trace library</dt><dd><dl><dt>Application Programming Interface <a class="link" href="#IG31340177503">Trace API</a></dt><dd></dd></dl><dl><dt>entry points <a class="link" href="#IG31340177549">Configuring the Trace Library</a></dt><dd></dd></dl><dl><dt>functions <a class="link" href="#IG31340177535">Configuring the Trace Library</a></dt><dd></dd></dl><dl><dt>instrumenting applications <a class="link" href="#IG31340177464">Instrumenting Applications</a></dt><dd></dd></dl></dd><dt>library reentrancy <a class="link" href="#IG3134017758">Library Reentrancy and Threaded Applications</a></dt><dd></dd><dt>metric description services <a class="link" href="#IG31340177306"><code class="command">pmLookupDesc</code> Function</a></dt><dd></dd><dt>metrics</dt><dd><dl><dt>API <a class="link" href="#IG31340177260">Naming and Identifying Performance Metrics</a></dt><dd></dd></dl><dl><dt>definition <a class="link" href="#IG31340177111">Overview</a> <a class="link" href="#IG31340177114">Metrics</a></dt><dd></dd></dl><dl><dt>name and value <a class="link" href="#IG31340177447">Symbolic Association between a Metric's Name and Value</a></dt><dd></dd></dl></dd><dt>metrics and instances <a class="link" href="#IG31340177112">Overview</a></dt><dd></dd><dt>metrics description services <a class="link" href="#IG31340177305"><code class="command">pmLookupDesc</code> Function</a></dt><dd></dd><dt>metrics services <a class="link" href="#IG31340177384"><code class="command">pmFetch</code> Function</a></dt><dd></dd><dt>mmv_lookup_value_desc function <a class="link" href="#Z1033577633nat">Getting a Handle on Mapped Values</a></dt><dd></dd><dt>mmv_stats_init function <a class="link" href="#IG31340177504nat">Starting and Stopping Instrumentation</a></dt><dd></dd><dt>mmv_stats_stop function <a class="link" href="#IG31340177505nat">Starting and Stopping Instrumentation</a></dt><dd></dd><dt>mmv_stats_inc function <a class="link" href="#Z1033577634nat">Updating Mapped Values</a></dt><dd></dd><dt>mmv_stats_interval_start function <a class="link" href="#Z1033577635nat">Elapsed Time Measures</a></dt><dd></dd><dt>mmv_stats_interval_end function <a class="link" href="#Z1033577636nat">Elapsed Time Measures</a></dt><dd></dd><dt>monitoring tools <a class="link" href="#IG3134017711">PCP Architecture</a></dt><dd></dd><dt>multidimensional arrays <a class="link" href="#IG31340177136">N Dimensional Data</a></dt><dd></dd><dt>multiple threads <a class="link" href="#IG3134017757">Library Reentrancy and Threaded Applications</a></dt><dd></dd><dt>MMV PMDA</dt><dd><dl><dt>description <a class="link" href="#IG31340177462nat">Instrumenting Applications</a></dt><dd></dd></dl><dl><dt>design <a class="link" href="#IG31340177470nat">MMV PMDA Design</a></dt><dd></dd></dl></dd><dt>name space <a class="link" href="#IG3134017722">Name Space</a> <a class="link" href="#IG31340177155">Name Space</a></dt><dd></dd><dt>new metrics <a class="link" href="#IG31340177160">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177452">Initializing New Metrics</a></dt><dd></dd><dt>new PMDA <a class="link" href="#IG31340177244">Upgrading a PMNS to Include Metrics from a New PMDA</a></dt><dd></dd><dt>newhelp man page <a class="link" href="#IG31340177159">PMDA Help Text</a></dt><dd></dd><dt>newhelp tool <a class="link" href="#IG3134017737">Application and Agent Development</a></dt><dd></dd><dt>NOW_INDOM <a class="link" href="#IG31340177144">Data Structures</a></dt><dd></dd><dt>observation metric units <a class="link" href="#IG31340177498">Configuring the Trace PMDA</a></dt><dd></dd><dt>parallelism <a class="link" href="#IG31340177557">Instrumenting Applications</a></dt><dd></dd><dt>PCP</dt><dd><dl><dt>acronym <a class="link" href="#IG31340177570">Acronyms</a></dt><dd></dd></dl><dl><dt>description <a class="link" href="#IG313401770">Programming Performance Co-Pilot</a></dt><dd></dd></dl><dl><dt>tool summaries <a class="link" href="#IG3134017734">Application and Agent Development</a></dt><dd></dd></dl></dd><dt>PCP_TRACE_HOST variable <a class="link" href="#IG31340177525">Configuring the Trace Library</a></dt><dd></dd><dt>PCP_TRACE_PORT variable <a class="link" href="#IG31340177526">Configuring the Trace Library</a></dt><dd></dd><dt>PCP_TRACE_RECONNECT variable <a class="link" href="#IG31340177531">Configuring the Trace Library</a></dt><dd></dd><dt>PCP_TRACE_REQTIMEOUT variable <a class="link" href="#IG31340177529">Configuring the Trace Library</a></dt><dd></dd><dt>PCP_TRACE_TIMEOUT variable <a class="link" href="#IG31340177528">Configuring the Trace Library</a></dt><dd></dd><dt>PDU <a class="link" href="#IG3134017780">Overview</a> <a class="link" href="#IG31340177475">Application Interaction</a> <a class="link" href="#IG31340177542">Configuring the Trace Library</a> <a class="link" href="#IG31340177571">Acronyms</a></dt><dd></dd><dt>PDU_AUTH <a class="link" href="#IG3134017791nat">Overview</a></dt><dd></dd><dt>PDU_DESC_REQ <a class="link" href="#IG3134017789">Overview</a></dt><dd></dd><dt>PDU_FETCH <a class="link" href="#IG3134017783">Overview</a> <a class="link" href="#IG31340177219">Simple PMDA</a></dt><dd></dd><dt>PDU_INSTANCE_REQ <a class="link" href="#IG3134017787">Overview</a></dt><dd></dd><dt>PDU_PMNS_CHILD <a class="link" href="#IG3134017785nat">Overview</a></dt><dd></dd><dt>PDU_PMNS_NAMES <a class="link" href="#IG3134017783nat">Overview</a></dt><dd></dd><dt>PDU_PMNS_TRAVERSE <a class="link" href="#IG3134017787nat">Overview</a></dt><dd></dd><dt>PDU_PMNS_IDS <a class="link" href="#IG3134017789nat">Overview</a></dt><dd></dd><dt>PDU_PROFILE <a class="link" href="#IG3134017785">Overview</a></dt><dd></dd><dt>PDU_RESULT <a class="link" href="#IG3134017794">Overview</a> <a class="link" href="#IG31340177218">Simple PMDA</a></dt><dd></dd><dt>PDU_TEXT_REQ <a class="link" href="#IG3134017791">Overview</a></dt><dd></dd><dt>performance instrumentation <a class="link" href="#IG313401775">Programming Performance Co-Pilot</a> <a class="link" href="#IG31340177467nat">Performance Instrumentation and Sampling</a> <a class="link" href="#IG31340177467">Performance Instrumentation and Tracing</a></dt><dd></dd><dt>Performance Metric Identifier</dt><dd><dt>(see PMID)</dt></dd><dt>performance metrics</dt><dd><dt>(see metrics)</dt></dd><dt>Performance Metrics Application Programming Interface</dt><dd><dt>(see PMAPI)</dt></dd><dt>Performance Metrics Collection Daemon</dt><dd><dt>(see PMCD)</dt></dd><dt>Performance Metrics Domain Agent</dt><dd><dt>(see PMDA)</dt></dd><dt>Performance Metrics Name Space</dt><dd><dt>(see PMNS)</dt></dd><dt>periodic sampling <a class="link" href="#IG31340177485">Simple Periodic Sampling</a></dt><dd></dd><dt>pipe <a class="link" href="#IG31340177103">Daemon PMDA</a> <a class="link" href="#IG31340177104">Daemon PMDA</a></dt><dd></dd><dt>PM_CONTEXT_ARCHIVE type <a class="link" href="#IG31340177348"><code class="command">pmNewContext</code> Function</a></dt><dd></dd><dt>PM_CONTEXT_HOST type <a class="link" href="#IG31340177349"><code class="command">pmNewContext</code> Function</a></dt><dd></dd><dt>PM_ERR_CONV error code <a class="link" href="#IG31340177177">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177422"><code class="command">pmExtractValue</code> Function</a></dt><dd></dd><dt>PM_ERR_INST error code <a class="link" href="#IG31340177197"><code class="literal">simple_store</code> in the Simple PMDA</a></dt><dd></dd><dt>PM_ERR_PMID error code <a class="link" href="#IG31340177167">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177198"><code class="literal">simple_store</code> in the Simple PMDA</a></dt><dd></dd><dt>PM_ERR_SIGN error code <a class="link" href="#IG31340177424"><code class="command">pmExtractValue</code> Function</a></dt><dd></dd><dt>PM_ERR_TIMEOUT error code <a class="link" href="#IG31340177388"><code class="command">pmFetch</code> Function</a></dt><dd></dd><dt>PM_ERR_TRUNC error code <a class="link" href="#IG31340177423"><code class="command">pmExtractValue</code> Function</a></dt><dd></dd><dt>PM_IN_NULL instance identifier <a class="link" href="#IG31340177264">Performance Metric Instances</a></dt><dd></dd><dt>PM_INDOM_NULL instance domain</dt><dd><dl><dt>data structures <a class="link" href="#IG31340177125">Data Structures</a> <a class="link" href="#IG31340177145">Data Structures</a></dt><dd></dd></dl><dl><dt>description <a class="link" href="#IG31340177263">Performance Metric Instances</a></dt><dd></dd></dl><dl><dt>pmAddProfile function <a class="link" href="#IG31340177362"><code class="command">pmAddProfile</code> Function</a></dt><dd></dd></dl><dl><dt>pmDelProfile function <a class="link" href="#IG31340177363"><code class="command">pmDelProfile</code> Function</a></dt><dd></dd></dl></dd><dt>PM_SEM_COUNTER semantic type <a class="link" href="#IG31340177128">Semantics</a></dt><dd></dd><dt>PM_SEM_DISCRETE semantic type <a class="link" href="#IG31340177130">Semantics</a></dt><dd></dd><dt>PM_SEM_INSTANT semantic type <a class="link" href="#IG31340177126">Data Structures</a> <a class="link" href="#IG31340177129">Semantics</a></dt><dd></dd><dt>PM_TYPE_AGGREGATE type <a class="link" href="#IG31340177270">Performance Metric Descriptions</a></dt><dd></dd><dt>PM_TYPE_NOSUPPORT value <a class="link" href="#IG31340177165">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177271">Performance Metric Descriptions</a></dt><dd></dd><dt>PM_TYPE_STRING type <a class="link" href="#IG31340177269">Performance Metric Descriptions</a> <a class="link" href="#IG31340177425"><code class="command">pmExtractValue</code> Function</a></dt><dd></dd><dt>PM_TYPE_EVENT type <a class="link" href="#IG31340177269nat">Performance Metric Descriptions</a></dt><dd></dd><dt>PM_VAL_INSITU value <a class="link" href="#IG31340177279">Performance Metrics Values</a></dt><dd></dd><dt>pmAddProfile function <a class="link" href="#IG3134017784">Overview</a> <a class="link" href="#IG31340177322">PMAPI Context Services</a> <a class="link" href="#IG31340177361"><code class="command">pmAddProfile</code> Function</a></dt><dd></dd><dt>PMAPI <a class="link" href="#IG3134017739">Application and Agent Development</a> <a class="link" href="#IG31340177262">Performance Metric Instances</a></dt><dd><div>(see also metrics)</div><dl><dt>acronym <a class="link" href="#IG31340177572">Acronyms</a></dt><dd></dd></dl><dl><dt>ancillary support services <a class="link" href="#IG31340177418">PMAPI Ancillary Support Services</a></dt><dd></dd></dl><dl><dt>application compiling <a class="link" href="#IG31340177459">Compiling and Linking PMAPI Applications</a></dt><dd></dd></dl><dl><dt>archive-specific services <a class="link" href="#IG31340177400"><code class="command">pmGetArchiveLabel</code> Function</a></dt><dd></dd></dl><dl><dt>client development <a class="link" href="#IG3134017755">Client Development and PMAPI</a></dt><dd></dd></dl><dl><dt>context services <a class="link" href="#IG31340177321">PMAPI Context Services</a></dt><dd></dd></dl><dl><dt>current context <a class="link" href="#IG31340177265">Current PMAPI Context</a></dt><dd></dd></dl><dl><dt>description <a class="link" href="#IG31340177256">PMAPI--The Performance Metrics API</a></dt><dd></dd></dl><dl><dt>description services <a class="link" href="#IG31340177308"><code class="command">pmLookupDesc</code> Function</a></dt><dd></dd></dl><dl><dt>error handling <a class="link" href="#IG31340177291">PMAPI Error Handling</a> <a class="link" href="#IG31340177457">Handling PMAPI Errors</a></dt><dd></dd></dl><dl><dt>identifying metrics <a class="link" href="#IG31340177261">Naming and Identifying Performance Metrics</a></dt><dd></dd></dl><dl><dt>initializing new metrics <a class="link" href="#IG31340177450">Initializing New Metrics</a></dt><dd></dd></dl><dl><dt>instance domain services <a class="link" href="#IG31340177317"><code class="command">pmGetInDom</code> Function</a></dt><dd></dd></dl><dl><dt>introduction <a class="link" href="#IG313401774">Programming Performance Co-Pilot</a></dt><dd></dd></dl><dl><dt>iterative processing <a class="link" href="#IG31340177453">Iterative Processing of Values</a></dt><dd></dd></dl><dl><dt>man page <a class="link" href="#IG3134017721">Distributed Collection</a></dt><dd></dd></dl><dl><dt>metrics services <a class="link" href="#IG31340177383"><code class="command">pmFetch</code> Function</a></dt><dd></dd></dl><dl><dt>Name Space services <a class="link" href="#IG31340177292"><code class="command">pmGetChildren</code> Function</a></dt><dd></dd></dl><dl><dt>program evolution <a class="link" href="#IG31340177455">Accommodating Program Evolution</a></dt><dd></dd></dl><dl><dt>programming issues <a class="link" href="#IG31340177443">PMAPI Programming Issues and Examples</a> <a class="link" href="#IG31340177444">PMAPI Programming Issues and Examples</a></dt><dd></dd></dl><dl><dt>programming style <a class="link" href="#IG31340177281">PMAPI Programming Style and Interaction</a></dt><dd></dd></dl><dl><dt>record-mode services <a class="link" href="#IG31340177395"><code class="command">pmRecordAddHost</code> Function</a></dt><dd></dd></dl><dl><dt>time control services <a class="link" href="#IG31340177413">PMAPI Time Control Services</a></dt><dd></dd></dl><dl><dt>timezone services <a class="link" href="#IG31340177377"><code class="command">pmNewContextZone</code> Function</a></dt><dd></dd></dl><dl><dt>variable length arguments <a class="link" href="#IG31340177282">Variable Length Argument and Results Lists</a></dt><dd></dd></dl></dd><dt>pmAtomStr function <a class="link" href="#IG31340177174">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177433"><code class="command">pmAtomStr</code> Function</a></dt><dd></dd><dt>pmAtomValue structure <a class="link" href="#IG31340177190">Simple PMDA</a></dt><dd></dd><dt>PMCD</dt><dd><dl><dt>acronym <a class="link" href="#IG31340177573">Acronyms</a></dt><dd></dd></dl><dl><dt>distributed collection <a class="link" href="#IG3134017718">Distributed Collection</a></dt><dd></dd></dl><dl><dt>overview <a class="link" href="#IG3134017713">PCP Architecture</a></dt><dd></dd></dl><dl><dt>pmReconnectContext function <a class="link" href="#IG31340177373"><code class="command">pmReconnectContext</code> Function</a></dt><dd></dd></dl></dd><dt>PMCD_RECONNECT_TIMEOUT variable <a class="link" href="#IG31340177376"><code class="command">pmReconnectContext</code> Function</a></dt><dd></dd><dt>PMCD_REQUEST_TIMOUT variable <a class="link" href="#IG31340177389"><code class="command">pmFetch</code> Function</a></dt><dd></dd><dt>pmchart command <a class="link" href="#IG313401779">PCP Architecture</a> <a class="link" href="#IG3134017769">Implementing a PMDA</a> <a class="link" href="#IG31340177499">Configuring the Trace PMDA</a></dt><dd></dd><dt>pmclient tool <a class="link" href="#IG3134017741">Application and Agent Development</a></dt><dd><dl><dt>brief description <a class="link" href="#IG3134017738">Application and Agent Development</a></dt><dd></dd></dl></dd><dt>pmConvScale function <a class="link" href="#IG31340177173">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177426"><code class="command">pmConvScale</code> Function</a></dt><dd></dd><dt>PMDA</dt><dd><dl><dt>acronym <a class="link" href="#IG31340177575">Acronyms</a></dt><dd></dd></dl><dl><dt>architecture <a class="link" href="#IG3134017778">PMDA Architecture</a></dt><dd></dd></dl><dl><dt>checklist <a class="link" href="#IG3134017766">Implementing a PMDA</a></dt><dd></dd></dl><dl><dt>development <a class="link" href="#IG3134017744">PMDA Development</a></dt><dd></dd></dl><dl><dt>evolution <a class="link" href="#IG31340177161">Management of Evolution within a PMDA</a></dt><dd></dd></dl><dl><dt>help text <a class="link" href="#IG31340177157">PMDA Help Text</a></dt><dd></dd></dl><dl><dt>initialization <a class="link" href="#IG31340177207">Initializing a PMDA</a></dt><dd></dd></dl><dl><dt>Install script <a class="link" href="#IG31340177240">Installing a PMDA</a> <a class="link" href="#IG31340177246">Upgrading a PMNS to Include Metrics from a New PMDA</a></dt><dd></dd></dl><dl><dt>integration <a class="link" href="#IG31340177237">Integration of a PMDA</a></dt><dd></dd></dl><dl><dt>interface <a class="link" href="#IG31340177178">PMDA Interface</a></dt><dd></dd></dl><dl><dt>introduction <a class="link" href="#IG313401773">Programming Performance Co-Pilot</a></dt><dd></dd></dl><dl><dt>man page <a class="link" href="#IG3134017720">Distributed Collection</a></dt><dd></dd></dl><dl><dt>removal <a class="link" href="#IG31340177247">Removing a PMDA</a></dt><dd></dd></dl><dl><dt>structures <a class="link" href="#IG31340177199">PMDA Structures</a></dt><dd></dd></dl><dl><dt>trace <a class="link" href="#IG31340177463">Instrumenting Applications</a></dt><dd></dd></dl><dl><dt>writing <a class="link" href="#IG3134017759">Writing a PMDA</a></dt><dd></dd></dl></dd><dt>pmda library <a class="link" href="#IG3134017742">Application and Agent Development</a></dt><dd><dt>(see PMDA)</dt></dd><dt>mmv library <a class="link" href="#IG3134017742nat">Application and Agent Development</a></dt><dd><dt>(see MMV)</dt></dd><dt>PMDA_PMID macro <a class="link" href="#IG31340177122">Data Structures</a></dt><dd></dd><dt>pmdaAttribute callback <a class="link" href="#IG31340180nat">Overview</a></dt><dd></dd><dt>pmdaChildren callback <a class="link" href="#IG31340179nat">Overview</a></dt><dd></dd><dt>pmdacisco man page <a class="link" href="#IG31340177108">Caching PMDA</a></dt><dd></dd><dt>pmdaConnect man page <a class="link" href="#IG31340177202">PMDA Structures</a> <a class="link" href="#IG31340177223">Daemon Initialization</a></dt><dd></dd><dt>pmdaDaemon man page <a class="link" href="#IG31340177204">PMDA Structures</a> <a class="link" href="#IG31340177220">Daemon Initialization</a></dt><dd></dd><dt>pmdaDesc callback <a class="link" href="#IG31340177182">Overview</a></dt><dd></dd><dt>pmdaDSO man page <a class="link" href="#IG31340177203">PMDA Structures</a></dt><dd></dd><dt>pmdaExt structure <a class="link" href="#IG31340177185">Overview</a> <a class="link" href="#IG31340177201">PMDA Structures</a></dt><dd></dd><dt>pmdaFetch callback <a class="link" href="#IG31340177179">Overview</a> <a class="link" href="#IG31340177214">Trivial PMDA</a></dt><dd></dd><dt>pmdaGetOptions man page <a class="link" href="#IG31340177205">PMDA Structures</a> <a class="link" href="#IG31340177221">Daemon Initialization</a> <a class="link" href="#IG31340177225">Daemon Initialization</a></dt><dd></dd><dt>pmdaIndom structure <a class="link" href="#IG31340177139">Data Structures</a></dt><dd></dd><dt>pmdaInit man page <a class="link" href="#IG31340177142">Data Structures</a> <a class="link" href="#IG31340177206">PMDA Structures</a> <a class="link" href="#IG31340177211">Common Initialization</a> <a class="link" href="#IG31340177212">Common Initialization</a></dt><dd></dd><dt>pmdaInstance callback <a class="link" href="#IG31340177181">Overview</a></dt><dd></dd><dt>pmdaInstid structure <a class="link" href="#IG31340177138">Data Structures</a></dt><dd></dd><dt>pmdaInterface structure <a class="link" href="#IG31340177200">PMDA Structures</a> <a class="link" href="#IG31340177208">Overview</a></dt><dd></dd><dt>pmdaMain man page <a class="link" href="#IG31340177224">Daemon Initialization</a></dt><dd></dd><dt>pmdaMetric structure <a class="link" href="#IG31340177123">Data Structures</a></dt><dd></dd><dt>pmdaName callback <a class="link" href="#IG31340178nat">Overview</a></dt><dd></dd><dt>pmdaOpenLog man page <a class="link" href="#IG31340177222">Daemon Initialization</a></dt><dd></dd><dt>pmdaPMID callback <a class="link" href="#IG31340177nat">Overview</a></dt><dd></dd><dt>pmdaProfile callback <a class="link" href="#IG31340177180">Overview</a></dt><dd></dd><dt>pmdaStore callback <a class="link" href="#IG31340177184">Overview</a> <a class="link" href="#IG31340177196"><code class="literal">simple_store</code> in the Simple PMDA</a></dt><dd></dd><dt>pmdaText callback <a class="link" href="#IG31340177183">Overview</a></dt><dd></dd><dt>pmdatrace man page <a class="link" href="#IG31340177466">Performance Instrumentation and Tracing</a> <a class="link" href="#IG31340177469">Performance Instrumentation and Tracing</a></dt><dd></dd><dt>pmdbg man page <a class="link" href="#IG31340177230">Overview</a> <a class="link" href="#IG31340177231">Debugging Information</a></dt><dd></dd><dt>pmDelProfile function <a class="link" href="#IG31340177323">PMAPI Context Services</a> <a class="link" href="#IG31340177364"><code class="command">pmDelProfile</code> Function</a></dt><dd></dd><dt>pmDesc structure <a class="link" href="#IG31340177119">Data Structures</a> <a class="link" href="#IG31340177164">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177268">Performance Metric Descriptions</a> <a class="link" href="#IG31340177274">Performance Metric Descriptions</a></dt><dd></dd><dt>pmDestroyContext function <a class="link" href="#IG31340177354"><code class="command">pmDestroyContext</code> Function</a></dt><dd></dd><dt>pmDupContext function <a class="link" href="#IG31340177324">PMAPI Context Services</a> <a class="link" href="#IG31340177355"><code class="command">pmDupContext</code> Function</a></dt><dd></dd><dt>pmErrStr function <a class="link" href="#IG31340177419"><code class="command">pmErrStr</code> Function</a></dt><dd></dd><dt>pmExtractValue function <a class="link" href="#IG31340177172">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177420"><code class="command">pmExtractValue</code> Function</a> <a class="link" href="#IG31340177428"><code class="command">pmConvScale</code> Function</a></dt><dd></dd><dt>pmFetch function <a class="link" href="#IG31340177275">Performance Metrics Values</a> <a class="link" href="#IG31340177280">Performance Metrics Values</a> <a class="link" href="#IG31340177289">Variable Length Argument and Results Lists</a> <a class="link" href="#IG31340177325">PMAPI Context Services</a> <a class="link" href="#IG31340177351"><code class="command">pmNewContext</code> Function</a> <a class="link" href="#IG31340177370"><code class="command">pmSetMode</code> Function</a> <a class="link" href="#IG31340177385"><code class="command">pmFetch</code> Function</a> <a class="link" href="#IG31340177387"><code class="command">pmFetch</code> Function</a> <a class="link" href="#IG31340177390"><code class="command">pmFreeResult</code> Function</a> <a class="link" href="#IG31340177411"><code class="command">pmFetchArchive</code> Function</a> <a class="link" href="#IG31340177435"><code class="command">pmPrintValue</code> Function</a> <a class="link" href="#IG31340177440"><code class="command">pmSortInstances</code> Function</a> <a class="link" href="#IG31340177449">Symbolic Association between a Metric's Name and Value</a></dt><dd></dd><dt>pmFetch man page <a class="link" href="#IG3134017782">Overview</a> <a class="link" href="#IG31340177166">Management of Evolution within a PMDA</a></dt><dd></dd><dt>pmFetchArchive function <a class="link" href="#IG31340177326">PMAPI Context Services</a> <a class="link" href="#IG31340177369"><code class="command">pmSetMode</code> Function</a> <a class="link" href="#IG31340177412"><code class="command">pmFetchArchive</code> Function</a></dt><dd></dd><dt>pmflush function <a class="link" href="#IG31340177437"><code class="command">pmflush</code> Function</a></dt><dd></dd><dt>pmFreeResult function <a class="link" href="#IG31340177290">Variable Length Argument and Results Lists</a> <a class="link" href="#IG31340177386"><code class="command">pmFetch</code> Function</a> <a class="link" href="#IG31340177391"><code class="command">pmFreeResult</code> Function</a></dt><dd></dd><dt>pmgadgets command <a class="link" href="#IG3134017770">Implementing a PMDA</a></dt><dd></dd><dt>pmgenmap tool <a class="link" href="#IG3134017743">Application and Agent Development</a></dt><dd></dd><dt>pmGetArchiveEnd function <a class="link" href="#IG31340177327">PMAPI Context Services</a> <a class="link" href="#IG31340177403"><code class="command">pmGetArchiveEnd</code> Function</a></dt><dd></dd><dt>pmGetArchiveLabel function <a class="link" href="#IG31340177328">PMAPI Context Services</a> <a class="link" href="#IG31340177399"><code class="command">pmGetArchiveLabel</code> Function</a></dt><dd></dd><dt>pmGetChildren function <a class="link" href="#IG3134017785nat">Overview</a> <a class="link" href="#IG31340177288">Variable Length Argument and Results Lists</a> <a class="link" href="#IG31340177293"><code class="command">pmGetChildren</code> Function</a> <a class="link" href="#IG31340177294"><code class="command">pmGetChildrenStatus</code> Function</a> <a class="link" href="#IG31340177329">PMAPI Context Services</a></dt><dd></dd><dt>pmGetChildrenStatus function <a class="link" href="#IG31340177330">PMAPI Context Services</a></dt><dd></dd><dt>pmGetContextHostName function <a class="link" href="#IG31340177330nat">PMAPI Context Services</a></dt><dd></dd><dt>pmGetInDom function <a class="link" href="#IG3134017786">Overview</a> <a class="link" href="#IG31340177286">Variable Length Argument and Results Lists</a> <a class="link" href="#IG31340177316"><code class="command">pmGetInDom</code> Function</a> <a class="link" href="#IG31340177332">PMAPI Context Services</a> <a class="link" href="#IG31340177367"><code class="command">pmSetMode</code> Function</a> <a class="link" href="#IG31340177408"><code class="command">pmGetInDomArchive</code> Function</a></dt><dd></dd><dt>pmGetInDomArchive function <a class="link" href="#IG31340177333">PMAPI Context Services</a> <a class="link" href="#IG31340177407"><code class="command">pmGetInDomArchive</code> Function</a></dt><dd></dd><dt>pmGetPMNSLocation function <a class="link" href="#IG31340177295"><code class="command">pmGetPMNSLocation</code> Function</a> <a class="link" href="#IG31340177331">PMAPI Context Services</a></dt><dd></dd><dt>PMID</dt><dd><dl><dt>acronym <a class="link" href="#IG31340177576">Acronyms</a></dt><dd></dd></dl><dl><dt>introduction <a class="link" href="#IG3134017724">Name Space</a></dt><dd></dd></dl></dd><dt>pmIDStr function <a class="link" href="#IG31340177430"><code class="command">pmIDStr</code> Function</a></dt><dd></dd><dt>pmie command <a class="link" href="#IG3134017772">Implementing a PMDA</a> <a class="link" href="#IG31340177252">Configuring PCP Tools</a></dt><dd></dd><dt>pmieconf command <a class="link" href="#IG3134017773">Implementing a PMDA</a> <a class="link" href="#IG31340177253">Configuring PCP Tools</a></dt><dd></dd><dt>pmInDomStr function <a class="link" href="#IG31340177431"><code class="command">pmInDomStr</code> Function</a></dt><dd></dd><dt>pmLoadNameSpace function <a class="link" href="#IG31340177296"><code class="command">pmLoadNameSpace</code> Function</a></dt><dd></dd><dt>pmlogconf command <a class="link" href="#IG31340177255">Configuring PCP Tools</a></dt><dd></dd><dt>pmlogger command <a class="link" href="#IG3134017776">Implementing a PMDA</a> <a class="link" href="#IG31340177254">Configuring PCP Tools</a></dt><dd></dd><dt>pmLookupDesc function <a class="link" href="#IG3134017788">Overview</a> <a class="link" href="#IG31340177120">Data Structures</a> <a class="link" href="#IG31340177163">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177307"><code class="command">pmLookupDesc</code> Function</a> <a class="link" href="#IG31340177334">PMAPI Context Services</a> <a class="link" href="#IG31340177368"><code class="command">pmSetMode</code> Function</a> <a class="link" href="#IG31340177421"><code class="command">pmExtractValue</code> Function</a> <a class="link" href="#IG31340177427"><code class="command">pmConvScale</code> Function</a></dt><dd></dd><dt>pmLookupInDom function <a class="link" href="#IG31340177318"><code class="command">pmLookupInDom</code> Function</a> <a class="link" href="#IG31340177335">PMAPI Context Services</a> <a class="link" href="#IG31340177366"><code class="command">pmSetMode</code> Function</a></dt><dd></dd><dt>pmLookupInDomArchive function <a class="link" href="#IG31340177336">PMAPI Context Services</a> <a class="link" href="#IG31340177409"><code class="command">pmLookupInDomArchive</code> Function</a></dt><dd></dd><dt>pmLookupInDomText function <a class="link" href="#IG31340177310"><code class="command">pmLookupInDomText</code> Function</a> <a class="link" href="#IG31340177337">PMAPI Context Services</a></dt><dd></dd><dt>pmLookupName function <a class="link" href="#IG3134017782nat">Overview</a> <a class="link" href="#IG31340177298"><code class="command">pmLookupName</code> Function</a> <a class="link" href="#IG31340177338">PMAPI Context Services</a> <a class="link" href="#IG31340177448">Symbolic Association between a Metric's Name and Value</a></dt><dd></dd><dt>pmLookupText function <a class="link" href="#IG3134017790">Overview</a> <a class="link" href="#IG31340177168">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177285">Variable Length Argument and Results Lists</a> <a class="link" href="#IG31340177312"><code class="command">pmLookupText</code> Function</a> <a class="link" href="#IG31340177339">PMAPI Context Services</a></dt><dd></dd><dt>pmNameAll function <a class="link" href="#IG31340177299"><code class="command">pmNameAll</code> Function</a></dt><dd></dd><dt>pmNameID function <a class="link" href="#IG31340177287">Variable Length Argument and Results Lists</a> <a class="link" href="#IG31340177300"><code class="command">pmNameID</code> Function</a> <a class="link" href="#IG31340177340">PMAPI Context Services</a></dt><dd></dd><dt>pmNameInDom function <a class="link" href="#IG31340177284">Variable Length Argument and Results Lists</a> <a class="link" href="#IG31340177319"><code class="command">pmNameInDom</code> Function</a> <a class="link" href="#IG31340177341">PMAPI Context Services</a> <a class="link" href="#IG31340177365"><code class="command">pmSetMode</code> Function</a></dt><dd></dd><dt>pmNameInDomArchive function <a class="link" href="#IG31340177342">PMAPI Context Services</a> <a class="link" href="#IG31340177410"><code class="command">pmNameInDomArchive</code> Function</a></dt><dd></dd><dt>pmNewContext function <a class="link" href="#IG31340177350"><code class="command">pmNewContext</code> Function</a></dt><dd></dd><dt>pmNewContextZone function <a class="link" href="#IG31340177379"><code class="command">pmNewContextZone</code> Function</a></dt><dd></dd><dt>pmNewZone function <a class="link" href="#IG31340177380"><code class="command">pmNewZone</code> Function</a></dt><dd></dd><dt>PMNS</dt><dd><dl><dt>acronym <a class="link" href="#IG31340177577">Acronyms</a></dt><dd></dd></dl><dl><dt>distributed <a class="link" href="#IG3134017729">Distributed PMNS</a></dt><dd></dd></dl><dl><dt>upgrade <a class="link" href="#IG31340177245">Upgrading a PMNS to Include Metrics from a New PMDA</a></dt><dd></dd></dl></dd><dt>pmns man page <a class="link" href="#IG31340177154">Name Space</a></dt><dd></dd><dt>pmNumberStr function <a class="link" href="#IG31340177434"><code class="command">pmNumberStr</code> Function</a></dt><dd></dd><dt>pmParseInterval function <a class="link" href="#IG31340177441"><code class="command">pmParseInterval</code> Function</a></dt><dd></dd><dt>pmParseMetricSpec function <a class="link" href="#IG31340177442"><code class="command">pmParseMetricSpec</code> Function</a></dt><dd></dd><dt>pmprintf function <a class="link" href="#IG31340177438"><code class="command">pmprintf</code> Function</a></dt><dd></dd><dt>pmPrintValue function <a class="link" href="#IG31340177176">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177436"><code class="command">pmPrintValue</code> Function</a></dt><dd></dd><dt>pmReconnectContext function <a class="link" href="#IG31340177374"><code class="command">pmReconnectContext</code> Function</a></dt><dd></dd><dt>pmRecordAddHost function <a class="link" href="#IG31340177394"><code class="command">pmRecordAddHost</code> Function</a></dt><dd></dd><dt>pmRecordControl function <a class="link" href="#IG31340177397"><code class="command">pmRecordControl</code> Function</a></dt><dd></dd><dt>pmRecordSetup function <a class="link" href="#IG31340177398"><code class="command">pmRecordSetup</code> Function</a></dt><dd></dd><dt>pmSetMode function <a class="link" href="#IG31340177343">PMAPI Context Services</a> <a class="link" href="#IG31340177371"><code class="command">pmSetMode</code> Function</a> <a class="link" href="#IG31340177404"><code class="command">pmGetArchiveEnd</code> Function</a></dt><dd></dd><dt>pmSortInstances function <a class="link" href="#IG31340177439"><code class="command">pmSortInstances</code> Function</a></dt><dd></dd><dt>pmstore function <a class="link" href="#IG3134017793">Overview</a> <a class="link" href="#IG31340177117">Metrics</a> <a class="link" href="#IG31340177171">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177195"><code class="literal">simple_store</code> in the Simple PMDA</a> <a class="link" href="#IG31340177235">Debugging Information</a> <a class="link" href="#IG31340177276">Performance Metrics Values</a> <a class="link" href="#IG31340177344">PMAPI Context Services</a> <a class="link" href="#IG31340177392"><code class="command">pmStore</code> Function</a> <a class="link" href="#IG31340177393"><code class="command">pmStore</code> Function</a></dt><dd></dd><dt>PMTRACE_STATE_API flag <a class="link" href="#IG31340177538">Configuring the Trace Library</a></dt><dd></dd><dt>PMTRACE_STATE_ASYNC flag <a class="link" href="#IG31340177547">Configuring the Trace Library</a></dt><dd></dd><dt>PMTRACE_STATE_COMMS flag <a class="link" href="#IG31340177539">Configuring the Trace Library</a></dt><dd></dd><dt>PMTRACE_STATE_NOAGENT flag <a class="link" href="#IG31340177543">Configuring the Trace Library</a> <a class="link" href="#IG31340177544">Configuring the Trace Library</a></dt><dd></dd><dt>PMTRACE_STATE_NONE flag <a class="link" href="#IG31340177536">Configuring the Trace Library</a></dt><dd></dd><dt>PMTRACE_STATE_PDU flag <a class="link" href="#IG31340177540">Configuring the Trace Library</a></dt><dd></dd><dt>PMTRACE_STATE_PDUBUF flag <a class="link" href="#IG31340177541">Configuring the Trace Library</a></dt><dd></dd><dt>pmtraceabort function <a class="link" href="#IG31340177507">Transactions </a></dt><dd></dd><dt>pmtracebegin function <a class="link" href="#IG31340177504">Transactions </a></dt><dd></dd><dt>pmtracend function <a class="link" href="#IG31340177505">Transactions </a></dt><dd></dd><dt>pmtraceobs function <a class="link" href="#IG31340177518">Observations and Counters</a></dt><dd></dd><dt>pmtracepoint function <a class="link" href="#IG31340177515">Point Tracing </a> <a class="link" href="#IG31340177519">Observations and Counters</a></dt><dd></dd><dt>pmtracestate call <a class="link" href="#IG31340177534">Configuring the Trace Library</a></dt><dd></dd><dt>pmTraversePMNS function <a class="link" href="#IG3134017786nat">Overview</a> <a class="link" href="#IG31340177301"><code class="command">pmTraversePMNS</code> Function</a> <a class="link" href="#IG31340177345">PMAPI Context Services</a></dt><dd></dd><dt>__pmParseHostAttrsSpec function <a class="link" href="#IG3134017790nat">Overview</a></dt><dd></dd><dt>pmTypeStr function <a class="link" href="#IG31340177175">Management of Evolution within a PMDA</a> <a class="link" href="#IG31340177432"><code class="command">pmTypeStr</code> Function</a></dt><dd></dd><dt>pmUnitsStr function <a class="link" href="#IG31340177429"><code class="command">pmUnitsStr</code> Function</a></dt><dd></dd><dt>pmUnloadNameSpace function <a class="link" href="#IG31340177304"><code class="command">pmUnloadNameSpace</code> Function</a></dt><dd></dd><dt>pmUnpackEventRecords function <a class="link" href="#IG31340177280nat">Event Monitor Considerations</a></dt><dd></dd><dt>pmUseContext function <a class="link" href="#IG31340177353"><code class="command">pmNewContext</code> Function</a> <a class="link" href="#IG31340177356"><code class="command">pmUseContext</code> Function</a></dt><dd></dd><dt>pmUseZone function <a class="link" href="#IG31340177381"><code class="command">pmUseZone</code> Function</a></dt><dd></dd><dt>pmWhichContext function <a class="link" href="#IG31340177358"><code class="command">pmWhichContext</code> Function</a></dt><dd></dd><dt>pmWhichZone function <a class="link" href="#IG31340177382"><code class="command">pmWhichZone</code> Function</a></dt><dd></dd><dt>point tracing <a class="link" href="#IG31340177514">Point Tracing </a></dt><dd></dd><dt>program evolution <a class="link" href="#IG31340177456">Accommodating Program Evolution</a></dt><dd></dd><dt>programming components <a class="link" href="#IG313401771">Programming Performance Co-Pilot</a></dt><dd></dd><dt>protocol data units</dt><dd><dt>(see PDU)</dt></dd><dt>pthreads man page <a class="link" href="#IG31340177152">Latency and Threads of Control</a></dt><dd></dd><dt>record-mode services <a class="link" href="#IG31340177396"><code class="command">pmRecordAddHost</code> Function</a></dt><dd></dd><dt>removal script <a class="link" href="#IG31340177248">Removing a PMDA</a></dt><dd></dd><dt>restarting pmcd <a class="link" href="#IG31340177242">Installing a PMDA</a></dt><dd></dd><dt>retrospective analysis <a class="link" href="#IG3134017730">Retrospective Sources of Performance Metrics</a></dt><dd></dd><dt>ring buffers <a class="link" href="#IG31340177490">Rolling-Window Periodic Sampling</a></dt><dd></dd><dt>rolling-window sampling <a class="link" href="#IG31340177477">Sampling Techniques</a> <a class="link" href="#IG31340177488">Rolling-Window Periodic Sampling</a></dt><dd></dd><dt>sample duration <a class="link" href="#IG31340177489">Rolling-Window Periodic Sampling</a> <a class="link" href="#IG31340177496">Configuring the Trace PMDA</a></dt><dd></dd><dt>sampling techniques <a class="link" href="#IG31340177478">Sampling Techniques</a></dt><dd></dd><dt>scale and dimensionality <a class="link" href="#IG31340177273">Performance Metric Descriptions</a></dt><dd></dd><dt>semantic types <a class="link" href="#IG31340177127">Semantics</a></dt><dd></dd><dt>sequential log files <a class="link" href="#IG3134017763">Implementing a PMDA</a></dt><dd></dd><dt>service time <a class="link" href="#IG31340177558">Instrumenting Applications</a></dt><dd></dd><dt>simple periodic sampling <a class="link" href="#IG31340177486">Simple Periodic Sampling</a></dt><dd></dd><dt>simple PMDA</dt><dd><dl><dt>2 branches, 4 metrics <a class="link" href="#IG31340177156">Name Space</a></dt><dd></dd></dl><dl><dt>as daemon <a class="link" href="#IG31340177105">Daemon PMDA</a></dt><dd></dd></dl><dl><dt>DSO <a class="link" href="#IG3134017797">DSO PMDA</a></dt><dd></dd></dl><dl><dt>initialization <a class="link" href="#IG31340177216">Simple PMDA</a></dt><dd></dd></dl><dl><dt>pmdaFetch callback <a class="link" href="#IG31340177188">Simple PMDA</a></dt><dd></dd></dl></dd><dt>simple_init function <a class="link" href="#IG3134017799">DSO PMDA</a> <a class="link" href="#IG31340177189">Simple PMDA</a> <a class="link" href="#IG31340177217">Simple PMDA</a></dt><dd></dd><dt>simple_store function <a class="link" href="#IG31340177234">Debugging Information</a></dt><dd></dd><dt>simple.color metric <a class="link" href="#IG31340177191">Simple PMDA</a></dt><dd></dd><dt>simple.now metric <a class="link" href="#IG31340177193">Simple PMDA</a></dt><dd></dd><dt>simple.store metric <a class="link" href="#IG31340177194"><code class="literal">simple_store</code> in the Simple PMDA</a></dt><dd></dd><dt>simple.time metric <a class="link" href="#IG31340177192">Simple PMDA</a></dt><dd></dd><dt>snapshot files <a class="link" href="#IG3134017764">Implementing a PMDA</a></dt><dd></dd><dt>software <a class="link" href="#IG3134017732">Overview of Component Software</a></dt><dd></dd><dt>specific instance domain <a class="link" href="#IG31340177346">PMAPI Context Services</a></dt><dd></dd><dt>state flags <a class="link" href="#IG31340177523">Configuring the Trace Library</a> <a class="link" href="#IG31340177532">Configuring the Trace Library</a></dt><dd></dd><dt>storage of metrics <a class="link" href="#IG31340177116">Metrics</a></dt><dd></dd><dt>symbolic association <a class="link" href="#IG31340177446">Symbolic Association between a Metric's Name and Value</a></dt><dd></dd><dt>synchronous protocol <a class="link" href="#IG31340177537">Configuring the Trace Library</a></dt><dd></dd><dt>target domain <a class="link" href="#IG3134017762">Implementing a PMDA</a> <a class="link" href="#IG31340177115">Metrics</a> <a class="link" href="#IG31340177148">Extracting the Information</a></dt><dd></dd><dt>TCP/IP <a class="link" href="#IG31340177527">Configuring the Trace Library</a> <a class="link" href="#IG31340177578">Acronyms</a></dt><dd></dd><dt>testing and debugging <a class="link" href="#IG31340177226">Testing and Debugging a PMDA</a></dt><dd></dd><dt>threaded applications <a class="link" href="#IG3134017756">Library Reentrancy and Threaded Applications</a></dt><dd></dd><dt>time control services <a class="link" href="#IG31340177414">PMAPI Time Control Services</a></dt><dd></dd><dt>timezone services <a class="link" href="#IG31340177378"><code class="command">pmNewContextZone</code> Function</a></dt><dd></dd><dt>tool configuration <a class="link" href="#IG31340177250">Configuring PCP Tools</a></dt><dd></dd><dt>trace facilities <a class="link" href="#IG313401776">Programming Performance Co-Pilot</a></dt><dd></dd><dt>trace PMDA</dt><dd><dl><dt>command-line options <a class="link" href="#IG31340177494">Configuring the Trace PMDA</a></dt><dd></dd></dl><dl><dt>description <a class="link" href="#IG31340177462">Instrumenting Applications</a></dt><dd></dd></dl><dl><dt>design <a class="link" href="#IG31340177470">Trace PMDA Design</a></dt><dd></dd></dl></dd><dt>trace.control.reset metric <a class="link" href="#IG31340177501">Configuring the Trace PMDA</a></dt><dd></dd><dt>trace.observe metrics <a class="link" href="#IG31340177520">Observations and Counters</a></dt><dd></dd><dt>trace.observe.rate metric <a class="link" href="#IG31340177479">Sampling Techniques</a></dt><dd></dd><dt>trace.point.count metric <a class="link" href="#IG31340177516">Point Tracing </a></dt><dd></dd><dt>trace.point.rate metric <a class="link" href="#IG31340177517">Point Tracing </a> <a class="link" href="#IG31340177480">Sampling Techniques</a></dt><dd></dd><dt>trace.transact.ave_time metric <a class="link" href="#IG31340177481">Sampling Techniques</a> <a class="link" href="#IG31340177508">Transactions </a></dt><dd></dd><dt>trace.transact.count metric <a class="link" href="#IG31340177509">Transactions </a></dt><dd></dd><dt>trace.transact.max_time metric <a class="link" href="#IG31340177482">Sampling Techniques</a> <a class="link" href="#IG31340177510">Transactions </a></dt><dd></dd><dt>trace.transact.min_time metric <a class="link" href="#IG31340177483">Sampling Techniques</a> <a class="link" href="#IG31340177511">Transactions </a></dt><dd></dd><dt>trace.transact.rate metric <a class="link" href="#IG31340177484">Sampling Techniques</a> <a class="link" href="#IG31340177512">Transactions </a></dt><dd></dd><dt>trace.transact.total_time metric <a class="link" href="#IG31340177513">Transactions </a></dt><dd></dd><dt>transactions <a class="link" href="#IG31340177506">Transactions </a></dt><dd></dd><dt>trivial PMDA</dt><dd><dl><dt>callbacks <a class="link" href="#IG31340177186">Trivial PMDA</a></dt><dd></dd></dl><dl><dt>initialization <a class="link" href="#IG31340177213">Trivial PMDA</a></dt><dd></dd></dl><dl><dt>singular metric <a class="link" href="#IG31340177124">Data Structures</a></dt><dd></dd></dl></dd><dt>trivial_init function <a class="link" href="#IG31340177187">Trivial PMDA</a> <a class="link" href="#IG31340177215">Trivial PMDA</a></dt><dd></dd><dt>two or three dimensional arrays <a class="link" href="#IG31340177135">N Dimensional Data</a></dt><dd></dd><dt>type field <a class="link" href="#IG31340177170">Management of Evolution within a PMDA</a></dt><dd></dd><dt>unavailable metrics support <a class="link" href="#IG31340177162">Management of Evolution within a PMDA</a></dt><dd></dd><dt>working buffers <a class="link" href="#IG31340177476">Application Interaction</a> <a class="link" href="#IG31340177491">Rolling-Window Periodic Sampling</a></dt><dd></dd></dl></div></div></body></html>